{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Stake Development Kit","text":""},{"location":"#powered-by-carrotrgs","title":"Powered by CarrotRGS","text":""},{"location":"#complex-games-made-easy","title":"Complex Games Made Easy","text":"<p>The Stake Development Kit is a comprehensive framework designed to simplify the creation, simulation, and optimization of slot games. Whether you're an independent developer or part of a dedicated studio, the SDK empowers you to bring your gaming vision to life with precision and efficiency. By leveraging the Carrot Remote Gaming Server (RGS), developers can seamlessly integrate their games on Stake.com, facilitating smooth and scalable deployments.</p>"},{"location":"#what-does-the-sdk-offer","title":"What Does the SDK Offer?","text":"<p>The SDK is an optional software package handling both the client-side rendering of games in-browser, and the generation of static files containing all possible game results.</p> <ol> <li> <p>Math Framework: A Python-based engine for defining game rules, simulating outcomes, and optimizing win distributions. It generates all necessary backend and configuration files, lookup tables, and simulation results.</p> </li> <li> <p>Frontend Framework: A PixieJS/Svelte-based toolkit for creating visually engaging slot games. This component integrates seamlessly with the math engine's outputs, ensuring consistency between game logic and player experience.</p> </li> </ol>"},{"location":"#stake-engine-game-format-criteria","title":"Stake Engine Game Format Criteria","text":"<p>For verification, testing and security purposes, games uploaded to Stake Engine must consist of static files. Developers utilizing their own frontend and/or math solutions are welcome to upload compatible file-formats to the Admin Control Panel (ACP). All possible game-outcomes must be contained within compressed game-files, typically separated out by modes. Each outcome must be mapped to a corresponding CSV file summarizing a single game-round by a simulation number, probability of selection, and final payout multiplier. When a betting round is initiated a simulation number is selected at a frequency proportional to the simulation weighting, and the corresponding game events are returned though the /play API response.</p> <p></p>"},{"location":"books_formatting/","title":"Books Formatting Integration","text":"<p>This document describes the automatic formatting setup for books files (<code>.jsonl</code>) that is integrated into the simulation workflow.</p>"},{"location":"books_formatting/#overview","title":"Overview","text":"<p>Every time you run <code>make run GAME=&lt;game_name&gt;</code>, the system will automatically format all <code>.jsonl</code> files in the specified game directory after the simulation completes.</p>"},{"location":"books_formatting/#what-it-does","title":"What it does","text":"<ol> <li>Runs the simulation - Executes the normal game simulation process</li> <li>Formats books files - Automatically formats all <code>.jsonl</code> files found in the game directory</li> <li>Smart JSON formatting - Pretty-prints JSON while keeping simple name objects like <code>{\"name\": \"L1\"}</code> compact on single lines</li> </ol>"},{"location":"books_formatting/#files-involved","title":"Files involved","text":"<ul> <li>Makefile - Updated <code>run</code> target to include formatting step</li> <li>scripts/format_books_json.py - Python script that handles the formatting logic with advanced JSON processing</li> </ul>"},{"location":"books_formatting/#how-it-works","title":"How it works","text":"<p>The formatting script (<code>scripts/format_books_json.py</code>) performs the following:</p> <ol> <li>JSONL Processing - Searches for all <code>.jsonl</code> files in the specified game directory</li> <li>JSON Parsing - Uses Python's built-in <code>json</code> module to safely parse each line</li> <li>Smart Formatting - Pretty-prints JSON with 2-space indentation while keeping simple objects compact:</li> <li>Simple name objects like <code>{\"name\": \"L1\"}</code> stay on single lines</li> <li>Complex objects are pretty-printed for readability</li> <li>Error Recovery - Includes advanced error handling and JSONL reconstruction for corrupted files</li> <li>Format Validation - Ensures output maintains valid JSONL format (one JSON object per line)</li> </ol>"},{"location":"books_formatting/#benefits","title":"Benefits","text":"<ul> <li>Smart formatting - Pretty-printed JSON for readability with compact simple objects</li> <li>Consistent structure - All books files have uniform formatting standards</li> <li>Version control friendly - Readable format is better for code reviews and diffs</li> <li>Automatic - No manual intervention required</li> <li>Robust - Advanced error handling and JSONL reconstruction capabilities</li> <li>Fast - Efficient Python JSON processing</li> </ul>"},{"location":"books_formatting/#example-formatting","title":"Example formatting","text":"<p>Before formatting (raw JSONL):</p> <pre><code>{\"id\": 1, \"events\": [{\"type\": \"reveal\", \"board\": [[{\"name\": \"L1\"}, {\"name\": \"H1\"}]]}]}\n</code></pre> <p>After formatting:</p> <pre><code>{\n  \"id\": 1,\n  \"events\": [\n    {\n      \"type\": \"reveal\", \n      \"board\": [\n        [\n          {\"name\": \"L1\"},\n          {\"name\": \"H1\"}\n        ]\n      ]\n    }\n  ]\n}\n</code></pre> <p>Notice how simple name objects like <code>{\"name\": \"L1\"}</code> remain compact on single lines while the overall structure is pretty-printed.</p>"},{"location":"books_formatting/#usage","title":"Usage","text":"<p>Simply run your simulation as usual:</p> <pre><code>make run GAME=0_0_tower_defense\n</code></pre> <p>The formatting will happen automatically after the simulation completes.</p>"},{"location":"books_formatting/#requirements","title":"Requirements","text":"<ul> <li>Python 3 - For running the formatting script (uses built-in json module)</li> <li>Virtual environment - Script runs in the project's Python virtual environment</li> </ul>"},{"location":"books_formatting/#error-handling","title":"Error handling","text":"<ul> <li>Graceful failures - If formatting fails for any reason, a warning is displayed but the build continues</li> <li>JSONL reconstruction - Automatically attempts to repair corrupted JSONL files</li> <li>Invalid line skipping - Lines that cannot be parsed as valid JSON are skipped with warnings</li> <li>Detailed error reporting - Shows specific error messages and line numbers for debugging</li> </ul>"},{"location":"books_formatting/#example-output","title":"Example output","text":"<pre><code>Formatting books files...\n  Formatting: games/0_0_tower_defense/library/books/books_bonus.jsonl\n  \u2705 Formatted: games/0_0_tower_defense/library/books/books_bonus.jsonl (100 lines processed)\n  Formatting: games/0_0_tower_defense/library/books/books_base.jsonl\n  \u2705 Formatted: games/0_0_tower_defense/library/books/books_base.jsonl (100 lines processed)\nBooks formatting complete! (200 total lines processed)\n</code></pre>"},{"location":"fe_home/","title":"Stake Engine Software Development Kit","text":""},{"location":"fe_home/#frontend-sdk","title":"Frontend - SDK","text":""},{"location":"fe_home/#why-use-the-frontend-sdk","title":"Why Use the frontend SDK?","text":"<p>The frontend-sdk is a PixieJS/Svelte package used for developing web-based slot games in a declarative way. This package walks though how to utilize powerful tools such as Turborepo and Storybook to test and publish slot games. Sample slot games are provided which consume outputs provided by the math-sdk, though the repo is customizable and can be tailored to accommodate custom events for slot games covering all levels of complexity.</p> <p>See Frontend SDK Technical Details for more details.</p>"},{"location":"math_home/","title":"Stake Engine - Software Development Kit","text":""},{"location":"math_home/#math-sdk","title":"Math - SDK","text":""},{"location":"math_home/#why-use-the-math-sdk","title":"Why Use the Math SDK?","text":"<p>Traditionally, developing slot games involves navigating complex mathematical models to balance payouts, hit rates, and player engagement. This process can be time-consuming and resource-intensive. The Carrot Math SDK eliminates these challenges by providing:</p> <ul> <li>Predefined Frameworks: Start with customizable templates or sample games to accelerate development.</li> <li>Mathematical Precision: Simulate and optimize win distributions using discrete outcome probabilities, ensuring strict control over game mechanics.</li> <li>Seamless Integration: Outputs are formatted to align with the Carrot RGS, enabling quick deployment to production environments.</li> <li>Scalability: Built-in multithreading and optimization tools allow for efficient handling of large-scale simulations.</li> </ul>"},{"location":"math_home/#who-is-this-for","title":"Who Is This For?","text":"<p>The Carrot Math SDK is ideal for developers looking to:</p> <ul> <li>Create custom slot games with unique mechanics.</li> <li>Optimize game payouts and hit rates without relying on extensive manual calculations.</li> <li>Generate detailed simulation outputs for statistical analysis.</li> <li>Publish games on Stake.com with minimal friction.</li> </ul>"},{"location":"math_home/#static-file-outputs","title":"Static File Outputs","text":"<p>Physical slot-machines (and many of those used in iGaming) generate results in real time by programming game-logic onto the RGS/backend. When a game is requested, a cryptographically secure random number generator selects a random reel-stop position for every active reel, and the game-logic flows from the starting board position. The drawbacks of this method is that since a single reel-strip could easily have 100+ symbols, with typically 5 reels, there are 100^5 (10 billion) unique board combinations.Explicitly calculating game payouts or Return to Player (RTP) is often infeasible, so extensive simulations are used to estimate outcomes. Stake Engine requires all game-outcomes to be known at the time of publication. Storing instructions for all possible game outcomes is impractical. Instead, a subset of results is used to define the game.</p> <p>These outputs are broken up into two main parts: 1. game logic files and 2. CSV payout summaries.  The game-logic files contain an ordered list of critical game details such as symbol names, board positions, payout amounts, winning symbol positions etc... Accompanying each simulation detailed in the game logic files is a CSV entry listing the simulation number, probability of selection, and payout amount. So upon a game round request, the RGS will consult the CSV/lookup table to select a simulation number, then return a JSON response from the game-logic file for this simulation number to the frontend, telling the web-client what to render, while also updating the players wallet with the payout amount. Breaking up these two files also allows us to exactly calculate the games RTP and essential win-distribution statistics at time of publication. </p>"},{"location":"math_home/#get-started-today","title":"Get Started Today","text":"<p>Dive into the technical details and explore how the Carrot Math SDK can transform your game development process. With powerful tools, sample games, and detailed documentation, you'll have everything you need to create engaging and mathematically sound games.</p> <p>See Math SDK Technical Details for more details.</p>"},{"location":"fe_docs/context/","title":"Context","text":"<ul> <li>ContextEventEmitter</li> <li>ContextLayout</li> <li>ContextXstate</li> <li>ContextApp</li> </ul> <p> svelte-context is a useful feature from svelte especially when a shared state requires some inputs/types to create. Here it shows the structure of context of sample game <code>/apps/lines</code>. As showed before, <code>setContext()</code> is called at entry level component. For example, <code>apps/lines/src/routes/+page.svelte</code> or <code>apps/lines/src/stories/ComponentsGame.stories.svelte</code>. It sets four major contexts from the packages by this:</p> <pre><code>// context.ts - Example of setContext in apps\n\nexport const setContext = () =&gt; {\n  setContextEventEmitter&lt;EmitterEvent&gt;({ eventEmitter });\n  setContextXstate({ stateXstate, stateXstateDerived });\n  setContextLayout({ stateLayout, stateLayoutDerived });\n  setContextApp({ stateApp });\n};\n</code></pre> <p>Different apps and packages require different contexts.</p> <p></p> <p></p>"},{"location":"fe_docs/context/#contexteventemitter","title":"ContextEventEmitter","text":"<p><code>eventEmitter</code> is created by <code>packages/utils-event-emitter/src/createEventEmitter.ts</code>. We have covered eventEmitter in the previous content.</p> <p></p>"},{"location":"fe_docs/context/#contextlayout","title":"ContextLayout","text":"<p><code>stateLayout</code> and <code>stateLayoutDerived</code> are created by <code>packages/utils-layout/src/createLayout.svelte.ts</code>. It provides canvasSizes, canvasRatio, layoutType and so on. Because we have a setting <code>resizeTo: window</code> for PIXI.Application, we use the sizes of window from svelte-reactivity as <code>canvasSizes</code>.</p> <p>For html, the tags will auto-flow by default. However, in the canvas/pixijs we need to set positions manually to avoid overlapping. The importance of LayoutContext is that it provides us the values of boundaries (canvasSizes), device type based on the dimensions (layoutType) and so on. For example:</p> <ul> <li>Set a pixi-svelte component to the left edge of the canvas:</li> <li><code>&lt;Component x={0} /&gt;</code></li> <li>Set a pixi-svelte component to the right edge of the canvas:</li> <li><code>&lt;Component x={context.stateLayoutDerived.canvasSizes().width} anchor={{ x: 1: y: 0 }} /&gt;</code></li> <li>It works when <code>&lt;App /&gt;</code> is the parent of the component, otherwise it will be determined by its parent <code>&lt;Container /&gt;</code>.</li> <li>The reason why we set <code>anchor</code> is because that the drawing is always go from top-left to bottom-right in pixijs.</li> </ul> <pre><code>// createLayout.svelte.ts\n\nimport { innerWidth, innerHeight } from 'svelte/reactivity/window';\n\n...\n\nconst stateLayout = $state({\n  showLoadingScreen: true,\n});\n\nconst stateLayoutDerived = {\n  canvasSizes,\n  canvasRatio,\n  canvasRatioType,\n  canvasSizeType,\n  layoutType,\n  isStacked,\n  mainLayout,\n  normalBackgroundLayout,\n  portraitBackgroundLayout,\n};\n</code></pre> <p></p>"},{"location":"fe_docs/context/#contextxstate","title":"ContextXstate","text":"<p><code>stateXstate</code> and <code>stateXstateDerived</code> are created by <code>packages/utils-xstate/src/createXstateUtils.svelte.ts</code>. It provides a few functions to check the state of finite state machine, also known as <code>gameActor</code>, which is created by <code>packages/utils-xstate/src/createGameActor.svelte.ts</code>.</p> <pre><code>// createXstateUtils.svelte.ts\n\nimport { matchesState, type StateValue } from 'xstate';\n\n...\n\nconst stateXstate = $state({\n  value: '' as StateValue,\n});\n\nconst matchesXstate = (state: string) =&gt; matchesState(state, stateXstate.value);\n\nconst stateXstateDerived = {\n  matchesXstate,\n  isRendering: () =&gt; matchesXstate(STATE_RENDERING),\n  isIdle: () =&gt; matchesXstate(STATE_IDLE),\n  isBetting: () =&gt; matchesXstate(STATE_BET),\n  isAutoBetting: () =&gt; matchesXstate(STATE_AUTOBET),\n  isResumingBet: () =&gt; matchesXstate(STATE_RESUME_BET),\n  isForcingResult: () =&gt; matchesXstate(STATE_FORCE_RESULT),\n  isPlaying: () =&gt; !matchesXstate(STATE_RENDERING) &amp;&amp; !matchesXstate(STATE_IDLE),\n};\n</code></pre> <p><code>gameActor</code>: To avoid using massive \"if-else\" conditions in the code, we use npm/xstate to create a finite state machine to handle the complicated logic and states of betting. It provides a few pre-defined mechanics like one-off <code>bet</code>, <code>autoBet</code> with a count down, <code>resumeBet</code> to continue an unfinished bet and so on.</p> <pre><code>// createGameActor.svelte.ts\n\nimport { setup, createActor } from 'xstate';\n\n...\n\nconst gameMachine = setup({\n  actors: {\n    bet: intermediateMachines.bet,\n    autoBet: intermediateMachines.autoBet,\n    resumeBet: intermediateMachines.resumeBet,\n    forceResult: intermediateMachines.forceResult,\n  },\n}).createMachine({\n  initial: 'rendering',\n  states: {\n    [STATE_RENDERING]: stateRendering,\n    [STATE_IDLE]: stateIdle,\n    [STATE_BET]: stateBet,\n    [STATE_AUTOBET]: stateAutoBet,\n    [STATE_RESUME_BET]: stateResumeBet,\n    [STATE_FORCE_RESULT]: stateForceResult,\n  },\n});\n\nconst gameActor = createActor(gameMachine);\n</code></pre> <p>This is highly useful when it comes to the interactions with UI, for example disable the bet button when the a game is playing.</p> <pre><code>// BetButton.svelte - Example of interaction between xstate and UI\n\n&lt;script lang=\"ts\"&gt;\n  import { getContext } from '../context';\n\n  const context = getContext();\n&lt;/script&gt;\n\n&lt;SimpleUiButton disabled={context.stateXstateDerived.isPlaying()} /&gt;\n</code></pre> <p></p>"},{"location":"fe_docs/context/#appcontext","title":"AppContext","text":"<p><code>stateApp</code> is created by <code>packages/pixi-svelte/src/lib/createApp.svelte.ts</code>. <code>loadedAssets</code> contains the static images, animations and sound data that is processed by <code>PIXI.Assets.load</code> with <code>stateApp.assets</code>. <code>loadedAssets</code> can be digested by pixi-svelte components directly as showed in pixi-svelte component <code>\\&lt;Sprite /\\&gt;</code>(<code>/packages/pixi-svelte/src/lib/components/Sprite.svelte</code>).</p> <pre><code>// createApp.svelte.ts\n\nconst stateApp = $state({\n  reset,\n  assets,\n  loaded: false,\n  loadingProgress: 0,\n  loadedAssets: {} as LoadedAssets,\n  pixiApplication: undefined as PIXI.Application | undefined,\n});\n</code></pre>"},{"location":"fe_docs/dependencies/","title":"Dependencies","text":"<p>Besides basic web skills (html, css and javascript), here it shows a list of npm dependencies of this repo. It would be great to start with understanding them before kicking off Get Started.</p> <ul> <li>pixijs: https://www.npmjs.com/package/pixi.js and more...</li> <li>svelte: https://www.npmjs.com/package/svelte and more...</li> <li>turborepo: https://www.npmjs.com/package/turbo and more...</li> <li>pixi-svelte: https://www.npmjs.com/package/pixi-svelte and more...</li> <li>This is an in-house npm package. It combines pixi and svelte together and uses pixijs in a declarative way.</li> <li>sveltekit: https://www.npmjs.com/package/@sveltejs/kit and more...</li> <li>storybook: https://www.npmjs.com/package/storybook and more...</li> <li>xstate: https://www.npmjs.com/package/xstate and more...</li> <li>typescript: https://www.npmjs.com/package/typescript and more...</li> <li>pnpm: https://www.npmjs.com/package/pnpm and more...</li> </ul>"},{"location":"fe_docs/explore_sb/","title":"Explore Storybook","text":"<p>Storybook is a powerful and handy tool to test our games. For example:</p> <ul> <li><code>COMPONENTS/&lt;Game&gt;/component</code>: It tests the <code>&lt;Game \\/&gt;</code>(<code>/apps/lines/src/components/Game.svelte</code>) component. In this case, it doesn't skip the loading screen.</li> <li><code>COMPONENTS/&lt;Game&gt;/preSpin</code>: It tests the <code>&lt;Game \\/&gt;</code>(<code>/apps/lines/src/components/Game.svelte</code>) component with the preSpin function.</li> <li><code>COMPONENTS/&lt;Game&gt;/emitterEvent</code>: It tests the <code>&lt;Game \\/&gt;</code>(<code>/apps/lines/src/components/Game.svelte</code>) component with an emitterEvent \"boardHide\".</li> <li>...</li> <li><code>COMPONENTS/&lt;Symbol&gt;/component</code>: It tests the <code>&lt;Symbol \\/&gt;</code>(<code>/apps/lines/src/components/Symbol.svelte</code>) component with controls e.g. state of the symbol.</li> <li><code>COMPONENTS/&lt;Symbol&gt;/symbols</code>: It tests the <code>&lt;Symbol \\/&gt;</code>(<code>/apps/lines/src/components/Symbol.svelte</code>) component with all the symbols and all the states.</li> <li>...</li> <li><code>MODE_BASE/book/random</code>: It tests the <code>&lt;Game \\/&gt;</code>(<code>/apps/lines/src/components/Game.svelte</code>) component with a random book of base mode.</li> <li><code>MODE_BASE/bookEvent/reveal</code>: It tests the <code>&lt;Game \\/&gt;</code>(<code>/apps/lines/src/components/Game.svelte</code>) component with a \"reveal\" bookEvent of the base mode. It will spin the reels.</li> <li>...</li> <li><code>MODE_BONUS/book/random</code>: It tests the <code>&lt;Game \\/&gt;</code>(<code>/apps/lines/src/components/Game.svelte</code>) component with a random book of bonus mode.</li> <li><code>MODE_BONUS/bookEvent/reveal</code>: It tests the <code>&lt;Game \\/&gt;</code>(<code>/apps/lines/src/components/Game.svelte</code>) component with a \"reveal\" bookEvent of the bonus mode. It will spin the reels.</li> <li>...</li> </ul> <p> </p>"},{"location":"fe_docs/explore_sb/#_1","title":"Storybook","text":"<p>With all the stories above and the stories that created and customised by yourself, we are able to test the whole game, intermediate components and atomic components.</p> <p>We are also able to test our game with a book, a sequence of bookEvents and a single bookEvent. If each bookEvent is implemented well with emitterEvents and its story is resolved properly, the game is technically finished.</p>"},{"location":"fe_docs/file_struct/","title":"File Structure","text":"<p>The file structure is in a way of structure of TurboRepo to achieve a monorepo. Besides the files for the configurations of TurboRepo, sveltekit, eslint, typescript, git and so on, here is a list of of key modules of (<code>/apps</code>) and <code>/packages</code>.</p> <pre><code>root\n  |_apps\n  |  |_cluster\n  |  |_lines\n  |  |_price\n  |  |_scatter\n  |  |_ways\n  |\n  |_packages\n     |_config-*\n     |_constants-*\n     |_state-*\n     |_utils-*\n     |_components-*\n     |_pixi-*\n</code></pre>"},{"location":"fe_docs/file_struct/#apps","title":"/apps","text":"<p>For each game, it has an individual folder in the apps, for example <code>/apps/lines</code>.</p> <ul> <li><code>/apps/lines/package.json</code>: Find the module name of the app here.</li> </ul> <pre><code>{\n  \"name\": \"lines\",\n  ...\n}\n</code></pre> <ul> <li>To run the app in DEV mode instead of in the storybook: Run <code>pnpm run dev --filter=&lt;MODULE_NAME&gt;</code> in the terminal.</li> </ul> <pre><code>pnpm run dev --filter=lines\n</code></pre> <ul> <li><code>/apps/lines/src/routes/%2Bpage.svelte</code>: This is the entry file of sample game apps/lines in a sveltekit way. It is a combination of two things:</li> <li><code>setContext()</code>(<code>/apps/lines/src/game/context.ts#L14</code>): A function that sets all the svelte-context required and used in this app and in the <code>/packages</code>. As we already know, only children-level components can access the context. That is why we set the context at the entry level of the app.</li> <li><code>&lt;Game \\/&gt;</code>(<code>/apps/lines/src/components/Game.svelte</code>): The entry svelte component to the game. It includes all the components of the game.</li> </ul> <pre><code>// +page.svelte\n\n&lt;script lang=\"ts\"&gt;\n  import Game from '../components/Game.svelte';\n  import { setContext } from '../game/context';\n\n  setContext();\n&lt;/script&gt;\n\n&lt;Game /&gt;\n</code></pre> <ul> <li><code>/apps/lines/src/stories/ComponentsGame.stories.svelte</code>: You will find the same pattern in this storybook or other <code>Mode&lt;GAME_MODE&gt;Book.stories.svelte</code> and <code>Mode&lt;GAME_MODE&gt;BookEvent.stories.svelte</code>.</li> </ul> <pre><code>// ComponentsGame.stories.svelte\n\n&lt;script lang=\"ts\"&gt;\n  ...\n  import Game from '../components/Game.svelte';\n  import { setContext } from '../game/context';\n\n  ...\n  setContext();\n&lt;/script&gt;\n\n&lt;Story name=\"component (loadingScreen)\"&gt;\n  &lt;StoryLocale lang=\"en\"&gt;\n    &lt;Game /&gt;\n  &lt;/StoryLocale&gt;\n&lt;/Story&gt;\n</code></pre> <ul> <li>We can render <code>&lt;Game \\/&gt;</code>(<code>/apps/lines/src/components/Game.svelte</code>) component in the app or in the storybook. Either way it requires the context to set in advance, otherwise the children or the descendants will throw errors if they use the <code>getContext()</code>(<code>/apps/lines/src/game/context.ts#L21</code>) from <code>/apps</code> or <code>getContext()</code> (<code>/packages/components-ui-pixi/src/context.ts#L8</code>) from <code>/packages</code>.</li> </ul> <p></p>"},{"location":"fe_docs/file_struct/#packages","title":"/packages","text":"<p>For every TurboRepo local package, you can import and use them in an app or in another local package directly without publishing them to npm. Our codebase benefits considerably from a monorepo because it brings reusability, readability, maintainability, code splitting and so on. Here is an example of importing local packages with <code>workspace:*</code> in <code>/apps/lines/package.json</code>:</p> <pre><code>// package.json\n\n{\n  \"name\": \"lines\",\n  ...,\n  \"devDependencies\": {\n    ...,\n    \"config-ts\": \"workspace:*\",\n  },\n  \"dependencies\": {\n    ...,\n    \"pixi-svelte\": \"workspace:*\",\n    \"constants-shared\": \"workspace:*\",\n    \"state-shared\": \"workspace:*\",\n    \"utils-shared\": \"workspace:*\",\n    \"components-shared\": \"workspace:*\",\n  }\n}\n</code></pre> <p>The naming convention of packages is a combination of <code>&lt;PACKAGE_TYPE&gt;</code>, hyphen and <code>&lt;SPECIAL_DEPENDENCY&gt;</code> or <code>&lt;SPECIAL_USAGE&gt;</code>. For example, <code>components-pixi</code> is a local package that the package type is \"components\" and the special dependency is <code>pixi-svelte</code>.</p> <ul> <li><code>config-*</code>:</li> <li><code>/packages/config-lingui</code>: This local package contains reusable configurations of npm package lingui.</li> <li><code>/packages/config-storybook</code>: This local package contains reusable configurations of npm package storybook.</li> <li><code>packages/config-svelte</code>: This local package contains reusable configurations of npm package svelte.</li> <li><code>/packages/config-ts</code>: This local package contains reusable configurations of npm package typescript.</li> <li><code>/packages/config-vite</code>: This local package contains reusable configurations of npm package vite.</li> <li><code>pixi-*</code></li> <li><code>/packages/pixi-svelte</code>: This local package contains reusable svelte components/functions/types based on pixijs and svelte.<ul> <li>It creates <code>stateApp</code> and <code>AppContext</code> as a svelte-context.</li> <li>It also builds and publishes pixi-svelte of npm.</li> </ul> </li> <li><code>packages/pixi-svelte-storybook</code>: This is a storybook for components in <code>pixi-svelte</code>.</li> <li><code>constants-*</code>:</li> <li><code>/packages/constants-shared</code>: This local package contains reusable global constants.</li> <li><code>state-*</code>:</li> <li><code>/packages/state-shared</code>: This local package contains reusable global svelte-$state.</li> <li><code>utils-*</code>:</li> <li><code>/packages/utils-book</code>: This local package contains reusable functions/types that are related to book and bookEvent.</li> <li><code>/packages/utils-fetcher</code>: This local package contains reusable functions/types based on fetch API.</li> <li><code>/packages/utils-shared</code>: This local package contains reusable functions/types, except for lodash and lingui.</li> <li><code>/packages/utils-slots</code>: This local package contains reusable functions/types for slots game, for example creating reel and spinning the board.</li> <li><code>/packages/utils-sound</code>: This local package contains reusable functions/types based on npm package howler for music and sound effect.</li> <li><code>/packages/utils-event-emitter</code>: This local package contains reusable functions/types to achieve our event-driven programming.<ul> <li>It creates <code>eventEmitter</code> and <code>ContextEventEmitter</code> as a svelte-context</li> </ul> </li> <li><code>/packages/utils-xstate</code>: This local package contains reusable functions/types based on npm package xstate.<ul> <li>It creates <code>stateXstate</code>, <code>stateXstateDerived</code> and <code>ContextXstate</code> as a svelte-context</li> </ul> </li> <li><code>/packages/utils-layout</code>: This local package contains reusable functions/types for our layout system of pixijs.<ul> <li>It creates <code>stateLayout</code>, <code>stateLayoutDerived</code> and <code>ContextLayout</code> as a svelte-context</li> </ul> </li> <li><code>components-*</code>:</li> <li><code>/packages/components-layout</code>: This local package contains reusable svelte components based on another local package <code>utils-layout</code>.</li> <li><code>/packages/components-pixi</code>: This local package contains reusable svelte components based on <code>pixi-svelte</code>.</li> <li><code>/packages/components-shared</code>: This local package contains reusable svelte components based on <code>html</code>.</li> <li><code>/packages/components-storybook</code>: This local package contains reusable svelte components for storybooks.</li> <li><code>/packages/components-ui-pixi</code>: This local package contains reusable svelte pixi-svelte components for the game UI.</li> <li><code>packages/components-ui-html</code>: This local package contains reusable svelte html components for the game UI.</li> </ul> <p>For <code>*-shared</code> packages, they are created to be reused as much as possible by other apps and packages. Instead of having a special dependency or usage, they should have a minimum list of dependencies and a broad set of use cases.</p> <p><code>pixi-svelte</code>, <code>utils-event-emitter</code>, <code>utils-layout</code> and <code>utils-xstate</code> they have functions to create corresponding svelte-context. For the contexts, they can be used by either an app or a local <code>components-*</code> package by just calling the <code>getContext&lt;CONTEXT_NAME&gt;()</code>. For example, components in <code>components-layout</code> use <code>getContextLayout()</code> from <code>utils-layout</code>. In this way, we can regard <code>pixi-svelte</code> as an integration of \"utils-pixi-svelte\" and \"components-pixi-svelte\".</p>"},{"location":"fe_docs/flowchart/","title":"Flow Chart","text":"<p>Here it is a simplified flow chart of steps how a game is processed after RGS request. The real situation might be more complicated, but it follows the same idea.</p> <p></p> <p></p>"},{"location":"fe_docs/flowchart/#playbookevents","title":"playBookEvents()","text":"<p>This function is created by <code>packages/utils-book/src/createPlayBookUtils.ts</code>. It goes through bookEvents one by one, handles each one with async function <code>playBookEvent()</code>. It resolves them one after another with <code>sequence()</code> in the order of the bookEvents array. It means the sequence of bookEvents matters eminently and it determines the behaviors of the game. For example, we don't want to see the \"win\" before \"spin\", so we should put \"win\" after the \"spin\". This function is also used in the <code>MODE_&lt;GAME_MODE&gt;/book/random</code> stories.</p> <ul> <li> <p><code>playBookEvent()</code>: This is a function that takes in a bookEvent with some context (usually all the bookEvents), then find the bookEventHandler in bookEventHandlerMap based on <code>bookEvent.type</code> to process it. This function is also used in the <code>MODE_&lt;GAME_MODE&gt;/bookEvent/&lt;BOOK_EVENT_TYPE&gt;</code> stories.</p> </li> <li> <p><code>sequence()</code>: This is an async function to achieve resolving async functions/promises one after another. On the contrast, <code>Promise.all()</code> will trigger all the async functions/promises together at the same time, which is not what we desire for the sequence of the game.</p> </li> </ul> <p></p>"},{"location":"fe_docs/flowchart/#bookevent","title":"bookEvent","text":"<ul> <li><code>book</code>: A book is a json data that is returned from the RGS (Remote Game Server) for each game requested. It is mainly composed by bookEvents.</li> </ul> <pre><code>// base_books.ts - Example of a base game book\n\n{\n  id: 1,\n  payoutMultiplier: 0.0,\n  events: [\n    {\n      index: 0,\n      type: 'reveal',\n      board: [\n        [{ name: 'L2' }, { name: 'L1' }, { name: 'L4' }, { name: 'H2' }, { name: 'L1' }],\n        [{ name: 'H1' }, { name: 'L5' }, { name: 'L2' }, { name: 'H3' }, { name: 'L4' }],\n        [{ name: 'L3' }, { name: 'L5' }, { name: 'L3' }, { name: 'H4' }, { name: 'L4' }],\n        [{ name: 'H4' }, { name: 'H3' }, { name: 'L4' }, { name: 'L5' }, { name: 'L1' }],\n        [{ name: 'H3' }, { name: 'L3' }, { name: 'L3' }, { name: 'H1' }, { name: 'H1' }],\n      ],\n      paddingPositions: [216, 205, 195, 16, 65],\n      gameType: 'basegame',\n      anticipation: [0, 0, 0, 0, 0],\n    },\n    { index: 1, type: 'setTotalWin', amount: 0 },\n    { index: 2, type: 'finalWin', amount: 0 },\n  ],\n  criteria: '0',\n  baseGameWins: 0.0,\n  freeGameWins: 0.0,\n}\n</code></pre> <ul> <li><code>bookEvent</code>: A bookEvent is a json data that is one of the element of the <code>book.events</code> array.</li> </ul> <pre><code>// base_books.ts - Example of a \"reveal\" bookEvent\n\n{\n  index: 0,\n  type: 'reveal',\n  board: [\n    [{ name: 'L2' }, { name: 'L1' }, { name: 'L4' }, { name: 'H2' }, { name: 'L1' }],\n    [{ name: 'H1' }, { name: 'L5' }, { name: 'L2' }, { name: 'H3' }, { name: 'L4' }],\n    [{ name: 'L3' }, { name: 'L5' }, { name: 'L3' }, { name: 'H4' }, { name: 'L4' }],\n    [{ name: 'H4' }, { name: 'H3' }, { name: 'L4' }, { name: 'L5' }, { name: 'L1' }],\n    [{ name: 'H3' }, { name: 'L3' }, { name: 'L3' }, { name: 'H1' }, { name: 'H1' }],\n  ],\n  paddingPositions: [216, 205, 195, 16, 65],\n  gameType: 'basegame',\n  anticipation: [0, 0, 0, 0, 0],\n}\n\n// base_books.ts - Example of a setTotalWin bookEvent\n\n{ index: 1, type: 'setTotalWin', amount: 0 },\n</code></pre> <ul> <li><code>bookEventHandler</code>: An async function that takes in a bookEvent and do some operations with it. Usually it broadcasts some emitterEvents, so the components will receive and handle.</li> </ul>"},{"location":"fe_docs/flowchart/#bookeventhandlermap","title":"bookEventHandlerMap","text":"<p>An object that the key is <code>bookEvent.type</code> and value is a <code>bookEventHandler</code>. We can find an example in <code>/apps/lines/src/game/bookEventHandlerMap.ts</code>.</p> <pre><code>// bookEventHandlerMap.ts - Example of \"updateFreeSpin\" bookEventHandler\n\nexport const bookEventHandlerMap: BookEventHandlerMap&lt;BookEvent, BookEventContext&gt; = {\n  ...,\n  updateFreeSpin: async (bookEvent: BookEventOfType&lt;'updateFreeSpin'&gt;) =&gt; {\n    eventEmitter.broadcast({ type: 'freeSpinCounterShow' });\n    eventEmitter.broadcast({\n      type: 'freeSpinCounterUpdate',\n      current: bookEvent.amount,\n      total: bookEvent.total,\n    });\n  },\n  ...,\n}\n</code></pre> <ul> <li>In simple terms, a book is composed by multiple bookEvents. Different combinations of bookEvents will determine the different behaviours of a game e.g. win/lose, a big/small win, a base/bonus game, 1/10/15 spins and so on.</li> </ul> <p></p>"},{"location":"fe_docs/flowchart/#eventemitter","title":"eventEmitter","text":"<p>It achieves event-driven programming for the development. It can either broadcast or subscribe to emitterEvents. It connects the javascript scope and svelte component scope with emitterEvents instead of passing the different states as svelte component props directly. The three most used functions are:</p> <ul> <li><code>eventEmitter.broadcast()</code></li> <li><code>eventEmitter.broadcastAsync()</code></li> <li><code>eventEmitter.subscribeOnMount()</code></li> </ul> <p></p>"},{"location":"fe_docs/flowchart/#emitterevent","title":"emitterEvent","text":"<p>An emitterEvent is a json data that <code>eventEmitter.broadcast(emitterEvent)</code> or <code>eventEmitter.broadcastAsync(emitterEvent)</code> broadcasts, so that a component which has <code>eventEmitter.subscribeOnMount(emitterEventHandlerMap)</code> can receive the data and deal with it in a synchronous or asynchronous way.</p> <p>For a game we have many animations, so sometimes we need to \"await\" for those animations to finish before going to the next step.</p> <p>Conceptually a bookEvent is composed by emitterEvents. Nevertheless, the flexibility lies in that the emitterEvents composing a bookEvent can come from multiple different svelte components. This way we can achieve and control the interactions and timing between different svelte components for the same bookEvent, ultimately, to achieve our games.</p> <pre><code>// bookEventHandlerMap.ts - Example of an emitterEvent\n\n{\n  type: 'freeSpinCounterUpdate',\n  current: undefined,\n  total: bookEvent.totalFs,\n}\n</code></pre> <ul> <li><code>EmitterEventHandler (Synchronous)</code>: A sync function that takes in an emitterEvent. It usually deals with some sync operations e.g. show/hide component, tidy up, update some numbers and so on.</li> </ul> <pre><code>// bookEventHandlerMap.ts - Example of broadcast\n\neventEmitter.broadcast({\n  type: 'freeSpinCounterUpdate',\n  current: undefined,\n  total: bookEvent.totalFs,\n});\n\n// FreeSpinCounter.svelte - Example of receiving\n\ncontext.eventEmitter.subscribeOnMount({\n  ...,\n  freeSpinCounterUpdate: (emitterEvent) =&gt; {\n    if (emitterEvent.current !== undefined) current = emitterEvent.current;\n    if (emitterEvent.total !== undefined) total = emitterEvent.total;\n  },\n  ...,\n});\n</code></pre> <ul> <li><code>EmitterEventHandler (Asynchronous)</code>: An async function that takes in an emitterEvent. It usually deals with some async operations e.g. wait for fading in/out component, wait for animations to finish, wait for numbers to increase/decrease with svelte-tween and so on.</li> </ul> <pre><code>// bookEventHandlerMap.ts - Example of broadcastAsync\n\nawait eventEmitter.broadcastAsync({\n  type: 'freeSpinIntroUpdate',\n  totalFreeSpins: bookEvent.totalFs,\n});\n\n// FreeSpinIntro.svelte - Example of receiving\n\ncontext.eventEmitter.subscribeOnMount({\n  ...,\n  freeSpinIntroUpdate: async (emitterEvent) =&gt; {\n    freeSpinsFromEvent = emitterEvent.totalFreeSpins;\n    await waitForResolve((resolve) =&gt; (oncomplete = resolve));\n  },\n  ...,\n});\n</code></pre> <p></p>"},{"location":"fe_docs/flowchart/#emittereventhandlermap","title":"emitterEventHandlerMap","text":"<p>An object that the key is <code>emitterEvent.type</code> and value is an <code>emitterEventHandler</code>. We can find this object in each component. For example, (<code>/apps/lines/src/components/FreeSpinCounter.svelte</code>).</p> <ul> <li>Each emitterEventHandler can do a lot or a little, but we prefer each emitterEventHandler just doing a minimum job to achieve the duty that is described by its type. This way we follow the Single Responsibility Principle of SOLID. For example, <code>freeSpinCounterShow</code> just shows this component and does nothing more.</li> </ul> <pre><code>// FreeSpinCounter.svelte and its emitterEventHandlers\n\n&lt;script lang=\"ts\" module&gt;\n  export type EmitterEventFreeSpinCounter =\n    | { type: 'freeSpinCounterShow' }\n    | { type: 'freeSpinCounterHide' }\n    | { type: 'freeSpinCounterUpdate'; current?: number; total?: number };\n&lt;/script&gt;\n\n&lt;script lang=\"ts\"&gt;\n  ...\n\n  context.eventEmitter.subscribeOnMount({\n    freeSpinCounterShow: () =&gt; (show = true),\n    freeSpinCounterHide: () =&gt; (show = false),\n    freeSpinCounterUpdate: (emitterEvent) =&gt; {\n      if (emitterEvent.current !== undefined) current = emitterEvent.current;\n      if (emitterEvent.total !== undefined) total = emitterEvent.total;\n    },\n  });\n&lt;/script&gt;\n\n&lt;MainContainer&gt;\n  ...\n&lt;/MainContainer&gt;\n</code></pre>"},{"location":"fe_docs/get_started/","title":"Get started","text":"<p>Here is a complete tutorial to start our sample games in the storybook. Please ignore those steps that you already know or done.</p> <ul> <li>It is preferred to use VS Code as IDE. download</li> <li>Install node with version 18.18.0. download</li> </ul> <pre><code># Download and install nvm:\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash\n\n# in lieu of restarting the shell\n\\. \"$HOME/.nvm/nvm.sh\"\n\n# Download and install Node.js:\nnvm install 18.18.0\n\n# Verify the node versions. Should print \"v18.18.0\".\nnode -v\n</code></pre> <ul> <li>Install pnpm with version 10.5.0.</li> </ul> <pre><code># Install pnpm\nnpm install pnpm@10.5.0 -g\n\n# Verify the pnpm versions. Should print \"v10.5.0\"\npnpm -v\n</code></pre> <ul> <li>Clone the repo to your local in VS Code terminal or others.</li> </ul> <pre><code>git clone &lt;REPO_CLONE_URL&gt;\ncd web-sdk\n</code></pre> <ul> <li>Install dependencies.</li> </ul> <pre><code>pnpm install\n</code></pre> <ul> <li>Run <code>pnpm run storybook --filter=&lt;MODULE_NAME&gt;</code> in the terminal to see the storybook of a sample game in a TurboRepo way. <code>&lt;MODULE_NAME&gt;</code> is the name in the package.json file of a module in apps or packages folders.</li> <li>For example, we have <code>\"name\": \"lines\"</code> in the <code>/apps/lines/package.json</code>, so we can find it and run its storybook by:</li> </ul> <pre><code>pnpm run storybook --filter=lines\n</code></pre> <ul> <li>You should see this: </li> </ul>"},{"location":"fe_docs/get_started/#_1","title":"Getting Started","text":"<ul> <li>Now switch to <code>MODE_BASE/book/random</code> in the left sidebar, you will see an <code>Action</code> button appear on the left right conner of the game.</li> </ul>"},{"location":"fe_docs/get_started/#_2","title":"Getting Started","text":"<ul> <li>Click on the <code>Action</code> button and wait for a base game to finish.</li> <li>Congratulations! You are now in the zone of game development with us now.</li> </ul>"},{"location":"fe_docs/localisation/","title":"Localisation","text":""},{"location":"fe_docs/localisation/#internationalisation-i18n","title":"Internationalisation (i18n)","text":""},{"location":"fe_docs/steps/","title":"Steps to Add a New BookEvent","text":"<p>For example, we have a game <code>/apps/lines</code> already. Assume that we have added a new bookEvent <code>updateGlobalMult</code> to the bonus game mode (<code>MODE_BONUS</code>) in math, so that we have a new global multiplier feature for the game. Based on that, here we will go through the steps together to implement this new bookEvent and add it to the game. Along the way we will introduce part of our file structure as well.</p> <ul> <li><code>/apps/lines/src/stories/data/bonus_books.ts</code>: This file includes the an array of bonus books that story <code>MODE_BONUS/book/random</code> will randomly pick at. This is to simulate requesting data from RGS. All we need to do is to copy/paste data from our new math package and format it.a</li> </ul> <pre><code>// bonus_books.ts\n\n{\n  type: 'updateGlobalMult',\n  globalMult: 3,\n},\n</code></pre> <ul> <li><code>/apps/lines/src/stories/data/bonus_events.ts</code>: This file includes the an object of every type of bookEvent that story <code>MODE_BONUS/bookEvent/&lt;BOOK_EVENT_TYPE&gt;</code> uses. All we need to do is to copy/paste data from our new math package and format it.</li> </ul> <pre><code>// bonus_events.ts\n\nexport default {\n  ...,\n  updateGlobalMult: {\n    type: 'updateGlobalMult',\n    globalMult: 3,\n  },\n  ...,\n}\n</code></pre> <ul> <li><code>/apps/lines/src/stories/ModeBonusBookEvent.stories.svelte</code>: This file implements all the sub stories in story set <code>MODE_BONUS/bookEvent</code>. With the following code added in this file, you will see the a new story <code>MODE_BONUS/bookEvent/updateGlobalMult</code> that is added in our storybook with an <code>Action</code> button. Now if we click on it and nothing would happen, but it is a good start because we set up the testing environment first. Next step is to add code of bookEventHandler to handle it.</li> </ul> <pre><code>// ModeBonusBookEvent.stories.svelte\n\n&lt;Story\n  name=\"updateGlobalMult\"\n  args={templateArgs({\n    skipLoadingScreen: true,\n    data: events.updateGlobalMult,\n    action: async (data) =&gt; await playBookEvent(data, { bookEvents: [] }),\n  })}\n/&gt;\n</code></pre> <ul> <li><code>/apps/lines/src/game/typesBookEvent.ts</code>: This file contains typescript types of all the bookEvents. Let is add the type of our new bookEvent to get the intellisense from typescript for the following step.</li> <li><code>type BookEvent</code> is a union type (typescript union type) of BookEvent types.</li> </ul> <pre><code>// typesBookEvent.ts\n\ntype BookEventUpdateGlobalMult = {\n  index: number;\n  type: 'updateGlobalMult';\n  globalMult: number;\n};\n\nexport type BookEvent =\n  | ...\n  | BookEventUpdateGlobalMult\n  | ...\n;\n</code></pre> <ul> <li><code>/apps/lines/src/game/bookEventHandlerMap.ts</code>: This file includes all the bookEventHandlers. Let is add a new one for the new bookEvent. Check the intellisense that the previous step brings, it provides a better developer experience.</li> </ul> <p></p>"},{"location":"fe_docs/steps/#_1","title":"Adding New Events","text":"<ul> <li><code>/apps/lines/src/components/GlobalMultiplier.svelte</code>: This file is created as our target svelte component for updateGlobalMulti bookEvent. Technically speaking, all the jobs that is related to global multiplier of the game should only be in this svelte component. Similar to the bookEvent types, let is add the typescript types for new emitterEvents first.</li> <li><code>type EmitterEventGlobalMultiplier</code> is a union type of EmitterEvent types.</li> </ul> <pre><code>// GlobalMultiplier.svelte\n\n&lt;script lang=\"ts\" module&gt;\n  export type EmitterEventGlobalMultiplier =\n    | { type: 'globalMultiplierShow' }\n    | { type: 'globalMultiplierHide' }\n    | { type: 'globalMultiplierUpdate'; multiplier: number };\n&lt;/script&gt;\n</code></pre> <ul> <li><code>/apps/lines/src/game/typesEmitterEvent.ts</code>: This file has typescript types of all the emitterEvents of the game. Let is add the type of our new emitterEvents for intellisense.</li> <li><code>type EmitterEventGame</code> is a union type of EmitterEvent types.</li> </ul> <pre><code>// typesEmitterEvent.ts\n\n...\nimport type { EmitterEventGlobalMultiplier } from '../components/GlobalMultiplier.svelte';\n...\n\nexport type EmitterEventGame =\n  | ...\n  | EmitterEventGlobalMultiplier\n  | ...\n;\n</code></pre> <ul> <li><code>/apps/lines/src/game/eventEmitter.ts</code>: This file exports the eventEmitter, it uses the <code>EmitterEventGame</code> and other EmitterEvent types to compose <code>type EmitterEvent</code>.</li> <li><code>type EmitterEvent</code> is a union type of EmitterEvent types.</li> </ul> <pre><code>// eventEmitter.ts\n\n...\nimport type { EmitterEventGame } from './typesEmitterEvent';\nexport type EmitterEvent = EmitterEventUi | EmitterEventHotKey | EmitterEventGame;\nexport const { eventEmitter } = createEventEmitter&lt;EmitterEvent&gt;();\n\n</code></pre> <ul> <li><code>/apps/lines/src/components/GlobalMultiplier.svelte</code>: Back to our component file, the intellisense is there. Let is add the code to process the values with a spine animation as well.</li> </ul>"},{"location":"fe_docs/steps/#_2","title":"Adding New Events","text":"<pre><code>// GlobalMultiplier.svelte\n\n&lt;script lang=\"ts\" module&gt;\n  export type EmitterEventGlobalMultiplier =\n    | { type: 'globalMultiplierShow' }\n    | { type: 'globalMultiplierHide' }\n    | { type: 'globalMultiplierUpdate'; multiplier: number };\n&lt;/script&gt;\n\n&lt;script lang=\"ts\"&gt;\n  ...\n\n  context.eventEmitter.subscribeOnMount({\n    globalMultiplierShow: () =&gt; (show = true),\n    globalMultiplierHide: () =&gt; (show = false),\n    globalMultiplierUpdate: async (emitterEvent) =&gt; {\n      console.log(emitterEvent.multiplier)\n    },\n  });\n&lt;/script&gt;\n\n&lt;SpineProvider key=\"globalMultiplier\" width={PANEL_WIDTH}&gt;\n  ...\n  &lt;SpineTrack trackIndex={0} {animationName} /&gt;\n&lt;/SpineProvider&gt;\n</code></pre> <ul> <li> <p>Test it individually <code>(MODE_BONUS/bookEvent/updateGlobalMult)</code>: Run storybook and we should see this a new story \"updateGlobalMult\" has been added.</p> </li> <li> <p>Now click on the <code>Action</code> button and we should see the <code>&lt;GlobalMultiplier \\/&gt;</code> (<code>/apps/lines/src/components/GlobalMultiplier.svelte</code>) component animates correctly followed by the \" \u24d8 Action is resolved \u2705 \" message, otherwise we need to go back to the component and figure out what is wrong until it is resolved.</p> </li> <li> <p>If you find out the component hard to debug, we'd better start creating a new story <code>COMPONENTS/&lt;GlobalMultiplierSpine&gt;/component</code>. <code>&lt;GlobalMultiplierSpine /&gt;</code> component will purely take props and achieve its duty instead of being controlled by emitterEvents. This way it becomes more friendly for testing the component with the storybook controls.</p> </li> <li> <p>Test it in books <code>(MODE_BONUS/book/random)</code>: Final step is to test it in a book environment by switching to this book story. In a previous step we have updated <code>/apps/lines/src/stories/data/bonus_books.ts</code>, so the new bookEvent will appear if we keep hitting the <code>Action</code> button in this story.</p> </li> </ul>"},{"location":"fe_docs/task_bd/","title":"Task Breakdown","text":"<p>There is one single idea that is been applied across the whole carrot-game-sdk that is Task Breakdown.</p> <p>To extend a bit more of the topic above, if an emitterEventHandler does too much work, then it is better we consider to split it into smaller emitterEventHandlers as a process of task-breakdown.</p> <p>For example, \"tumbleBoard\" bookEvent is a fairly complicated bookEvent. Instead of having one \"tumbleBoard\" emitterEvent, we split it into \"tumbleBoardInit\", \"tumbleBoardExplode\", \"tumbleBoardRemoveExploded\", \"tumbleBoardSlideDown\".</p> <p>This way we can implement a big and complicated emitterEvent step by step. More importantly, we can test the implementations one by one in storybook of <code>COMPONENTS/&lt;Game&gt;/emitterEvent</code>.</p> <pre><code>// bookEventHandlerMap.ts - Example of task-breakdown\n\n{\n  ...,\n  tumbleBoard: async (bookEvent: BookEventOfType&lt;'tumbleBoard'&gt;) =&gt; {\n    eventEmitter.broadcast({ type: 'tumbleBoardShow' });\n    eventEmitter.broadcast({ type: 'tumbleBoardInit', addingBoard: bookEvent.newSymbols });\n    await eventEmitter.broadcastAsync({\n      type: 'tumbleBoardExplode',\n      explodingPositions: bookEvent.explodingSymbols,\n    });\n    eventEmitter.broadcast({ type: 'tumbleBoardRemoveExploded' });\n    await eventEmitter.broadcastAsync({ type: 'tumbleBoardSlideDown' });\n    eventEmitter.broadcast({\n      type: 'boardSettle',\n      board: stateGameDerived\n        .tumbleBoardCombined()\n        .map((tumbleReel) =&gt; tumbleReel.map((tumbleSymbol) =&gt; tumbleSymbol.rawSymbol)),\n    });\n    eventEmitter.broadcast({ type: 'tumbleBoardReset' });\n    eventEmitter.broadcast({ type: 'tumbleBoardHide' });\n  },\n  ...,\n}\n</code></pre> <pre><code>// TumbleBoard.svelte - Example of task-breakdown\n\ncontext.eventEmitter.subscribeOnMount({\n  tumbleBoardShow: () =&gt; {},\n  tumbleBoardHide: () =&gt; {},\n  tumbleBoardInit: () =&gt; {},\n  tumbleBoardReset: () =&gt; {},\n  tumbleBoardExplode: () =&gt; {},\n  tumbleBoardRemoveExploded: () =&gt; {},\n  tumbleBoardSlideDown: () =&gt; {},\n});\n</code></pre> <p>Stateless games can be complicated as well (vs. stateful games). For example, a slots game can have different types of spins, number of spins, win rules, number of bookEvents, game modes, global multiplier, multiplier symbols and so on.</p> <ul> <li>Stateless games: A single request to the RGS will finish the job of playing a game. For example, it requires only one request to play and finish a slots game.</li> <li>Stateful games: It requires multiple requests to the RGS to be able to finish the job. For example, a mines game.</li> </ul> <p></p> <p>However with the data structure of math and the functions we have, we are able to break down a complicated game into small and atomic tasks (emitterEvents). It enables us to test the atomics independently as well. Visually it is something like this:</p> <p></p> <p>The colors of the emitterEvents under a bookEvent can be different, which means they are from different svelte components.</p>"},{"location":"fe_docs/ui/","title":"UI","text":"<p>We have provided solutions for the UI, which are <code>/packages/components-ui-pixi</code> and <code>/packages/components-ui-html</code>. They are functional with a few features like auto gaming, turbo mode, bonus button, responsiveness and so on, but they are not as beautiful.</p> <pre><code>&lt;script lang=\"ts\"&gt;\n    import { UI, UiGameName } from 'components-ui-pixi';\n    import { GameVersion, Modals } from 'components-ui-html';\n&lt;/script&gt;\n\n&lt;App&gt;\n  &lt;UI&gt;\n    {#snippet gameName()}\n      &lt;UiGameName name=\"LINES GAME\" /&gt;\n    {/snippet}\n    {#snippet logo()}\n      &lt;Text\n        anchor={{ x: 1, y: 0 }}\n        text=\"ADD YOUR LOGO\"\n        style={{\n          fontFamily: 'proxima-nova',\n          fontSize: REM * 1.5,\n          fontWeight: '600',\n          lineHeight: REM * 2,\n          fill: 0xffffff,\n        }}\n      /&gt;\n    {/snippet}\n  &lt;/UI&gt;\n&lt;/App&gt;\n\n&lt;Modals&gt;\n    {#snippet version()}\n        &lt;GameVersion version=\"0.0.0\" /&gt;\n    {/snippet}\n&lt;/Modals&gt;\n\n</code></pre> <p>For the branding purpose, we recommend you to regard them as just an example of UI packages instead of applying them directly to your final product. It would be a good choice to use them as a starting point and add more style to them to build your UI. It is completely fine to ignore them and build your own UI from scratch.</p>"},{"location":"math_docs/directory/","title":"Repository Directory Overview","text":"<p>This repository is organized into several directories, each focusing on a specific aspect of the game creation process. Below is a breakdown of the main directories and their purposes:</p>"},{"location":"math_docs/directory/#main-directories","title":"Main Directories","text":"<ul> <li><code>games/</code></li> <li> <p>Contains sample slot games showcasing widely used mechanics and modes:</p> <ul> <li><code>0_0_cluster</code>: Cascading cluster-wins game.</li> <li><code>0_0_lines</code>: Basic win-lines example game.</li> <li><code>0_0_ways</code>: Basic ways-wins example game.</li> <li><code>0_0_scatter</code>: Pay-anywhere cascading example game.</li> <li><code>0_0_expwilds</code>: Expanding Wild-reel game with an additional prize-collection feature.</li> </ul> </li> <li> <p><code>src/</code></p> </li> <li>Core game setup functions, game mechanics, frontend event structures, wallet management, and simulation output control. This directory contains reusable code shared across games. Edit with caution.</li> <li> <p>Subdirectories:</p> <ul> <li><code>calculations/</code>: Board and symbol setup, various win-type game logic.</li> <li><code>config/</code>: Generates configuration files required by the RGS, frontend, and optimization algorithm.</li> <li><code>events/</code>: Data structures passed between the math engine and frontend engine.</li> <li><code>executables/</code>: Commonly used groupings of game logic and events.</li> <li><code>state/</code>: Tracks the game state during simulations.</li> <li><code>wins/</code>: Wallet manager handling various win criteria.</li> <li><code>write_data/</code>: Handles writing simulation data, compression, and force files.</li> </ul> </li> <li> <p><code>utils/</code></p> </li> <li> <p>Contains helpful functions for simulation and win-distribution analysis:</p> <ul> <li><code>analysis/</code>: Constructs and analyzes basic properties of win distributions.</li> <li><code>game_analytics/</code>: Uses recorded events, paytables, and lookup tables to generate hit-rate and simulation properties.</li> </ul> </li> <li> <p><code>tests/</code></p> </li> <li> <p>Includes basic PyTest functions for verifying win calculations:</p> <ul> <li><code>win_calculations/</code>: Tests various win-mechanic functionality.</li> </ul> </li> <li> <p><code>uploads/</code></p> </li> <li> <p>Handles the data upload process for connecting and uploading game files to an AWS S3 bucket for testing.</p> </li> <li> <p><code>optimization_program/</code></p> </li> <li> <p>Contains an experimental genetic algorithm (written in Rust) for balancing discrete-outcome games.</p> </li> <li> <p><code>docs/</code></p> </li> <li>Documentation files written in Markdown.</li> </ul>"},{"location":"math_docs/directory/#detailed-subdirectory-breakdown","title":"Detailed Subdirectory Breakdown","text":""},{"location":"math_docs/directory/#src","title":"<code>src/</code>","text":"<ul> <li><code>calculations/</code>: Handles board and symbol setup, along with various win-type game logic.</li> <li><code>config/</code>: Creates configuration files required by the RGS, frontend, and optimization algorithm.</li> <li><code>events/</code>: Defines data structures passed between the math engine and frontend engine.</li> <li><code>executables/</code>: Groups commonly used game logic and events for reuse.</li> <li><code>state/</code>: Tracks the game state during simulations.</li> <li><code>wins/</code>: Manages wallet functionality and various win criteria.</li> <li><code>write_data/</code>: Writes simulation data, handles compression, and generates force files.</li> </ul>"},{"location":"math_docs/directory/#games","title":"<code>games/</code>","text":"<ul> <li><code>0_0_cluster/</code>: Sample cascading cluster-wins game.</li> <li><code>0_0_lines/</code>: Basic win-lines example game.</li> <li><code>0_0_ways/</code>: Basic ways-wins example game.</li> <li><code>0_0_scatter/</code>: Pay-anywhere cascading example game.</li> <li><code>0_0_expwilds/</code>: Expanding Wild-reel game with an additional prize-collection feature.</li> </ul>"},{"location":"math_docs/directory/#utils","title":"<code>utils/</code>","text":"<ul> <li><code>analysis/</code>: Constructs and analyzes basic properties of win distributions.</li> <li><code>game_analytics/</code>: Generates hit-rate and simulation properties using recorded events, paytables, and lookup tables.</li> </ul>"},{"location":"math_docs/directory/#tests","title":"<code>tests/</code>","text":"<ul> <li><code>win_calculations/</code>: Tests various win-mechanic functionality.</li> </ul>"},{"location":"math_docs/directory/#uploads","title":"<code>uploads/</code>","text":"<ul> <li>Handles the process of uploading game files to an AWS S3 bucket for testing.</li> </ul>"},{"location":"math_docs/directory/#optimization_program","title":"<code>optimization_program/</code>","text":"<ul> <li>Experimental genetic algorithm (written in Rust) for balancing discrete-outcome games.</li> </ul>"},{"location":"math_docs/general_overview/","title":"Setup and installation","text":"<p>Running the math-sdk requires Python3 and PIP to be installed!</p> <p>Rust/Cargo must also be installed for the optimization algorithm to run!</p> <p>Clone the Math SDK repository to get started</p> <pre><code>git@github.com:StakeEngine/math-sdk.git\n</code></pre>"},{"location":"math_docs/general_overview/#makefile-recommended","title":"Makefile (recommended)","text":"<p>Assuming Make and a recent version of Python3 is installed on your machine, the easiest method of setting up the SDK is using the terminal to invoke:</p> <pre><code>  make setup\n</code></pre> <p>This will setup and activate a Python virtual environment, installing all necessary packages as defined within requirements.txt, and install an editable math-sdk module.</p> <p>Once the relavent parameters are set for a particular game, execute the run.py file using:</p> <pre><code>  make run GAME=&lt;game_id&gt;\n</code></pre>"},{"location":"math_docs/general_overview/#installing-cargo-only-if-using-optimization-algorithm","title":"Installing Cargo (Only if using Optimization Algorithm)","text":"<p>If the optimization algorithm is being utilized, Rust and Cargo should be installed. </p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre>"},{"location":"math_docs/general_overview/#manual-installation","title":"Manual installation","text":"<p>*Note: This installation is for Mac operating systems, Windows OS uses the prefix python (instead of python3)</p>"},{"location":"math_docs/general_overview/#create-and-activate-a-virtual-environment","title":"Create and Activate a Virtual Environment","text":"<p>It's recommended to use a virtual environment to manage dependencies. Using the Virtual Environment manager (venv), install Python version &gt;=3.12 using:</p> <pre><code>python3 -m venv env\n</code></pre> <p>If you are using Mac, activate the env with:</p> <pre><code>source env/bin/activate   \n</code></pre> <p>If using a Windows computer use:</p> <pre><code>  env\\Scripts\\activate.bat\n</code></pre>"},{"location":"math_docs/general_overview/#install-dependencies","title":"Install Dependencies","text":"<p>Use <code>pip</code> to install dependencies from the <code>requirements.txt</code> file:</p> <pre><code>python3 -m pip install -r requirements.txt\n</code></pre>"},{"location":"math_docs/general_overview/#install-the-package-in-editable-mode","title":"Install the Package in Editable Mode","text":"<p>Using the <code>setup.py</code> file, the package should be installed it in editable mode (for development purposes) with the command:</p> <pre><code>python3 -m pip install -e .\n</code></pre> <p>This allows modifications to the package source code to take effect without reinstallation. </p>"},{"location":"math_docs/general_overview/#verify-installation","title":"Verify Installation","text":"<p>You can check that the package is installed by running:</p> <pre><code>python3 -m pip list\n</code></pre> <p>or testing the package import in Python:</p> <pre><code>python\n&gt;&gt;&gt; import your_package_name\n</code></pre>"},{"location":"math_docs/general_overview/#deactivating-the-virtual-environment","title":"Deactivating the Virtual Environment","text":"<p>When finished, deactivate the virtual environment with:</p> <pre><code>deactivate\n</code></pre>"},{"location":"math_docs/quickstart/","title":"Quickstart Guide","text":""},{"location":"math_docs/quickstart/#running-your-first-game","title":"Running your first game","text":"<p>There are several example games provided within <code>/games/</code>, showing how common slot mechanics may be implemented. As an example let's look at <code>games/0_0_lines/</code>, a 3-row, 5-reel game paying on 20 win-lines. Wins involving 3 or more like symbols will award an amount described by <code>GameConfig.(paytable/payines)</code>.</p>"},{"location":"math_docs/quickstart/#run-file","title":"Run-file","text":"<p>Simulation parameters including number of simulations, payout statistics, optimization conditions, which modes to run etc.. are all handled within <code>run.py</code>. </p> <p>Using the default settings, running:</p> <pre><code>make run GAME=0_0_lines\n</code></pre> <p>(or calling the script manually after activating your virtual-environment)</p> <pre><code>python3 games/0_0_lines/run.py \n</code></pre> <p>will output all the files required by the RGS. All required files to publish math results are found within the <code>library/publish_files/</code> folder. Even if this math-sdk is not being used to generate math results, the books, lookup-tables and index file are required for publication. </p>"},{"location":"math_docs/quickstart/#testing-game-outputs","title":"Testing Game Outputs","text":"<p>To see example output files in human-readable form, lets simulate 100 results without compression in order to inspect the JSON output, we can alter the following variables within <code>run.py</code>:</p> <pre><code>num_threads = 1\ncompression = False\n\nnum_sim_args = {\n    \"base\": 100,\n    \"bonus\": 100,\n}\n\nrun_conditions = {\n    \"run_sims\": True,\n    \"run_optimization\": False,\n    \"run_analysis\": False\n}\n</code></pre> <p>When setting <code>num_sim_args</code>, we are essentially running the function <code>run_spin()</code> within <code>gamestate.py</code> 100 times, with simulation criteria being assigned within the <code>GameConfig()</code> class. We can see which criteria (basegame, 0-wins, feature games, max-wins etc..) have been applied to which simulation within the <code>library/lookup_tables/lookUpTableIdToCriteria_&lt;mode&gt;.csv</code> file. Here, we will not run the optimization or analysis because 100 results does not give a large enough range of results to approach large-scale statistics. We only need 1 CPU thread, so we can change this from 10 to 1 since it should only a take a second or two to run. Inspecting the output file, <code>library/books/books_base.jsonl</code> shows each simulation, identified by <code>id</code> (1-100). Each simulation-id has an <code>events</code> tag, which communicates to the front-end framework which symbols are revealed, win positions and amounts, and any of game-specific logic. Each simulation has a <code>payoutMultiplier</code> value which is the final payout amount for that round. This value directly corresponds to the value in <code>library/lookup_tables/lookUpTable_base.csv</code>. When a round-response is returned from by the RGS from the <code>play/</code> API, it is the contents of the <code>events</code> tag which is returned in the response body. </p> <p>If we look at the results for, say, simulation 58:</p> <pre><code>{\n    \"id\": 58,\n    \"payoutMultiplier\": 10,\n    \"events\": [\n        {\n            \"index\": 0,\n            \"type\": \"reveal\",\n            \"board\":[...],\n            \"paddingPositions\": [...],\n            \"gameType\": \"basegame\",\n            \"anticipation\": [...]\n        },\n        {\n            \"index\": 1,\n            \"type\": \"winInfo\",\n            \"totalWin\": 10,\n            \"wins\": [\n                {\n                    \"symbol\": \"L5\",\n                    \"kind\": 3,\n                    \"win\": 10,\n                    \"positions\": [...],\n                    \"meta\": {}\n                }\n            ]\n        },\n        {\n            \"index\": 2,\n            \"type\": \"setWin\",\n            \"amount\": 10,\n            \"winLevel\": 2\n        },\n        {\n            \"index\": 3,\n            \"type\": \"setTotalWin\",\n            \"amount\": 10\n        },\n        {\n            \"index\": 4,\n            \"type\": \"finalWin\",\n            \"amount\": 10\n        }\n    ],\n    \"criteria\": \"basegame\",\n    \"baseGameWins\": 0.1,\n    \"freeGameWins\": 0.0\n}\n</code></pre> <p>This tells up what board-symbols to reveal, the winning positions on this board, the payout amount, and sets the win counters. If we now open the lookup-table file and search for simulation number 58 we see the result: <code>58,1,10</code>, matching what was given to us within the <code>books</code> file. Note that all simulations are initially given a selection weight of <code>1</code> (the second value in each CSV row). The optimization program is what sets these weights to ensure that the game-mode is balanced to a specified RTP.</p>"},{"location":"math_docs/quickstart/#larger-simulation-batches","title":"Larger simulation batches","text":"<p>When starting with a new game, it is suggested to start by running a small number of simulations saved in uncompressed JSON format for debugging. Once satisfied with the gamestate output, larger simulations should be run. For a production-ready game it is typically recommended to run 100k+ simulations per mode to ensure that there is a diverse range of payout multipliers to optimize over, and to significantly reduce the chances of any single player receiving the same round result more than once. We set the following parameters indicating that we want to use 20 threads for simulating the game-logic for 10,000 simulations per mode, output in compressed (.json.zst) format, we will then use 20 threads when running the optimization algorithm (this will produce modified lookup-tables such as <code>lookUpTable_base_0.csv</code>).</p> <pre><code>num_sim_args = {\n    \"base\": int(1e4),\n    \"bonus\": int(1e4),\n}\n\nrun_conditions = {\n    \"run_sims\": True,\n    \"run_optimization\": True,\n    \"run_analysis\": True,\n    \"upload_data\": False,\n}\n</code></pre> <p>In the terminal you should seethe game RTP printed out as each thread finishes</p> <pre><code>Thread 0 finished with 1.632 RTP. [baseGame: 0.043, freeGame: 1.588]\n</code></pre> <p>Flor the <code>bonus</code> mode, this is telling us that thread 0/10 finished with a total RTP of 163.2%, with 4.3% coming from the basegame (wins on the reveal of Scatter symbols), and 158.8% RTP coming from freegame wins. This is higher than our expected 97%, though we are forcing significantly more max-win simulations than will naturally be awarded, so this is okay. The optimization algorithm will adjust these weights to balance the game properly.</p> <p>By setting <code>run_analysis: True</code> we are indicating that we would like to generate a PAR sheet, summarizing key game statistics and hit-rates. This program will use the <code>library/lookup_tables/lookUpTableSegmented_&lt;mode&gt;.csv</code> file to determine which game-types contributed to the final round wins, in conjunction with the pay-table and <code>library/forces/force_record_&lt;mode&gt;.json</code> files to generate frequency and average-win statistics for specific events or win combinations.</p>"},{"location":"math_docs/quickstart/#next-steps","title":"Next steps","text":"<p>These outputs corresponding directly with example Storybook packages within the <code>web-sdk</code>. It is recommended to take look through this pack to see how these math events are passed and displayed on the frontend. If you have your own game in mind you can use one of the sample games provided as a template and implement your own unique rules within the <code>games/&lt;game_name&gt;/</code> directory. You will likely need to specify configuration values for things like multipliers, prize-value etc.. wtihin <code>game_config.py</code>. Then any unique calculations and events should be handled within the games <code>game_executables/game_calculation</code> files. Generally speaking, reusable functions, events or calculation should like with <code>/src/</code>, which one-off game functionality belongs within that games folder <code>/games/&lt;game_id&gt;/</code>.</p>"},{"location":"math_docs/gamestate_section/events_info/","title":"Game Event Structures","text":"<p>Events are the JSON objects returned from the RGS <code>play/</code> API and make up the vast majority of data with a game's library. Events contain all information required by the front-end to display the current state of the game. Anything not contained within or implied by the events cannot be shown to the player. For a typical game this includes, but is not limited to</p> <ul> <li>Active game-board symbols</li> <li>Freespin counters</li> <li>Win counters</li> <li>Symbol win information</li> <li>Multipliers</li> <li>Special symbol actions </li> <li>....</li> </ul> <p>The events are crucial as all events need to be handled by the front-end. The user is free to determine their event structure, though to follow the example games, all events have the format,</p> <pre><code>event = {\n    \"index\": [int],\n    \"type\": [str],\n    \"&lt;field_1&gt;\": [T],\n    ...\n    \"&lt;field_n&gt;\": [T]\n}\n</code></pre> <p><code>\"index\"</code> keeps track of the current number of events in a simulation, <code>\"type\"</code> is a unique keyword used to identify an event and is generally a one-word description. <code>\"fields\"</code> are strings who's corresponding value can have any data-type, as required. Once constructed, the event is appended to the book, \"events\" field\":</p> <pre><code>gamestate.book.add_event(event)\n</code></pre> <p>Events are handled separately in the gamestate to game calculations or executables. They are imported explicitly and not attached to the gamestate object. Once the math-engine has made the appropriate board transformation or action, the event should be emitted immediately, as it will provide a snapshot of the current state of the game. For example:</p> <pre><code> from src.Events.Events import update_freespin_event\n run_spin():\n    ...\n    update_freespin_event(self)\n    ....\n</code></pre> <p>These events should be sent anytime new information needs to be communicated to the player.</p>"},{"location":"math_docs/gamestate_section/force_info/","title":"Custom Defined Events","text":"<p>Every betmode will have a corresponding <code>force_record_&lt;betmode&gt;.json</code>. This file records the <code>book-id</code> corresponding to a custom defined search key. Anytime <code>self.record()</code> is called where</p> <pre><code>def record(self, description: dict) -&gt; None:\n    self.temp_wins.append(description)\n    self.temp_wins.append(self.book_id)\n</code></pre> <p>The current simulation number will be appended to the description/key if it exists, otherwise a new dictionary entry is made based on the description passed to the <code>record()</code> function. For example, we may want to keep track of how many Scatter symbols caused a freegame trigger. Which will be useful for later analysis to investigate the frequency of any custom defined event. In the freespin trigger executable function for example,</p> <pre><code>def run_freespin_from_base(self, scatter_key: str = \"scatter\") -&gt; None:\n    self.record(\n        {\n            \"kind\": self.count_special_symbols(scatter_key),\n            \"symbol\": scatter_key,\n            \"gametype\": self.gametype,\n        }\n    )\n    self.update_freespin_amount()\n    self.run_freespin()\n</code></pre> <p>This will ultimately output a <code>force_record_&lt;betmode&gt;.json</code> with the entries:</p> <pre><code>[\n    {\n        \"search\": {\n            \"gametype\": \"basegame\",\n            \"kind\": 5,\n            \"symbol\": \"scatter\"\n        },\n        \"timesTriggered\": 22134,\n        \"bookIds\": [\n            7,\n            12,\n            ....\n        ]\n    },\n    {\n        \"search\": {\n            \"gametype\": \"basegame\",\n            \"kind\": 6,\n            \"symbol\": \"scatter\"\n        },\n        \"timesTriggered\": 1196,\n        \"bookIds\": [\n            9,\n            10\n            ...\n        ]\n    },\n    ...\n]\n</code></pre>"},{"location":"math_docs/gamestate_section/force_info/#summary-force-file","title":"Summary force file","text":"<p>Once all simulations have been completed, a <code>force.json</code> file is produced, which contains all unique search fields and keys. The intended use for this file is for prototyping, where a drop-down menu, or something of the sort can be created for all possible search conditions.</p>"},{"location":"math_docs/gamestate_section/force_info/#accounting-for-discarded-simulations","title":"Accounting for discarded simulations","text":"<p>The <code>record()</code> function does not directly append the key/book-id to the force file. This action is only performed once a simulation has completed and is accepted. This is to ensure that keys/ids are not prematurely added if a simulation is rejected. Therefore keys and corresponding simulation ids are appended to <code>self.temp_wins</code> and <code>self.temp_wins</code> before being finalized within the <code>imprint_wins()</code> function within <code>src/state/state.py</code>. Keys must be unique, and book-ids are not repeated within keys, though the same book-id may appear within several keys.</p>"},{"location":"math_docs/gamestate_section/repeat_info/","title":"Simulation Acceptance Criteria","text":"<p>When setting up the game configuration file each mode is split into different win-criteria. Given a total number of simulations for a given bet-mode, the number of simulations required for each criteria is set using a <code>quota</code>, which determines the ratio of the total number of simulations satisfying a particular win criteria. </p> <p>Following the example used in the Sample Games, the win criteria has been split into the following unique conditions:</p> <ol> <li><code>0</code> win amounts</li> <li><code>basegame</code> wins </li> <li><code>freegame</code> scenarios</li> <li><code>max-win</code> scenarios</li> </ol> <p>The purpose of segmenting these game outcomes is to ensure that there are sufficiently many simulations scenarios satisfying a certain criteria. For example if the hit-rate for a max-win is 1% of the available RTP for a game with a 5000x payout would be 1 in 500,000 outcomes. Though if we are only producing 1 Million simulations in total for this mode, we would like to have more than 2 simulations in total which result in the maximum win amount. This reduces the possibility of any players seeing the same outcomes for a specific win amount. </p> <p>In the aforementioned list <code>0</code> dictates that the payout multiplier is ==0 for that simulation number. <code>basegame</code> is essentially any basegame spin where the payout is &gt;0  and the <code>freegame</code> is not triggered. <code>freegame</code> is any scenario where the <code>freegame</code> is triggered from the basegame. <code>max-win</code> is any outcome where the maximum payout multiplier is awarded.</p> <p>This segmentation of wins is also used by the optimization algorithm.</p> <p>Pertinent to this section though, the simulation acceptance criteria is integral to the <code>repeat</code> condition implemented in all sample games. When the <code>GameState</code> is setup, the acceptance criteria is assigned to a specific simulation number before any simulations are carried out. So simulation 10, for example, is predetermined to be a simulation which triggers a <code>freegame</code>. </p> <p>When the <code>run_spin()</code> function is called and the game-round ends, whether or not the simulation is recorded and added to the library is partially determined by the final win condition. If the only condition is that the simulation must be a <code>0</code> payout, then the <code>final_win</code> value is checked. If this condition is satisfied the <code>self.repeat = False</code> and the outcome is saved. Likewise if a particular simulation is determined to be <code>freegame</code> criteria, at the end of the spin we verify if the freegame has been triggered and accept the simulation result if so. There can be as many conditions are required in the <code>self.check_repeat()</code> function. Just be aware that the more stringent the criteria, the longer a simulation will likely take to run. This time can be quite substantial if the required criteria is unlikely to be achieved naturally. For the <code>max-win</code> scenarios for example, generally a specifically made reelstrip is used, and the probability if achieving higher multipliers, prizes etc.. is dictated  in the bet-mode distribution.</p>"},{"location":"math_docs/gamestate_section/repeat_info/#predetermining-acceptance","title":"Predetermining Acceptance","text":"<p>While it would be useful to run the simulations first and then assign the distribution criteria afterwards, this can cause issues when multi-threading larger simulation batches. Simulations relating to max-wins for example typically take substantially longer to succeed than say <code>0</code> win simulations. This means that all criteria except the max-win are likely to be filled first, leaving the final thread to deal with many or all of the max-win simulations. For this reason, the <code>quota</code> in the BetMode distribution conditions is used in conjunction with the total number of simulations. </p>"},{"location":"math_docs/gamestate_section/win_info/","title":"Win calculations","text":"<p>There are several built-in win methods included in the engine:</p> <ol> <li>Lines pays</li> <li>Ways pays</li> <li>Cluster pays</li> <li>Scatter pays</li> </ol>"},{"location":"math_docs/gamestate_section/win_info/#_1","title":"Wins","text":"<p>Irrespective of the win method applied, win information is stored in the gamestate object win_data:</p> <pre><code> win_data = {\n    'totalWin': [float],\n    'wins': [List[Dict]]\n }\n</code></pre> <p>This initialized <code>win_data</code> structure is the return value for all provided win calculation functions. If using the predefined win events, the dictionary items within <code>wins</code> must contain the \"position\" key to account for modifying the row number if needed for the padding symbols. All wins information for the current game board should be included in this structure. Such as all winning symbol combinations, win amounts and positions. The built-in functions also include a `meta' key which includes any additional information which the front-end may need to display. For the win-lines, as an example this appears as:</p> <pre><code>'wins': {\n    'symbol': 'H1',\n    'kind': 5,\n    'win': 300,\n    'positions': [{'reel':1, 'row':1}, ...],\n    'meta':{\n        'lineIndex': 12,\n        'multiplier': 10,\n        'winWithoutMult': 30,\n        'globalMult': 1,\n        'lineMultiplier': 10\n    }\n}\n</code></pre> <p>This additional information includes any symbol or global multiplier values applied, the base win amount, and the <code>lineIndex</code>, as defined in config.paylines = {[], ...}``</p>"},{"location":"math_docs/gamestate_section/win_info/#multiplier-methods","title":"Multiplier methods","text":"<p>For generality all win methods utilize functions from the <code>wins/multiplier_strategy</code> file. By calling <code>apply_mult()</code> with a specified strategy (<code>global</code>, <code>symbol</code>, <code>combined</code>), base win amount and winning symbol positions, total win amounts are returned inclusive of any global multipliers or symbol multipliers. By default, if the <code>combined</code> or <code>symbol</code> strategy is used, multiplier values are added together from winning symbol positions, where the symbol object contains the <code>multiplier</code> attribute.</p>"},{"location":"math_docs/gamestate_section/win_info/#overlay-values","title":"Overlay values","text":"<p>The cluster and scatter pay sample games, there is an <code>overlay</code> key included ine <code>win_data</code> \"meta\" tag of the structure:</p> <pre><code>'meta': {\n    ...\n    'overlay': {'reel': [int], 'row': [int]}\n}\n</code></pre> <p>This position is calculated as the board position closest to the  centre-of-mass of winning clusters.</p>"},{"location":"math_docs/gamestate_section/win_info/#wallet-manager","title":"Wallet manager","text":"<p>When writing game logic, the intent is to have a clear separation of logic, events and wins for clarity. The wins are all handled through a <code>WalletManager</code> class, which will handle outcomes from single spins while also keeping track of total cumulative win amount for RTP calculations, as well as which gametype the wins arise from.</p> <p>This can be seen in a typical gamestate <code>run_spin()</code> function where wins are calculated, the wallet is updated and corresponding win events are emitted:</p> <pre><code>self.win_data = self.get_lines()\nself.win_manager.update_spinwin(self.win_data[\"totalWin\"])\nself.emit_linewin_events()\n</code></pre> <p>Within a single spin there are wallet manager values associated with:</p> <ol> <li><code>spin_win</code> <ul> <li>This is the win associated with a specific <code>reveal</code> event. If the freegame is entered, this value is reset for each new spin. </li> <li>Updated using <code>wallet_manager.update_spinwin(win_amount: float)</code></li> </ul> </li> <li><code>running_bet_win</code><ul> <li>This is the cumulative win amount for a simulation. The final value which the <code>running_bet_win</code> is updated with should match the <code>payout_multiplier</code> for that simulation. </li> <li>This value is automatically updated with the <code>wallet_manager.set_spinwin(win_amount: float)</code> method.</li> </ul> </li> <li><code>basegame_wins</code>/<code>freegame_wins</code><ul> <li>This value is updated once all basegame actions are completed, or at the end of each freegame spin.</li> <li>Updated using <code>wallet_manager.update_gametype_wins(self.gametype)</code></li> <li>Important! As part of the final payout verification self.final_win and sum(self.basegame_wins + self.freegame_wins) must match. If these two payouts do not match a <code>RuntimeError</code> is raised. </li> <li>This is useful for game analysis and applying the correct parameters to the optimization algorithm. </li> </ul> </li> <li>Cumulative simulation wins<ul> <li><code>total_cumulative_wins</code>, <code>cumulative_base_wins</code> and <code>cumulative_free_wins</code> wins are updated at the end of each simulation. This value is used to display the runtime RTP for all simulations when printed in the terminal.</li> <li>Updated using <code>wallet_manager.update_end_round_wins()</code> within the <code>imprint_wins</code> function.</li> </ul> </li> </ol>"},{"location":"math_docs/gamestate_section/configuration_section/betmode_dist/","title":"Distribution Conditions","text":"<p>Within each <code>BetMode</code> there is a set of <code>Distribution</code> Classes which determine the win-criteria within each bet-mode. Required fields are:</p> <ol> <li>Criteria<ul> <li>A shorthand name describing the win condition in a single word</li> </ul> </li> <li>Quota<ul> <li>This is the amount of simulations (as a ratio of the total number of bet-mode simulation) which need to satisfy the corresponding criteria. The quota is normalized when assigning criteria to simulations, so the sum of all quotas does not need to be 1. There is a minimum of 1 simulation assigned per criteria.</li> </ul> </li> <li> <p>Conditions</p> <ul> <li>Conditions can have an arbitrary number of keys. Though the required keys are:<ul> <li><code>reel_weights</code> </li> <li><code>force_wincap</code></li> <li><code>force_freegame</code></li> </ul> </li> </ul> <p>Note that <code>force_wincap</code> and <code>force_freegame</code> are set to <code>False</code> by default and do not have to be explicitly added.</p> <p>The most common use for the Distribution Conditions is when drawing a random value using the BetMode's built-in method <code>get_distribution_conditions()</code>. i.e. <code>multiplier = get_random_outcome(betmode.get_distribution_conditions()['mult_values'])</code> Or to check if a board forcing the <code>freegame</code> should be drawn with:</p> <p><code>if get_distribution_conditions()['force_freegame']:     ...</code></p> </li> <li> <p>Win criteria (optional)</p> <p>There is also a <code>win_criteria</code> condition which incorporates a payout multiplier into the simulation acceptance. The two commonly used conditions are <code>win_criteria = 0.0</code> and <code>win_criteria = self.wincap</code>. When calling <code>self.check_repeat()</code> at the end of a simulation, if <code>win_criteria</code> is not <code>None</code> (default), the final win amount must match the value passed. </p> <p>The intention behind betmode distribution conditions is to give the option to handle game actions in a way which depends on the (known) expected simulation. This is most clear if for example a simulation is known to correspond to a <code>max-win</code> scenario. Instead of repeated drawing random outcomes which are most likely to be rejected, we can alter the probabilities of larger payouts occurring by biasing a particular reelset, weighting larger prize or multiplier values etc..</p> </li> </ol>"},{"location":"math_docs/gamestate_section/configuration_section/betmode_overview/","title":"BetMode","text":"<p>All valid bet-modes are defined in the array <code>self.bet_modes = [ ...]</code>  The <code>BetMode</code> class is an important configuration for when setting up game the behavior of a game.This class is used to set maximum win amounts, RTP, bet cost, and distribution conditions. Additional noteworthy tags are:</p> <ol> <li><code>auto_close_disabled</code><ul> <li>When this flag is <code>False</code> (default) the RGS endpoint API <code>/endround</code> is called automatically to close out the bet for efficiency. When the bet is closed however, the player cannot resume their bet. It may be desirable in bonus modes for example, to set this flag to <code>True</code> so that the player can resume interrupted play even if the payout is <code>0</code>. This means that the front-end will have to manually close out the bet in this instance.</li> </ul> </li> <li><code>is_feature</code><ul> <li>When this flag is true, it tells the frontend to preserve the current bet-mode without the need for player interaction. So if the player changes to <code>alt_mode</code> where this mode has <code>is_feature = True</code>, every time the spin/bet button is pressed, it will call the last selected bet-mode. Unlike in bonus games, where the player needs to confirm the bet-mode choice after each round completion.</li> </ul> </li> <li><code>is_buybonus</code><ul> <li>This is a flag used for the frontend framework to determine if the mode has been purchased directly (and hence may require a change in assets).</li> </ul> </li> </ol> <p>For example, the BetMode class for a bonus/buy feature is taken from the sample lines game:</p> <pre><code>    BetMode(\n        name=\"bonus\",\n        cost=100.0,\n        rtp=self.rtp,\n        max_win=self.wincap,\n        auto_close_disabled=False,\n        is_feature=False,\n        is_buybonus=True,\n        distributions=[\n            Distribution(\n                criteria=\"wincap\",\n                quota=0.001,\n                win_criteria=self.wincap,\n                conditions={\n                    \"reel_weights\": {\n                        self.basegame_type: {\"BR0\": 1},\n                        self.freegame_type: {\"FR0\": 1, \"WCAP\": 5},\n                    },\n                    \"mult_values\": {\n                        self.basegame_type: {1: 1},\n                        self.freegame_type: {2: 10, 3: 20, 4: 50, 5: 60, 10: 100, 20: 90, 50: 50},\n                    },\n                    \"scatter_triggers\": {4: 1, 5: 2},\n                    \"force_wincap\": True,\n                    \"force_freegame\": True,\n                },\n            ),\n            Distribution(\n                criteria=\"freegame\",\n                quota=0.999,\n                conditions={\n                    \"reel_weights\": {\n                        self.basegame_type: {\"BR0\": 1},\n                        self.freegame_type: {\"FR0\": 1},\n                    },\n                    \"scatter_triggers\": {3: 20, 4: 10, 5: 2},\n                    \"mult_values\": {\n                        self.basegame_type: {1: 1},\n                        self.freegame_type: {2: 100, 3: 80, 4: 50, 5: 20, 10: 10, 20: 5, 50: 1},\n                    },\n                    \"force_wincap\": False,\n                    \"force_freegame\": True,\n                },\n            ),\n        ],\n    ),\n</code></pre>"},{"location":"math_docs/gamestate_section/configuration_section/config_overview/","title":"Game Configuration Files","text":"<p>The GameState object requires certain parameters to be specified, and should be manually filled out for each new game. These elements are all defined in the <code>__init__</code> function. Full details of the expected inputs and data-types are given in the Source Files/Config section. </p> <p>General aspects of the game setup which should be considered when creating a <code>game_config.py</code> are:</p>"},{"location":"math_docs/gamestate_section/configuration_section/config_overview/#game-types","title":"Game-types","text":"<p>Several parts of the engine such as win amount verification, special symbol triggers/attributes and win-levels require the engine to know if the current state of the game is in the basegame or freegame. For example it is common to perform a weighted draw of some value:  <code>python  #Within game config:  self.multiplier_values = {     \"basegame\":{1:100, 2:50, 3: 10},      \"freegame\":{2:20, 3:50, 5: 20, 10:10, 20:1}}  ....  #Within gamestate:  multiplier = get_random_outcome(self.config.multiplier_values[self.gametype])</code> Typically special rules apply when the player enters a freegame. The configuration file allows the user to specify the key corresponding to each gametype. By default this is set to <code>basegame</code> and <code>freegame</code> respectively. All simulations will start in the basegame mode unless otherwise specified, and the transition to the freegame state is handled in the default <code>reset_fs_spin()</code> function, which is called as soon as the <code>run_freespin()</code> function is entered. </p>"},{"location":"math_docs/gamestate_section/configuration_section/config_overview/#reels","title":"Reels","text":"<p>Most games will use distinct reelstrips for different game-types. It is commonplace for game-modes to have multiple possible reels per mode. One method of adjusting the overall RTP of a game is to have a multiple reelstrips with varying RTP, which can be selected from a weighted draw when calling <code>self.create_board_from_reelstrips()</code>. Reelstrips are stored as a dictionary in the <code>self.config.reels</code> object. The reelstrip key and csv file name should be specified:</p> <pre><code>reels = {\"BR0\": \"BR0.csv\", \"FR0\": \"FR0.csv\"}\nself.reels = {}\nfor r, f in reels.items():\n    self.reels[r] = self.read_reels_csv(str.join(\"/\", [self.reels_path, f]))\n</code></pre> <p>Reelstrip weightings are required distribution conditions. An example of using multiple reelstrips for each gametype can be applied as:</p> <pre><code>conditions={\n    \"reel_weights\": {self.basegame_type: {\"BR0\": 2, \"BR1\": 1}, self.freegame_type: {\"FR0\":5, \"FR1\": 1}},\n},\n</code></pre>"},{"location":"math_docs/gamestate_section/configuration_section/config_overview/#scatter-triggers-and-anticipation","title":"Scatter triggers and Anticipation","text":"<p>Freegame entry from the basegame or retriggers in the freegame should be specified in the format <code>{num_scatters: num_spins}</code>,</p> <pre><code>self.freespin_triggers = {\n    self.basegame_type: {3: 10, 4: 15, 5: 20},\n    self.freegame_type: {2: 4, 3: 6, 4: 8, 5: 10},\n}\n</code></pre>"},{"location":"math_docs/gamestate_section/configuration_section/config_overview/#symbol-initialization","title":"Symbol initialization","text":"<p>A symbol is determined to be valid if the name exists either in <code>self.paytable</code> or in <code>self.special_symbols</code>. If a symbol that does not exist in either of these fields is detected when loading reelstrips, a <code>RuntimeError</code> is raised.</p>"},{"location":"math_docs/gamestate_section/configuration_section/config_overview/#symbol-values","title":"Symbol values","text":"<p>Winning symbols are determined from the <code>self.paytable</code> dictionary object in the game configuration. The expected format is:</p> <pre><code>self.paytable = {\n    (kind[int], name[str]): value[float],\n    ...\n}\n</code></pre> <p>Where <code>kind</code> is the number of winning symbols. For cascading games, or other circumstances where multiple winning symbol numbers pay the same about, for example in the scatter pays example game where 13+ symbols pay the same amount, <code>self.pay_group</code> can be defined. By then calling <code>self.paytable = self.convert_range_table(pay_group)</code> a paytable of the expected format is generated. The format of the pay-group objects (inclusive of both values in the kind-range) is given as:</p> <pre><code>self.pay_group = {\n    ((min_kind[int],max_kind[int]), name[str]): value[float],\n    ...\n}\n</code></pre>"},{"location":"math_docs/gamestate_section/configuration_section/config_overview/#special-symbols","title":"Special symbols","text":"<p>Special symbol attributes are assigned based on names appearing in <code>self.special_symbols = {attribute[str]: [name[str], ...]}</code>. Multiple symbols can share attributes and multiple attributes can be applied to the same symbol. Most games will at least have a <code>wild</code> and <code>scatter</code> attribute. Once the symbol is initialized, the value of the attribute is accessed through <code>symbol.attribute</code> or symbol.get_attribute(attribute) see Symbols for more information regarding symbol object structures. By default the attribute is set to <code>True</code>, unless otherwise overridden using the <code>gamestate.special_symbol_functions</code>, defined in the gamestate override.</p>"},{"location":"math_docs/gamestate_section/syms_board_section/board_info/","title":"Active Game Board","text":"<p>The active game-board is created as a 2D array of symbol objects. Each object within the array creates a new object instance. </p>"},{"location":"math_docs/gamestate_section/syms_board_section/board_info/#displaying-the-board","title":"Displaying the board","text":"<p>The board can be displayed by calling the <code>print_board()</code> method in the <code>Board</code> class, which will display a correctly orientated printout of all symbol names</p> <pre><code>self.print_board(self.board) -&gt;\n</code></pre> <pre><code>L5 L3 L4 L4 L4 \nL3 H4 L3 H1 L4 \nL3 H1 S  L3 H1 \n</code></pre>"},{"location":"math_docs/gamestate_section/syms_board_section/board_info/#active-special-symbols","title":"Active special symbols","text":"<p>When the game board is generated any symbols appearing in <code>config.special_symbols = {'property' : [symbols, ..]}</code> will be appended to the gamestate property <code>special_symbols_on_board = {'property': [{'reel': reel[int], 'row': row[int]}]}</code>. This property is particularly useful for checking aspects such as freegame entry conditions:</p> <pre><code>    if len(self.special_symbols_on_board['scatter']) &gt;= min_scatter:\n        self.run_freespin_from_base()\n</code></pre> <p>Care should be taken to update any new symbols which may appear on the board either from cascading events or through the application of some special action, such as removing symbols from the game board. If custom functions are being used which involve altering active symbols, the method <code>get_special_symbols_on_board()</code> from the <code>Board</code> class should be invoked.</p>"},{"location":"math_docs/gamestate_section/syms_board_section/board_info/#tumbling-the-board","title":"Tumbling the board","text":"<p>For cascading games (such as the Scatter and Cluster example games), winning symbols are removed from the board and symbols above tumble down to fill these vacant positions. Winning symbols are assigned the attribute <code>explode</code>. Subsequently when the <code>tumble_board()</code> method is called from the <code>Tumble</code> class, </p>"},{"location":"math_docs/gamestate_section/syms_board_section/board_info/#topbottom-symbols","title":"Top/bottom symbols","text":"<p>In the <code>config</code> class, there is a boolean option <code>include_padding</code>. This is to account for games where it is desirable for the player to see the symbols immediately above/below the active board. Usually this is displayed as a symbol being partially in-frame. If this flag is set to true, the row indexing for the active game board will start at <code>row=1</code>, where <code>row 0</code> is the <code>top_symbol</code> and <code>row len(board) + 1</code> is the <code>bottom_symbol</code>. The top and bottom symbols are included in the <code>board</code> <code>reveal</code> event. Within the gamestate these symbols are stored as:</p> <pre><code>self.top_symbols = [s1, s2, ....]\nself.bottom_symbols = [s1, s2, ....]\n</code></pre> <p>Note that for cascading/tumbling games, the top symbol is preserved during the tumble.</p>"},{"location":"math_docs/gamestate_section/syms_board_section/symbol_info/","title":"Symbol structure","text":"<p>Symbols are handled as their own distinct class objects. Based only off a symbol name, several useful attibutes are assigned to the object based on if the symbol name appears in in the <code>config.paytable</code> or <code>config.special_symbols</code> fields. </p> <pre><code>class Symbol:\n    def __init__(self, config: object, name: str) -&gt; None:\n        self.name = name\n        self.special_functions = []\n        self.special = False\n        is_special = False\n        for special_property in config.special_symbols.keys():\n            if name in config.special_symbols[special_property]:\n                setattr(self, special_property, True)\n                is_special = True\n\n        if is_special:\n            setattr(self, \"special\", True)\n\n        self.assign_paying_bool(config)\n</code></pre> <p>When a new game-board is drawn, a 2D array of symbol objects are generated. At a minimum, the symbol will have the attributes:</p> <ul> <li>Name<ul> <li>[string] shorthand name, typically 1 or 2 letters</li> </ul> </li> <li>special_functions<ul> <li>Within the <code>GameStateOverride</code> class, special functions can be applied to a symbol as soon as the object is created. This is done through the abstract function, for example:</li> </ul> </li> </ul> <pre><code>def assign_special_sym_function(self):\n    self.special_symbol_functions = {\n        \"W\": [self.assign_mult_property],\n    }\ndef assign_mult_property(self, symbol):\n    multiplier_value = get_random_outcome(\n        self.get_current_distribution_conditions()[\"mult_values\"][self.gametype]\n    )\n    symbol.assign_attribute({\"multiplier\": multiplier_value})\n</code></pre> <pre><code>`assign_special_sym_function()` is called when the `GameState` is initially created. In this example, we are assigning a multiplier value to any new wild ('W') which is created. Any action defined within `self.special_symbol_functions` with the format `{&lt;name&gt;: @callable_func}` will be assigned to the `special_functions` property.\n</code></pre> <ul> <li>is_special<ul> <li>This property is assigned as <code>False</code> by default unless the name appears as a value within <code>config.special_symbols</code></li> </ul> </li> <li>special_property<ul> <li>Properties appearing in <code>config.special_functions = {'property': [name]}</code> are set to <code>True</code> by default. </li> </ul> </li> <li>assign_paying_bool()<ul> <li>This function assigns the properties <code>is_paying</code> and <code>paytable</code>. If the symbol name appears in <code>config.paytable</code> <code>is_paying</code> is set to <code>True</code> and the relevant paytable values are assigned to <code>paytable</code>. Otherwise these values are set to <code>False</code> and <code>None</code> respectively.</li> </ul> </li> </ul>"},{"location":"math_docs/gamestate_section/syms_board_section/symbol_info/#symbol-attributes","title":"Symbol Attributes","text":"<p>In addition to the application of <code>special_functions</code>, attributes are an important characteristic of symbol objects, particularly for checking if there are any special symbols on the game-board which require additional actions. For example if we want to check if a given symbol has a <code>prize</code> or <code>multiplier</code> attribute:</p> <pre><code>if self.board[reel][row].check_attribute('prize','multiplier'):\n    ...\n</code></pre> <p>The <code>check_attribute</code> function will return a <code>boolean</code> value if the given attribute exists and its value is not <code>False</code>. I.e.:</p> <pre><code>if symbol.check_attribute('prize'):\n    win += symbol.get_attribute('prize')\n</code></pre> <p>Furthermore we can assign properties to a symbol using the <code>assign_attribute</code> method. As an example, if we have a game where we have a special symbol denoted by the <code>enhance</code> tag. Where the effect of this symbol is to add a <code>multiplier</code> value to any active <code>Wild</code> symbols. In the <code>gamestate</code> we could preform the following actions:</p> <pre><code>if len(self.special_symbols_on_board['enhance']) &gt; 0:\n    for sym in self.special_symbols_on_board[wild]:\n        mult_val = get_random_outcomes(self.config.mult_values[self.gametype])\n        self.board[sym['reel']][sym['row']].assign_attribute({'multiplier', mult_val})\n</code></pre>"},{"location":"math_docs/optimization_section/optimization_algorithm/","title":"Optimizing win distributions with iterative weighted sampling","text":"<p>A discussion of how the provided optimization algorithm operates can be viewed by downloading this paper.</p> <p>The aforementioned algorithm is implemented in the Rust programming language, this program compiles down to a binary executable. If the program is being run for the first time, or if there are modifications made to the main.rs file, the binary should be rebuilt using:</p> <pre><code>cargo build --release\n</code></pre>"},{"location":"math_docs/optimization_section/optimization_algorithm/#setting-up-optimization-parameters","title":"Setting up optimization parameters","text":"<p>The optimization algorithm parameters can be setup and passed within the run.py file Game-specific parameters should be set using the OptimizationSetup class. This Class takes as input the game configuration class and appends opt_params. This is a dictionary where the keys are the betmode names and have the required inputs:</p> <pre><code>opt_params = &lt;mode_name&gt; : {\n    \"conditions\": ...\n    \"scaling\": ...\n    \"parameters: \n}\n</code></pre> <p>Each key has a corresponding construction class within <code>optimization_algorithm/optimization_config.py</code></p>"},{"location":"math_docs/optimization_section/optimization_algorithm/#conditions","title":"Conditions","text":"<p>The <code>conditions</code> key has the setup class <code>ConstructConditions</code>. This key separates out specific simulation numbers which the optimization algorithm is applied to. The optimization program requires knowing what RTP to optimize a subset of solutions to.  This is generally separated out into events where it is desirable to control the frequency of such an event occurring. Such as freegame, max wins or 0-win hit-rates. For each of these win types, we need to have a well defined RTP, meaning that we need 2 of the 3 variables, RTP, average wins, hit-rates. You will notice that for the 0 win conditions in the sample game the hit-rate is undefined (x), this is allowed because it is a free-variable. Since all hit-rates of all win-types must sum to be exactly 1, we are able to deduce the hit-rate using 1 - (sum of all other win-type allocations).</p> <p>IMPORTANT: The order of the conditions keys matters, as the simulation ids corresponding to each of these keys must be exclusive. The optimization tool reads these conditions entries in order and assigns the corresponding simulation-ids to each key before removing them from the available pool of simulations. So for example, a wincap simulation will mostly likely also correspond to a freegame simulation, therefore wincap must be called first.</p>"},{"location":"math_docs/optimization_section/optimization_algorithm/#scaling","title":"Scaling","text":"<p>We are able to bias particular win-ranges within the optimization program. We initially generating our trial distributions, we can artificially increase or decrease the the Gaussian weights within this range by a particular scale factor. We can also assign a probability of these weights being assigned for each distribution created. Note that biasing particular ranges by a significant amount can be lead to a lower likelihood of a randomly assigned distribution being accepted, so its effect should be used carefully. </p>"},{"location":"math_docs/optimization_section/optimization_algorithm/#parameters","title":"Parameters","text":"<p>This input is used to construct a setup file red by the optimization tool. It defines the number of distributions to trial before combination, minimum and maximum mean-to-median distribution scores to control volatility as well as the number of simulated test spins to run in order to rank viable distributions. </p>"},{"location":"math_docs/optimization_section/optimization_algorithm/#executing-optimization-script","title":"Executing optimization script","text":"<p>Once the game specific <code>OptimizationSetup</code> class is constructed, a <code>math_config.json</code> file is generated containing all relevant game parameters in conjunction with a <code>setup.txt</code> file detailing simulation setup optimization parameters, handled with the <code>OptimizationExecution</code> class. Within the <code>run.py</code> file we can specify which game modes we would like to optimize and directly run the Rust binary using:</p> <pre><code>optimization_modes_to_run = [\"base\", \"bonus\"]\nOptimizationExecution().run_all_modes(config, optimization_modes_to_run, rust_threads)\n</code></pre>"},{"location":"math_docs/overview_section/game_format/","title":"Standard Game Setup Requirements","text":"<p>Without diving into specific functions, this section is intended to walkthrough how a new slot game would generally be setup. In practice it is recommended to start with one of the sample games which closest resemble the game being made, or otherwise starting from the template.</p>"},{"location":"math_docs/overview_section/game_format/#configuration-file","title":"Configuration file","text":"<p>Game parameters should all be set in the <code>GameConfig</code> <code>__init__()</code> function. This is where to set the name name, RTP, board dimensions, payouts, reels and various special symbol actions. All required fields are listed in the <code>Config</code> class and should be filed out explicitly for each new game. Next the <code>BetMode</code> classes are defined. Generally there would be at a minimum a (default) <code>base</code> game and a <code>freegame</code>, which is usually purchased. </p> <pre><code>class GameConfig(Config):\n    def __init__(self):\n        super().__init__()\n        self.game_id = \"\"\n        self.provider_number = 0\n        self.working_name = \"\"\n        self.wincap = 0\n        self.win_type = \"lines\"\n        self.rtp = 0\n\n        self.num_reels = 0\n        self.num_rows = [0] * self.num_reels  \n        self.paytable = {\n            (kind, symbol): payout, \n        }\n\n        self.include_padding = True\n        self.special_symbols = {\"property\": [\"sym_name\"],...}\n\n        self.freespin_triggers = {\n        }\n        self.reels = {}\n        self.bet_modes = []\n</code></pre> <p>Each <code>BetMode</code> should likewise be set explicitly, defining the cost, rtp maximum win amounts and various gametype flags. We would like to define different win criteria within each betmode. In the sample games we define distinct criteria for any game-aspects where we would like to control either the hit-rate and/or RTP allocation. In this example we would like to control the basegame hit-rate, max-win hit-rate and freegame hit-rate. Therefore we need to specify unique <code>Distribution</code> criteria for each of these special conditions. Further information about purpose of Distribution conditions can be found here and here</p> <pre><code>    BetMode(\n        name=\"base\",\n        cost=1.0,\n        rtp=self.rtp,\n        max_win=self.wincap,\n        auto_close_disabled=False,\n        is_feature=True,\n        is_buybonus=False,\n        distributions=[\n            Distribution(\n                criteria=\"winCap\",\n                quota=0.001,\n                win_criteria=self.wincap,\n                conditions={\n                    \"reel_weights\": {\n                        self.basegame_type: {\"BR0\": 1},\n                        self.freegame_type: {\"FR0\": 1},\n                    },\n                    \"force_wincap\": True,\n                    \"force_freegame\": True,\n                },\n            ),\n            Distribution(\n                criteria=\"freegame\",\n                quota=0.1,\n                conditions={\n                    \"reel_weights\": {\n                        self.basegame_type: {\"BR0\": 1},\n                        self.freegame_type: {\"FR0\": 1},\n                    },\n                    \"force_wincap\": False,\n                    \"force_freegame\": True,\n                },\n            ),\n            Distribution(\n                criteria=\"0\",\n                quota=0.4,\n                win_criteria=0.0,\n                conditions={\n                    \"reel_weights\": {self.basegame_type: {\"BR0\": 1}},\n                },\n            ),\n            Distribution(\n                criteria=\"basegame\",\n                quota=0.5,\n                conditions={\n                    \"reel_weights\": {self.basegame_type: {\"BR0\": 1}},\n                },\n            ),\n        ],\n    )\n</code></pre>"},{"location":"math_docs/overview_section/game_format/#gamestate-file","title":"Gamestate file","text":"<p>When any simulation is run, the entry point will be the <code>run_spin()</code> function, which lives in the <code>GameState</code> class. <code>GameExecutables</code> and <code>GameCalculations</code> are child classes of <code>GameState</code> and also deal with game specific logic.</p> <p>The generic structure would follow the format:</p> <pre><code>def run_spin(self, sim):\n    self.reset_seed(sim) #seed the RNG with the simulation number \n    self.repeat = True\n    while self.repeat:\n        self.reset_book() #reset local variables\n        self.draw_board() #rraw board from reelstrips\n\n        #evaluate win_data\n        #update win_manager\n        #emit relevant events\n\n        self.win_manager.update_gametype_wins(self.gametype) #update cumulative basegame wins\n        if self.check_fs_condition(): #check scatter conditions\n            self.run_freespin_from_base() #run freegame\n\n        self.evaluate_finalwin()\n        self.check_repeat() #Verify betmode distribution conditions are satisfied\n\n    self.imprint_wins() #save simulation result\n</code></pre> <p>For reproducibility the RNG is seeded with the simulation number. Betmode distribution criteria are preassigned to each simulation number, requiring the <code>self.repeat</code> condition to be initially set until the spin has completed and it can be checked that any criteria-specific conditions or win amounts are satisfied. Note that <code>self.repeat = False</code> is set in the <code>self.reset_book()</code> function. This function will reset all relevant <code>GameState</code> properties to default values. </p> <p>Generally the first steps will be to use the reelstrips provided in the configuration file to draw a board from randomly chosen reelstop positions. Wins are evaluated from one of the provided win-types for the active board, and the wallet manager is updated. After this game-logic is completed the relevant events (such as <code>reveal</code> and <code>winInfo</code>) are emitted. All sample games follow these three steps: 1. Calculate current state of the board 2. Update wallet manager 3. Emit events</p> <p>To keep track of which gametype wins are allocated, the wallet manger is again invoked once all basegame actions are complete. If the game have a freegame mode and the triggering conditions are satisfied the <code>run_freespin()</code> function is invoked. This mode will have a similar structure:</p> <pre><code>def run_freespin(self):\n    self.reset_fs_spin() #reset freegame variables\n    while self.fs &lt; self.tot_fs: #account for multiple freegame spins\n        self.update_freespin() #update spin number and emit event\n        self.draw_board() #draw a new board using freegame reelstrips\n\n        #evaluate win_data\n        #update win_manager\n        #emit relevant events\n\n        if self.check_fs_condition(): #check retrigger conditions\n            self.update_fs_retrigger_amt()\n\n        self.win_manager.update_gametype_wins(self.gametype) #update cumulative freegame win amounts\n\n    self.end_freespin() #emit event to indicate end of freegame\n\n</code></pre> <p>While it is possible to perform all game actions within these functions, for clarity functions from <code>GameExecutables</code> and <code>GameCalculations</code> are typically invoked and should be created on a game-by-game basis depending on requirements. </p>"},{"location":"math_docs/overview_section/game_format/#runfile","title":"Runfile","text":"<p>Finally to produce simulations, the <code>run.py</code> file is used to create simulation outputs and config files containing game and simulation details. </p> <pre><code>if __name__ == \"__main__\":\n\n    num_threads = 1\n    rust_threaeds = 20\n    batching_size = 50000\n    compression = False\n    profiling = False\n\n    num_sim_args = {\n        \"base\": int(10),\n        \"bonus\": int(10),\n    }\n\n    config = GameConfig()\n    gamestate = GameState(config)\n\n    create_books(\n        gamestate,\n        config,\n        num_sim_args,\n        batching_size,\n        num_threads,\n        compression,\n        profiling,\n    )\n    generate_configs(gamestate)\n\n</code></pre> <p>The <code>create_books</code> function handles the allocation of win criteria to simulation numbers, output file format and multi-threading parameters. </p>"},{"location":"math_docs/overview_section/game_format/#outputs","title":"Outputs","text":"<p>Simulation outputs are placed in the <code>game/library/</code> folder. <code>books/books_compressed</code> is the primary data-file containing all events and payout multipliers. <code>lookup_tables</code> hold the summary simulation-payout values in <code>.csv</code> format which is consumed by the optimization algorithm. Additionally for game analysis, lookup table mapping of which simulations belong to which win criteria and which gametype wins arise from are produced. <code>force/</code> file outputs contain all information used by the <code>.record()</code> function, which is again useful for analyzing the frequency and average win amounts for specific events. The optimization algorithm also uses the recorded <code>force</code> data to identify which simulations correspond to specific win criteria. Finally <code>config/</code> files contain information required by the frontend such as symbol and betmode information, backend information such as file hash values and a configuration file for the optimization algorithm.</p> <p>The optimization algorithm consumes the lookup table and outputs a copy of the file, but with modified weights. To assist with setting optimization parameters, there are two other files with the prefix <code>lookUpTableIdToCriteria</code> and <code>lookUpTableSegmented</code>. These files are used to identify which bet-mode sub-type that specific simulation number belongs to (such as max-wins, 0-wins, freegame entry etc..), and what gametype (usually basegame or freegame) contributes to the final payout multiplier.</p>"},{"location":"math_docs/overview_section/game_struct/","title":"Intended Engine Usage","text":""},{"location":"math_docs/overview_section/game_struct/#game-files","title":"Game Files","text":"<p>As seen in the example games, all games follow a recommended structure, which should be copied from the games/template folder. </p> <pre><code>```\ngame/\n\u251c\u2500\u2500 library/\n|----- books/\n|----- books_compressed/\n|----- configs/\n|----- forces/\n|----- lookup_tables/\n\u251c\u2500\u2500 reels/\n\u251c\u2500\u2500 readme.txt\n\u251c\u2500\u2500 run.py\n\u251c\u2500\u2500 game_config.py\n\u251c\u2500\u2500 game_executables.py\n\u251c\u2500\u2500 game_calculations.py\n\u251c\u2500\u2500 game_events.py\n\u251c\u2500\u2500 game_override.py\n\u2514\u2500\u2500 gamestate.py\n```\n</code></pre> <p>Sub-folders within library/ are automatically generated if they do not exist at the completion of the simulation. readme.txt is used for developer descriptions of game mechanics and miscellaneous information relevant to that particular game.</p> <p>While all commonly used engine functions are handled by classes within their respective src/ directory, every game is likely to be unique in some way and these game-files allow the user to override existing functions in order to add additional engine features to suit their use-case, or implement game-specific logic. </p> <p>The game_config/executables/calculations/events/override files offer extensions on actions defined in the Source Files section, which should be consulted for more detailed information.</p>"},{"location":"math_docs/overview_section/game_struct/#run-file","title":"Run-file","text":"<p>This file is used to set simulation parameters, specifically the configuration and <code>GameState</code> classes. The required specifications include:</p> Parameter Type Description <code>num_threads</code> <code>int</code> Number of threads used for multithreading <code>rust_threads</code> <code>int</code> Number of threads used by the Rust compiler <code>batching_size</code> <code>int</code> Number of simulations run on each thread <code>compression</code> <code>bool</code> <code>True</code> for <code>.json.zst</code> compressed books, <code>False</code> for <code>.json</code> format <code>profiling</code> <code>bool</code> <code>True</code> outputs and opens a <code>.svg</code> flame graph <code>num_sim_args</code> <code>dict[int]</code> Keys must match bet mode names in the game configuration <p>All simulations are passed to the <code>create_books()</code> function which carries out all the simulations and handles file output. This function will populate <code>library/</code> <code>books_compressed</code>, <code>books</code>, <code>forces</code>,  <code>lookup_tables</code> folders.</p> <p>Once the simulations are completed, the gamestate is passed to <code>generate_configs(gamestate)</code> which handles generating config files used for the frontend (<code>config_fe.json</code>), backend (<code>config.json</code>) and optimization (<code>config_math.json</code>). </p>"},{"location":"math_docs/overview_section/game_struct/#library-folders","title":"Library Folders","text":""},{"location":"math_docs/overview_section/game_struct/#booksbooks_compressed","title":"books/books_compressed","text":"<p>Depending on the compression tag passed to <code>create_books()</code> the <code>books/</code> or <code>books_compressed/</code> folders will be populated with the events emitted from the simulation. </p>"},{"location":"math_docs/overview_section/game_struct/#configs","title":"configs","text":"<p>This will consist of three <code>.json</code> files for the math, frontend and backend. The details of which are described here.</p>"},{"location":"math_docs/overview_section/game_struct/#lookup_tables","title":"lookup_tables","text":"<p>Once any given simulation is compete the events associated are stored within the books, and the corresponding payout details are recorded in a lookup table of the format:</p> Simulation Weight Payout <code>int</code> <code>int</code> <code>float</code> <p>All simulations start with an assigned weight of <code>1</code>, which is then modified if the optimization algorithm is applied. </p>"},{"location":"math_docs/overview_section/game_struct/#configs_1","title":"Configs","text":"<p>The GameConfig inherits the Config class. All information defined in the init function are required inputs. Symbol information, pay-tables, reels-strips and bet-mode information are all specified here. </p>"},{"location":"math_docs/overview_section/game_struct/#gamestate","title":"Gamestate","text":"<p>Every game has a gamestate.py file, where independent simulation states are handled. The run_spin() function is required and used as the entry_point from create_books to execute the a single simulation. run_freespin is also used in all sample games, though is not a required function if the game does not contain a free-spin entry from the base-game.</p>"},{"location":"math_docs/overview_section/game_struct/#executables","title":"Executables","text":"<p>Commonly used groups of game-logic and event emission is provided in this location. Functions called in the run_spin() functions will typically belong to the Executables/GameExecutables classes. </p> <p>Functions currently in this class include drawing random or forced game-boards, handling game-logic for several win-types and their associated win information events, updating and </p>"},{"location":"math_docs/overview_section/game_struct/#misc-calculations","title":"Misc. Calculations","text":"<p>The Executables class inherits all miscellaneous game-logic and board-actions. Primarily this includes all win-evaluation types:  * Lines  * Ways  * Scatter (pay anywhere)  * Cluster   * Expanding wild + prize collection</p> <p>Additionally other classes attached to Executables are tumbling/cascading of winning symbols and Conditions for checking the current simulation state</p>"},{"location":"math_docs/overview_section/state_overview/","title":"The State Machine","text":""},{"location":"math_docs/overview_section/state_overview/#introduction","title":"Introduction","text":"<p>The GameState class serves as the central hub for managing all aspects of a simulation batch. It handles:</p> <ul> <li>Simulation parameters</li> <li>Game modes</li> <li>Configuration settings</li> <li>Simulation results</li> <li>Output files</li> </ul> <p>The entry point for all game simulations is the <code>run.py</code> file, which initializes parameters through the Config class and creates a GameState object. The GameState ensures consistency across simulations and provides a unified structure for managing game logic and outputs.</p>"},{"location":"math_docs/overview_section/state_overview/#key-responsibilities-of-gamestate","title":"Key Responsibilities of <code>GameState</code>","text":""},{"location":"math_docs/overview_section/state_overview/#simulation-configuration","title":"Simulation Configuration","text":"<ul> <li>Compression</li> <li>Tracing</li> <li>Multithreading</li> <li>Output files</li> <li>Cumulative win manager</li> </ul>"},{"location":"math_docs/overview_section/state_overview/#game-configuration","title":"Game Configuration","text":"<ul> <li>Betmode details (costs, names, etc.)</li> <li>Paytable</li> <li>Symbols</li> <li>Reelsets</li> </ul> <p>These global <code>GameState</code> attributes remain consistent across all game modes and simulations. When a simulation runs, the <code>run_spin()</code> method creates a sub-instance of the GeneralGameState, allowing modifications to game data directly through the <code>self</code> object. This design reduces the need for passing objects between functions, streamlining game logic development.</p> <p>At a high level, the structure of the engine is shown below: </p>"},{"location":"math_docs/overview_section/state_overview/#extending-core-functionality","title":"Extending Core Functionality","text":"<p>The <code>GameState</code> class acts as a super-class containing core functionality. Custom games can extend or override this functionality using Python's Method Resolution Order (MRO). Once simulations are complete, the relevant output files are generated sequentially for each BetMode. These outputs can then be optimized and uploaded to the Admin Control Panel (ACP).</p>"},{"location":"math_docs/overview_section/state_overview/#class-inheritance","title":"Class Inheritance","text":""},{"location":"math_docs/overview_section/state_overview/#why-use-class-inheritance","title":"Why Use Class Inheritance?","text":"<p>Class inheritance ensures flexibility, allowing developers to access core functions while customizing specific behaviors for each game. Core functions are defined in the Source Files and can be overridden at the game level.</p>"},{"location":"math_docs/overview_section/state_overview/#gamestateoverride-gamegame_overridepy","title":"GameStateOverride (game/game_override.py)","text":"<p>This class is the first in the Method Resolution Order (MRO) and is responsible for modifying or extending actions from the <code>state.py</code> file. For example, all sample games override the <code>reset_book()</code> function to accommodate game-specific parameters:</p> <pre><code>def reset_book(self):\n    super().reset_book()\n    self.reset_grid_mults()\n    self.reset_grid_bool()\n    self.tumble_win = 0\n</code></pre>"},{"location":"math_docs/overview_section/state_overview/#gameexecutables-gamegame_executablespy","title":"GameExecutables (game/game_executables.py)","text":"<p>This class groups commonly used game actions into executable functions. These functions can be overridden to introduce new mechanics at the game level. For example, triggering freespins based on scatter symbols:</p> <pre><code>config.freespin_triggers = {3: 8, 4: 10, 5: 12}\n\ndef update_freespin_amount(self, scatter_key: str = \"scatter\") -&gt; None:\n    self.tot_fs = self.config.freespin_triggers[self.gametype][self.count_special_symbols(scatter_key)]\n    fs_trigger_event(self, basegame_trigger=True, freegame_trigger=False)\n</code></pre> <p>However in the <code>0_0_scatter</code> sample game, we would instead want to assign the total spins to be 2x the number of active Scatters. Therefore we can override the function in the <code>GameExecutables</code> class:</p> <pre><code>def update_freespin_amount(self, scatter_key: str = \"scatter\"):\n    self.tot_fs = self.count_special_symbols(scatter_key) * 2\n    fs_trigger_event(self, basegame_trigger=basegame_trigger, freegame_trigger=freegame_trigger)\n</code></pre>"},{"location":"math_docs/overview_section/state_overview/#gamecalculations-gamesgame_calculationspy","title":"GameCalculations (games/game_calculations.py)","text":"<p>This class handles game-specific calculations, inheriting from GameExecutables.</p>"},{"location":"math_docs/overview_section/state_overview/#books-and-libraries","title":"Books and Libraries","text":""},{"location":"math_docs/overview_section/state_overview/#what-is-a-book","title":"What is a \"Book\"?","text":"<p>A \"book\" represents a single simulation result, storing: - The payout multiplier - Events triggered during the round - Win conditions</p> <p>Each simulation generates a Book object, which is stored in a library. The library is a collection of all books generated during a simulation batch. These books are attached to the global GameState object and are used for further analysis and optimization.</p> <p>Example JSON structure:</p> <pre><code>[\n    {\n        \"id\": int,\n        \"payoutMultiplier\": float,\n        \"events\": [ {}, {}, {} ],\n        \"criteria\": str,\n        \"baseGameWins\": float,\n        \"freeGameWins\": float\n    }\n]\n</code></pre>"},{"location":"math_docs/overview_section/state_overview/#resetting-the-book","title":"Resetting the Book","text":"<p>At the start of a simulation, the book is reset to ensure a clean state:</p> <pre><code>def reset_book(self) -&gt; None:\n    self.book = {\n        \"id\": self.sim + 1,\n        \"payoutMultiplier\": 0.0,\n        \"events\": [],\n        \"criteria\": self.criteria,\n    }\n</code></pre>"},{"location":"math_docs/overview_section/state_overview/#lookup-tables","title":"Lookup Tables","text":""},{"location":"math_docs/overview_section/state_overview/#what-are-lookup-tables","title":"What are Lookup Tables?","text":"<p>Lookup tables provide a summary of all simulation payouts, offering a convenient way to calculate win distribution properties and Return To Player (RTP) values. Each table is stored as a CSV file and contains the following columns:</p> Simulation Number Simulation Weight Payout Multiplier 1 1 0.0 2 1 92.3 ... ... ... <p>The payoutMultipler attached to a book represents the final amount paid to the player, inclusive or basegame and freegame wins. The LookUpTable csv file is a summary of all simulation payouts. This provides a convenient way to calculate win distribution properties and Return To Player calculations. All lookup tables will be of the format:</p> <p>Purpose of Lookup Tables</p> <ul> <li>Win Distribution Analysis: Analyze payout distributions across simulations.</li> <li>RTP Calculation: Calculate the overall RTP for a game mode.</li> <li>Optimization: Serve as input for the optimization algorithm, which adjusts simulation weights to achieve desired payout characteristics.</li> </ul> <p>File Naming Convention</p> <ul> <li>Initial Lookup Tables: lookUpTable_mode.csv</li> <li>Optimized Lookup Tables: lookUpTable_mode_0.csv</li> </ul> <p>The optimization algorithm modifies the weight values in the lookup table, which are initially set to 1. These optimized tables are then used for further analysis or deployment.</p>"},{"location":"math_docs/sample_section/sample_games/","title":"Sample Games","text":"<p>There are 4 example games included to showcase different win-types and mechanics. All games have a basegame mode (all 1x bet cost) and 1 freegame mode. The expanding wilds game additionally has a superspin mode to showcase how prize-values are handled.</p> <p>Each game-type has a readme.txt file with a brief description of game-rules (copied below).</p>"},{"location":"math_docs/sample_section/sample_games/#lines-games","title":"Lines Games","text":"<p>This is an example of a simple lines-game-win</p> <p>Wilds have multipliers in the freeGame and have the effect of multiplying a given line win the addition multiplier values attached to Wild symbols,  only when the multiplier value is &gt; 1.</p>"},{"location":"math_docs/sample_section/sample_games/#basegame","title":"Basegame:","text":"<p>Scatter Symbols appear on all reels, a minimum of 3 Scatters are needed to trigger the Freegame</p>"},{"location":"math_docs/sample_section/sample_games/#freegame","title":"FreeGame:","text":"<p>A seperate reelset is used for the freegame  Wilds have larger multipliers in the freegame (minimum of 2x) and appear on all reels 2 Scatters are needed to trigger extra spins, appearing only on reels 2,3,4</p> <p>Notes: Wilds only pay on 5-Kind. If the paytable is chosen such that 3/4 Kind Wilds pay, the line calculation will assign the highest base-win symbols as winning. For example if there is a 3-Kind Wild is on the same line as a 5-Kind L4, the 3-Kind wild will be chosen, regardless of the multiplier on the final Wild since the base payout 3W &gt; 5L4</p>"},{"location":"math_docs/sample_section/sample_games/#ways-game","title":"Ways Game","text":"<p>Standard ways game with 5-reels and 3-rows. </p> <ul> <li>9 paying symbols (H1-H5, L1-L4)</li> <li>1 wild type of Wild symbol</li> <li>1 type of Scatter symbol</li> <li>Multipliers on Wilds (in freegame only)</li> <li>Wilds do not appear on 1st reel</li> </ul>"},{"location":"math_docs/sample_section/sample_games/#basegame_1","title":"Basegame","text":"<p>Minimum of 3 Scatter symbols are needed to enter the freegame. Maximum of 1 Scatter per reel.</p>"},{"location":"math_docs/sample_section/sample_games/#freegame-rules","title":"Freegame rules","text":"<p>Wild symbols have multipliers ranging from 1x to 5x. Multiplier values compound multiplicatively (unlike lines games where multiplier values add)</p>"},{"location":"math_docs/sample_section/sample_games/#cluster-based-win-game","title":"Cluster-based win game","text":"<p>Clusters of 5 or more like-symbols are removed from the board, and symbols above on the reelstrip fall to fill their place.</p>"},{"location":"math_docs/sample_section/sample_games/#basegame_2","title":"Basegame:","text":"<p>Standard tumbling game with Scatter and Wild symbols. Minimum of 4 Scatter symbols are required for freeSpin triggers</p>"},{"location":"math_docs/sample_section/sample_games/#freegame_1","title":"Freegame:","text":"<p>Same basegame rule, except grid positions have multipliers. Grid positions start in a 'deactivated' state. Once one win occurs, the position is 'activated' starting with a 1x multiplier - for every winning cluster, the multiplier value at that position is doubled (up to 512x) There is a global multiplier, which increases by +1 for every freespin and does not reset on each spin A minimum of 3 scatters are required for re-triggers</p>"},{"location":"math_docs/sample_section/sample_games/#notes","title":"Notes:","text":"<p>Because of the separation between basegame and freegame types - there is an additional freespin entry check to check of the criteria requires a forced  freespin condition. Otherwise, occurrences of Scatter symbols tumbling onto the board during basegame criteria may appear.</p>"},{"location":"math_docs/sample_section/sample_games/#scatter-pays-game","title":"Scatter-Pays Game","text":""},{"location":"math_docs/sample_section/sample_games/#summary","title":"Summary:","text":"<ul> <li>A 6-reel, 5-row pay-anywhere tumbling (cascading) game.</li> <li>8 paying total (4 high, 4 low)</li> <li>2 special symbols (wild, scatter)</li> </ul> <p>Symbols payouts are grouped by cluster-sizes (8-8), (9-10), (11,13), (14,36)</p>"},{"location":"math_docs/sample_section/sample_games/#basegame_3","title":"Basegame:","text":"<p>Minimum of 3 Scatter symbols needed for freegame trigger.  2 freegame spins are awarded for each Scatter. </p>"},{"location":"math_docs/sample_section/sample_games/#freegame-rules_1","title":"Freegame rules","text":"<p>Every tumble increments the global multiplier by +1, which is persistent throughout the freegame The global multiplier is applied to the tumble win as they are removed from the board After all tumbles have completed: multiply the cumulative tumble win by multipliers on board  (multipliers on board do not increment the global mult) If there is a multiplier symbol on the board, this is added to the global multiplier before the final evaluation</p>"},{"location":"math_docs/sample_section/sample_games/#notes_1","title":"Notes","text":"<p>Due to the potential for symbols to tumble into the active board area, there is no upper limit on the number of freegame that can be awarded. The total number of freegame is 2 * (number of Scatters on board). To account for this the usual 'updateTotalFreeSpinAmount' function is overridden  in the game_executables.py file.</p>"},{"location":"math_docs/sample_section/sample_games/#event-descriptions","title":"Event descriptions","text":"<p>\"winInfo\" Summarizes winning combinations. Includes multipliers, symbol positions, payInfo [passed for every tumble event] \"tumbleBanner\" includes values from the cumulative tumble, with global mult applied \"setWin\" this the result for the entire spin (from on Reveal to the next). Applied after board has stopped tumbling \"seTotalWin\" the cumulative win for a round. In the base-game this will be equal to the setWin, but in the bonus it will incrementally increase </p>"},{"location":"math_docs/sample_section/sample_games/#expanding-wilds-lines-superspin-mode","title":"Expanding Wilds Lines + Superspin mode","text":"<ul> <li>5-reel, 5-rows</li> <li>15 paylines</li> <li>9 paying symbols</li> <li>1 type of Wild</li> <li>1 type of scatter </li> </ul> <p>Superspin mode, costing 25x. This mode is independent, with no freegame entry. </p> <ul> <li>1 dead symbol (1)</li> <li>1 prize symbol </li> </ul>"},{"location":"math_docs/sample_section/sample_games/#basegame_4","title":"basegame","text":"<p>Standard lines games rules with Wilds paying on 3, 4 and 5-kind </p>"},{"location":"math_docs/sample_section/sample_games/#freegame_2","title":"freegame","text":"<p>1 Wild can initially appear on each reel. Symbol then expands out to fill all active rows. Expanded symbol is sticky and persistent for all remaining freegame spins. On each new reveal a random multiplier ranging from 2x - 50x is assigned. No retriggers in freegame. </p>"},{"location":"math_docs/sample_section/sample_games/#superspin","title":"superspin","text":"<p>This is a hold em' style game. The player can purchase a spin for 25x, and starts with 3 lives Each time a prize symbol lands on the board, the 3 available spins reset.  Prizes are sticky and evaluated once the player has no new spins remaining. </p> <p>This game has a purchase-only 'super-spin' mode. This mode can only be activated through a buy menu and cannot be accessed using Scatters like bonus-games</p>"},{"location":"math_docs/source_section/board_info/","title":"Board","text":""},{"location":"math_docs/source_section/board_info/#game-board","title":"Game Board","text":"<p>The <code>Board</code> class inherits the <code>GeneraGameState</code> class and handles the generation of game boards. Most commonly used is the <code>create_board_reelstrips()</code> function. Which selects a reelset as defined in the <code>BetMode.Distribution.conditions</code> class. For each reel a random stopping position is chosen with uniform probability on the range [0,len(reelstrip[reel])-1]. For each reelstop a 2D list of <code>Symbol</code> objects are created and attached to the GameState object. </p> <p>Additionally, special symbol information is included (special_symbols_on_board) along with the reelstop values (reel_positions), padding symbols directly above and below the active board (padding_positions) and which reelstrip-id was used.</p> <p>The is also an anticipation field which is used for adding a delay to reel reveals if the number of Scatters required for trigging the freegame is almost satisfied. This is an array of values initialized to <code>0</code> and counting upwards in <code>+1</code> value increments. For example if 3 Scatter symbols are needed to trigger the freegame and there are Scatters revealed on reels 0 and 1, the array would take the form (for a 5 reel game):</p> <pre><code>self.anticipation = [0, 0, 1, 2, 3]\n</code></pre> <p>If the selected reel_pos + the length of the board is greater than the total reelstrip length, the stopping position is wrapped around to the 0 index:</p> <pre><code> self.reelstrip[reel][(reel_pos - 1) % len(self.reelstrip[reel])]\n</code></pre> <p>The reelset used is drawn from the weighted possible reelstrips as defined in the <code>BetMode.betmode.distributions.conditions</code> class (and hence is a required field in the <code>BetMode</code> object):</p> <pre><code>    self.reelstrip_id = get_random_outcome(\n        self.get_current_distribution_conditions()[\"reel_weights\"][self.gametype]\n    )\n</code></pre> <p>Specific stopping positions can also be forced given a reelstrip-id and integer stopping values from <code>force_board_from_reelstrips()</code>. If no integer value are provided for a reel, a random position is chosen. This function is typically used in conjunction with <code>executables.force_special_board</code>, which will search a reelstrip for a particular symbol name and randomly select a specified number of stopping positions, chosen to land on a randomly selected board row. </p> <p>Additionally the <code>Board</code> class handled symbol generation, displaying the current <code>.board</code> in the terminal, and retrieving symbol positions and properties as defined in <code>config.special_symbols</code>. </p>"},{"location":"math_docs/source_section/cluster_info/","title":"Cluster Pays","text":"<p>Cluster games award wins when there are sufficiently many neighboring like-symbols. Neighbours must share the same reel or row, where diagonal connections do not count towards the cluster size. A minimum of 5 like-symbols is typical, though this can be defined in <code>GameConfig</code> class. Since it is possible for up to <code>num_rows * num_columns</code> winning symbols to occur, it is common to define a particular payout range. For example <code>5 kind</code> pays <code>p1</code> <code>6-7 kind</code> to pay <code>p2</code>, <code>8-10 kind</code> to pay <code>p3</code> and <code>12+</code> symbols pay <code>p4</code> etc... Instead of manually including all possible pay combinations in <code>config.paytable</code> there is a <code>convert_range_table()</code> function in the Config class which takes in a symbol range, name and payout amount which is used to generate all <code>config.paytable</code> entries. This pay group should be of the format:</p> <pre><code>    paygroup = {\n        ((min_combination[int], max_combination[int]), name[str]) : payout[float],\n        ... \n    }\n\n</code></pre> <p>Ranges defined in <code>min_combination</code> and <code>max_combination</code> are inclusive, so for example if the <code>5-kind</code> payout for symbol <code>H1</code> pays <code>10x</code>, this would be written as: <code>((5,5),H1): 10</code>.</p> <p>Often (though not always) cluster pays games include a tumbling mechanic. Within the cluster sample game for example, while there are still winning combinations, the board is tumbled, wins are evaluated for the new board, the wallet manager is updated and relevant events are emitted:</p> <pre><code>    while self.win_data[\"totalWin\"] &gt; 0 and not (self.wincap_triggered):\n        self.tumble_game_board()\n        self.win_data = self.get_cluster_data(record_wins=True)\n        self.win_manager.update_spinwin(self.win_data[\"totalWin\"])\n        self.emit_tumble_win_events()\n</code></pre> <p>Clusters are found using a Breath First Search (BFS) algorithm. Wild attributes can be set (<code>wild</code> is the default value). Wild symbols can contribute to multiple clusters, including those formed by different symbols. </p>"},{"location":"math_docs/source_section/config_info/","title":"Config class object","text":"<p>The game-specific configuration <code>GameConfig</code> inherits the <code>Config</code> super class. This contains all game specifications, many of which will be set manually for each new game within <code>GameConfig</code>. <code>Config</code> allows for setting custom <code>win_levels</code>, which are returned during win-events and can indicate the type of animation which needs to be played. Additionally the class sets up several path destinations used for writing files and functions to read in and verify reelstrips stored in the <code>.csv</code> format. </p>"},{"location":"math_docs/source_section/event_info/","title":"Events Module Documentation","text":""},{"location":"math_docs/source_section/event_info/#overview","title":"Overview","text":"<p>The <code>events.py</code> module defines reusable game events that modify the <code>gamestate</code> and log significant actions. These events ensure proper tracking of game states and facilitate structured client communication.</p>"},{"location":"math_docs/source_section/event_info/#functions","title":"Functions","text":""},{"location":"math_docs/source_section/event_info/#json_ready_symsymbol-special_attributes","title":"<code>json_ready_sym(symbol, special_attributes)</code>","text":"<p>Purpose: Converts a symbol object into a dictionary suitable for JSON serialization, including only specified attributes.</p> <p>Parameters: - <code>symbol (object)</code>: The symbol object to convert. - <code>special_attributes (list)</code>: A list of attribute names to include if they are not <code>False</code>.</p>"},{"location":"math_docs/source_section/event_info/#reveal_eventgamestate","title":"<code>reveal_event(gamestate)</code>","text":"<p>Purpose: Logs the initial board state, including padding symbols if enabled.</p>"},{"location":"math_docs/source_section/event_info/#fs_trigger_eventgamestate-include_padding_index-basegame_trigger-freegame_trigger","title":"<code>fs_trigger_event(gamestate, include_padding_index, basegame_trigger, freegame_trigger)</code>","text":"<p>Purpose: Logs the triggering of free spins, whether from the base game or a retrigger event.</p> <p>Assertions: - Either <code>basegame_trigger</code> or <code>freegame_trigger</code> must be <code>True</code>, not both. - <code>gamestate.tot_fs</code> must be greater than 0.</p>"},{"location":"math_docs/source_section/event_info/#set_win_eventgamestate-winlevel_keystandard","title":"<code>set_win_event(gamestate, winlevel_key='standard')</code>","text":"<p>Purpose: Updates the cumulative win amount for a single outcome.</p>"},{"location":"math_docs/source_section/event_info/#set_total_eventgamestate","title":"<code>set_total_event(gamestate)</code>","text":"<p>Purpose: Updates the total win amount for a betting round, including all free spins.</p>"},{"location":"math_docs/source_section/event_info/#set_tumble_eventgamestate","title":"<code>set_tumble_event(gamestate)</code>","text":"<p>Purpose: Logs wins from consecutive tumbles.</p>"},{"location":"math_docs/source_section/event_info/#wincap_eventgamestate","title":"<code>wincap_event(gamestate)</code>","text":"<p>Purpose: Emits an event when the maximum win amount is reached, stopping further spins.</p>"},{"location":"math_docs/source_section/event_info/#win_info_eventgamestate-include_padding_indextrue","title":"<code>win_info_event(gamestate, include_padding_index=True)</code>","text":"<p>Purpose: Logs winning symbol positions and their win amounts, adjusting for padding if enabled.</p>"},{"location":"math_docs/source_section/event_info/#update_tumble_win_eventgamestate","title":"<code>update_tumble_win_event(gamestate)</code>","text":"<p>Purpose: Updates the banner for tumble win amounts.</p>"},{"location":"math_docs/source_section/event_info/#update_freespin_eventgamestate","title":"<code>update_freespin_event(gamestate)</code>","text":"<p>Purpose: Logs the current and total free spins remaining.</p>"},{"location":"math_docs/source_section/event_info/#freespin_end_eventgamestate-winlevel_keyendfeature","title":"<code>freespin_end_event(gamestate, winlevel_key='endFeature')</code>","text":"<p>Purpose: Logs the end of a free spin feature and assigns the final win level.</p>"},{"location":"math_docs/source_section/event_info/#final_win_eventgamestate","title":"<code>final_win_event(gamestate)</code>","text":"<p>Purpose: Logs the final payout multiplier at the end of a simulation.</p>"},{"location":"math_docs/source_section/event_info/#update_global_mult_eventgamestate","title":"<code>update_global_mult_event(gamestate)</code>","text":"<p>Purpose: Logs changes to the global multiplier.</p>"},{"location":"math_docs/source_section/event_info/#tumble_board_eventgamestate","title":"<code>tumble_board_event(gamestate)</code>","text":"<p>Purpose: Logs symbol positions removed during a tumble and their replacements.</p>"},{"location":"math_docs/source_section/event_info/#usage-notes","title":"Usage Notes","text":"<ul> <li>Each function appends an event dictionary to <code>gamestate.book['events']</code>.</li> <li>Deep copies ensure that modifications do not affect past event states.</li> <li>Events provide structured output suitable for UI updates and analytics.</li> </ul> <p>This module is essential for maintaining a transparent, trackable game state across different game mechanics.</p>"},{"location":"math_docs/source_section/executables_info/","title":"Executables Class Documentation","text":""},{"location":"math_docs/source_section/executables_info/#overview","title":"Overview","text":"<p>The <code>Executables</code> class groups together common actions that are likely to be reused across multiple games. These functions can be overridden in <code>GameExecutables</code> or <code>GameCalculations</code> if game-specific alterations are required. Generally, <code>Executables</code> functions do not return values.</p>"},{"location":"math_docs/source_section/executables_info/#function-descriptions","title":"Function Descriptions","text":""},{"location":"math_docs/source_section/executables_info/#draw_boardemit_event-bool-true-none","title":"<code>draw_board(emit_event: bool = True) -&gt; None</code>","text":"<p>Forces the initial reveal to have a specific number of scatters if bet mode criteria specify it. Otherwise, it generates a new board and ensures it does not contain more scatters than necessary.</p>"},{"location":"math_docs/source_section/executables_info/#force_special_boardforce_criteria-str-num_force_syms-int-none","title":"<code>force_special_board(force_criteria: str, num_force_syms: int) -&gt; None</code>","text":"<p>Forces a board to have a specified number of a particular symbol by modifying reel stops.</p>"},{"location":"math_docs/source_section/executables_info/#get_syms_on_reelreel_id-str-target_symbol-str-listlist","title":"<code>get_syms_on_reel(reel_id: str, target_symbol: str) -&gt; List[List]</code>","text":"<p>Returns reel stop positions for a specific symbol name.</p>"},{"location":"math_docs/source_section/executables_info/#emit_wayswin_events-none","title":"<code>emit_wayswin_events() -&gt; None</code>","text":"<p>Transmits win events associated with ways wins.</p>"},{"location":"math_docs/source_section/executables_info/#emit_linewin_events-none","title":"<code>emit_linewin_events() -&gt; None</code>","text":"<p>Transmits win events associated with line wins.</p>"},{"location":"math_docs/source_section/executables_info/#emit_tumble_win_events-none","title":"<code>emit_tumble_win_events() -&gt; None</code>","text":"<p>Transmits win and new board information upon a tumble event.</p>"},{"location":"math_docs/source_section/executables_info/#tumble_game_board-none","title":"<code>tumble_game_board() -&gt; None</code>","text":"<p>Removes winning symbols from the active board and replaces them, triggering a tumble board event.</p>"},{"location":"math_docs/source_section/executables_info/#evaluate_wincap-none","title":"<code>evaluate_wincap() -&gt; None</code>","text":"<p>Checks if the running bet win has reached the wincap limit and stops further spin functions if necessary.</p>"},{"location":"math_docs/source_section/executables_info/#count_special_symbolsspecial_sym_criteria-str-int","title":"<code>count_special_symbols(special_sym_criteria: str) -&gt; int</code>","text":"<p>Returns the number of active symbols of a specified special kind.</p>"},{"location":"math_docs/source_section/executables_info/#check_fs_conditionscatter_key-str-scatter-bool","title":"<code>check_fs_condition(scatter_key: str = \"scatter\") -&gt; bool</code>","text":"<p>Checks if there are enough active scatters to trigger free spins.</p>"},{"location":"math_docs/source_section/executables_info/#check_freespin_entryscatter_key-str-scatter-bool","title":"<code>check_freespin_entry(scatter_key: str = \"scatter\") -&gt; bool</code>","text":"<p>Ensures that the bet mode criteria are expecting a free spin trigger before proceeding.</p>"},{"location":"math_docs/source_section/executables_info/#run_freespin_from_basescatter_key-str-scatter-none","title":"<code>run_freespin_from_base(scatter_key: str = \"scatter\") -&gt; None</code>","text":"<p>Triggers the free spin function and updates the total number of free spins available.</p>"},{"location":"math_docs/source_section/executables_info/#update_freespin_amountscatter_key-str-scatter-none","title":"<code>update_freespin_amount(scatter_key: str = \"scatter\") -&gt; None</code>","text":"<p>Sets the initial number of spins for a free game and transmits an event.</p>"},{"location":"math_docs/source_section/executables_info/#update_fs_retrigger_amtscatter_key-str-scatter-none","title":"<code>update_fs_retrigger_amt(scatter_key: str = \"scatter\") -&gt; None</code>","text":"<p>Updates the total number of free spins available when a retrigger occurs.</p>"},{"location":"math_docs/source_section/executables_info/#update_freespin-none","title":"<code>update_freespin() -&gt; None</code>","text":"<p>Called before a new reveal during free spins, resetting spin win data and other relevant attributes.</p>"},{"location":"math_docs/source_section/executables_info/#end_freespin-none","title":"<code>end_freespin() -&gt; None</code>","text":"<p>Transmits the total amount awarded during the free spin session.</p>"},{"location":"math_docs/source_section/executables_info/#evaluate_finalwin-none","title":"<code>evaluate_finalwin() -&gt; None</code>","text":"<p>Checks base and free spin sums, then sets the payout multiplier accordingly.</p>"},{"location":"math_docs/source_section/executables_info/#update_global_mult-none","title":"<code>update_global_mult() -&gt; None</code>","text":"<p>Increments the multiplier value and emits the corresponding event.</p>"},{"location":"math_docs/source_section/executables_info/#dependencies","title":"Dependencies","text":"<p>This class relies on multiple external modules, including: - <code>src.state.state_conditions.Conditions</code> - <code>src.calculations.lines.LineWins</code> - <code>src.calculations.cluster.ClusterWins</code> - <code>src.calculations.scatter.ScatterWins</code> - <code>src.calculations.ways.WaysWins</code> - <code>src.calculations.tumble.Tumble</code> - <code>src.calculations.statistics.get_random_outcome</code> - <code>src.events.events</code> (Various event handling functions)</p> <p>These modules provide necessary game logic, event management, and mathematical calculations for the execution of the class functions.</p>"},{"location":"math_docs/source_section/executables_info/#usage","title":"Usage","text":"<p>This class is designed as a base class and is expected to be extended by game-specific implementations where needed. It ensures core game mechanics, such as board generation, free spin handling, and win event management, are handled in a reusable manner.</p>"},{"location":"math_docs/source_section/file_info/","title":"Output files","text":"<p>All relevant output files are automatically generated within the <code>game/library/</code> directories. If the required sub-directories do not exist, the will be automatically generated.</p>"},{"location":"math_docs/source_section/file_info/#books","title":"Books","text":"<p>The primary data file output when simulations are run are the book files. These contain summary simulation information such as the final payout multiplier, basegame and freegame win contributions, the simulation criteria and simulation events. The contents of <code>book.events</code> is the information returned by the RGS <code>play/</code> API response. </p> <p>The uncompressed <code>books/</code> files are used within the front-end testing framework and should be used to debug events. Only a small number of simulations should be run due to the file size. Compressed book files are what is uploaded to <code>AWS</code> and consumed by the RGS when games are being uploaded. Only data from compressed books will be returned from the <code>play/</code> API.</p>"},{"location":"math_docs/source_section/file_info/#force-files","title":"Force files","text":"<p>Each bet mode will output a file of the format <code>force_mode.json</code>. Every time the <code>.record()</code> function is called, the description keys used as input are appended to the file. If the key already exists, the <code>book-id</code> is appended to the array. This file is used to count instances of particular events. The optimization algorithm also makes use of these keys to identify max-win and freegame books. Once all bet mode simulations are finished, a <code>force.json</code> file is output which contains all the unique fields and keys.</p>"},{"location":"math_docs/source_section/file_info/#lookup-tables","title":"Lookup tables","text":"<p>The final payout multiplier for each simulation is summarized in the <code>lookUpTable_mode.csv</code>. This is the file accessed by the optimization algorithm, which works by adjusting the weights, initially assigned to <code>1</code>. There is also a <code>IdToCriteria</code> file which indicates the win criteria required by a specific simulation number, and a <code>Segmented</code> file used to identify what gametype contributed to the final payout multiplier. Both these additional files are not typically uploaded to the ACP and are instead used for various analysis functions.</p>"},{"location":"math_docs/source_section/file_info/#config-files","title":"Config files","text":"<p>There are three config files generated after all simulations and optimizations are run. <code>config_math.json</code> is used by the optimization algorithm and contains all relevant bet mode details, RTP splits and optimization parameters. <code>config_fe.json</code> is used by the front-end frame work and contains symbol information, padding reels and bet mode details which need to be displayed to players. <code>config.json</code> contains bet mode information and file hash information and used used by the RGS to determine and verify changes to files being uploaded to the ACP.</p>"},{"location":"math_docs/source_section/file_info/#file-path-construction","title":"File path construction","text":"<p>The <code>OutputFiles</code> class within <code>src/config/output_filenames</code> is used to construct filepaths and output filenames as well as setting up output folders if they do not yet exist.</p>"},{"location":"math_docs/source_section/lines_info/","title":"Line wins evaluation","text":"<p>The <code>LinesWins</code> object evaluates winning symbol combinations for the current <code>self.board</code> state. Generally 3 or more consecutive symbols result in a win, though these specific combination numbers and payouts can be defined in:</p> <pre><code>config.paytable = {(kind[int], symbol[string]): payout[float]}\n</code></pre> <p>In order to identify winning lines, line arrays must be defined in:</p> <pre><code>config.paylines = {\n    0: [0,0,0,0,0],\n    1: [0,1,0,1,0],\n        ...    \n    }\n</code></pre> <p>in the <code>.paylines</code> dictionary, the key is the line-index and the value is an array dictating which rows result in a winning combination. Like symbols are matched and if the key <code>(kind, name)</code> exists in <code>self.paytable</code>, the corresponding win is evaluated. </p> <p>Custom keys used to identify wild attributes and symbol names can be explicitly set and will default to <code>\"wild\"</code> and <code>\"W\"</code> unless otherwise specified. In the case of <code>(kind, \"W\")</code> existing in <code>self.paytable</code>, the base payout value is checked against the <code>(kind, sym)</code> where sym is the first non-wild. If for example the payline <code>[0,0,0,0,0]</code> has the symbol combination <code>[W,W,W,L4,L4]</code>, resulting in wins <code>(3,\"W\")</code> or <code>(5,\"L4\")</code>. We compare both outcomes and determine that the three-kind Wild combination has a larger payout. Therefore we only take the first three symbols as the winning combination. Note that the sample lines calculation provided will only take into account the base-game wins. If the game is more complex, such as having multipliers on symbols, the final payout amount may need to be handled separately when deciding which winning combination to use. One common approach to dealing with this is to only define the Wild symbols to pay when there is a complete line (so only 5-kind Wilds would pay for a board of this size).</p> <p>The <code>get_lines()</code> evaluation function returns all win information including the winning symbol name, winning positions, number of consecutive matches and win amounts. The <code>meta</code> information also includes symbol and global multiplier information, as well as the index of winning lines as defined in `config.paylines = {index: [line], ... }. </p>"},{"location":"math_docs/source_section/scatter_info/","title":"Scatter Pays","text":"<p>Scatter-pays (pay-anywhere) games award wins based on the total number of like-symbols appearing on the game board. Symbols do not have to be arranged in any order. Typically a minimum of 8 like-symbols (or Wilds) are required to count as a win, though these values can be defined in the <code>GameConfig</code> class. Since it is possible for up to <code>num_rows * num_columns</code> winning symbols to occur, it is common to define a particular payout range. For example <code>8-kind</code> pays <code>p1</code> <code>9-kind</code> to pay <code>p2</code>, <code>10-12</code> kind to pay <code>p3</code> and <code>12+</code> symbols pay <code>p4</code> etc... Instead of manually including all possible pay combinations in <code>config.paytable</code> there is a <code>convert_range_table()</code> function in the Config class which takes in a symbol range, name and payout amount which is used to generate all <code>config.paytable</code> entries. This pay group should be of the format:</p> <pre><code>    paygroup = {\n        ((min_combination[int], max_combination[int]), name[str]) : payout[float],\n        ... \n    }\n\n</code></pre> <p>Ranges defined in <code>min_combination</code> and <code>max_combination</code> are inclusive, so for example if the <code>8-kind</code> payout for symbol <code>H1</code> pays <code>10x</code>, this would be written as: <code>((8,8),H1): 10</code>.</p> <p>Often (though not always) Scatter pays games are also cascading/tumbling. Within the scatter sample game for example, while there are still winning combinations, the board is tumbled, wins are evaluated for the new board, the wallet manager is updated and relevant events are emitted:</p> <pre><code>    while self.win_data[\"totalWin\"] &gt; 0 and not (self.wincap_triggered):\n        self.tumble_game_board()\n        self.win_data = self.get_scatterpay_wins(record_wins=True)\n        self.win_manager.update_spinwin(self.win_data[\"totalWin\"])\n        self.emit_tumble_win_events()\n</code></pre> <p>The Scatter pay evaluation function also checks for <code>multiplier</code> and <code>wild</code> attributes attached to symbols. Wild symbols can contribute to wins for any number of symbols. </p>"},{"location":"math_docs/source_section/state_info/","title":"GeneralGameState Class Overview","text":""},{"location":"math_docs/source_section/state_info/#class-generalgamestate","title":"Class: <code>GeneralGameState</code>","text":""},{"location":"math_docs/source_section/state_info/#description","title":"Description:","text":"<p>The <code>GeneralGameState</code> class is an abstract base class (ABC) that defines the general structure for game states. Other game state classes inherit from it. It includes methods for initializing game configurations, resetting states, managing wins, and running simulations.</p>"},{"location":"math_docs/source_section/state_info/#constructor","title":"Constructor:","text":""},{"location":"math_docs/source_section/state_info/#__init__self-config","title":"<code>__init__(self, config)</code>","text":"<ul> <li>Initializes the game state with the provided configuration.</li> <li>Initializes variables like <code>library</code>, <code>recorded_events</code>, <code>special_symbol_functions</code>, <code>win_manager</code>, <code>criteria</code>, etc.</li> <li>Calls helper methods to reset seeds, create symbol mappings, reset book values, and assign special symbol functions.</li> </ul>"},{"location":"math_docs/source_section/state_info/#methods","title":"Methods:","text":""},{"location":"math_docs/source_section/state_info/#create_symbol_mapself-none","title":"<code>create_symbol_map(self) -&gt; None</code>","text":"<ul> <li>Extracts all valid symbols from the configuration.</li> <li>Constructs a <code>SymbolStorage</code> object containing all the symbols from the paytable and special symbols.</li> </ul>"},{"location":"math_docs/source_section/state_info/#assign_special_sym_functionself-abstract-method","title":"<code>assign_special_sym_function(self)</code> (Abstract Method)","text":"<ul> <li>This method must be overridden in derived classes to define custom symbol behavior.</li> <li>Issues a warning if no special symbol functions are defined.</li> </ul>"},{"location":"math_docs/source_section/state_info/#reset_bookself-none","title":"<code>reset_book(self) -&gt; None</code>","text":"<ul> <li>Resets global game state variables such as <code>board</code>, <code>book_id</code>, <code>book</code>, and <code>win_data</code>.</li> <li>Initializes default values for win tracking and spin conditions.</li> <li>Resets <code>win_manager</code> state.</li> </ul>"},{"location":"math_docs/source_section/state_info/#reset_seedself-sim-int-0-none","title":"<code>reset_seed(self, sim: int = 0) -&gt; None</code>","text":"<ul> <li>Resets the random number generator seed based on the simulation number for reproducibility.</li> </ul>"},{"location":"math_docs/source_section/state_info/#reset_fs_spinself-none","title":"<code>reset_fs_spin(self) -&gt; None</code>","text":"<ul> <li>Resets the free spin game state when triggered.</li> <li>Updates <code>gametype</code> and resets spin wins in <code>win_manager</code>.</li> </ul>"},{"location":"math_docs/source_section/state_info/#get_betmodeself-mode_name-betmode","title":"<code>get_betmode(self, mode_name) -&gt; BetMode</code>","text":"<ul> <li>Retrieves a bet mode configuration based on its name.</li> <li>Prints a warning if the bet mode is not found.</li> </ul>"},{"location":"math_docs/source_section/state_info/#get_current_betmodeself-object","title":"<code>get_current_betmode(self) -&gt; object</code>","text":"<ul> <li>Returns the current active bet mode.</li> </ul>"},{"location":"math_docs/source_section/state_info/#get_current_betmode_distributionsself-object","title":"<code>get_current_betmode_distributions(self) -&gt; object</code>","text":"<ul> <li>Retrieves the distribution information for the current bet mode based on the active criteria.</li> <li>Raises an error if criteria distribution is not found.</li> </ul>"},{"location":"math_docs/source_section/state_info/#get_current_distribution_conditionsself-dict","title":"<code>get_current_distribution_conditions(self) -&gt; dict</code>","text":"<ul> <li>Returns the conditions required for the current criteria setup.</li> <li>Raises an error if bet mode conditions are missing.</li> </ul>"},{"location":"math_docs/source_section/state_info/#get_wincap_triggeredself-bool","title":"<code>get_wincap_triggered(self) -&gt; bool</code>","text":"<ul> <li>Checks if a max-win cap has been reached, stopping further spin progress if triggered.</li> </ul>"},{"location":"math_docs/source_section/state_info/#in_criteriaself-args-bool","title":"<code>in_criteria(self, *args) -&gt; bool</code>","text":"<ul> <li>Checks if the current win criteria match any of the given arguments.</li> </ul>"},{"location":"math_docs/source_section/state_info/#recordself-description-dict-none","title":"<code>record(self, description: dict) -&gt; None</code>","text":"<ul> <li>Records specific game events to the <code>temp_wins</code> list for tracking distributions.</li> </ul>"},{"location":"math_docs/source_section/state_info/#check_force_keysself-description-none","title":"<code>check_force_keys(self, description) -&gt; None</code>","text":"<ul> <li>Verifies and adds unique force-key parameters to the bet mode configuration.</li> </ul>"},{"location":"math_docs/source_section/state_info/#combineself-modes-betmode_name-none","title":"<code>combine(self, modes, betmode_name) -&gt; None</code>","text":"<ul> <li>Merges forced keys from multiple mode configurations into the target bet mode.</li> </ul>"},{"location":"math_docs/source_section/state_info/#imprint_winsself-none","title":"<code>imprint_wins(self) -&gt; None</code>","text":"<ul> <li>Records triggered events in the <code>library</code> and updates <code>win_manager</code>.</li> </ul>"},{"location":"math_docs/source_section/state_info/#update_final_winself-none","title":"<code>update_final_win(self) -&gt; None</code>","text":"<ul> <li>Computes and verifies the final win amount across base and free games.</li> <li>Ensures that total wins do not exceed the win cap.</li> <li>Raises an assertion error if the sum of base and free game payouts mismatches the recorded final payout.</li> </ul>"},{"location":"math_docs/source_section/state_info/#check_repeatself-none","title":"<code>check_repeat(self) -&gt; None</code>","text":"<ul> <li>Determines if a spin needs to be repeated based on criteria constraints.</li> </ul>"},{"location":"math_docs/source_section/state_info/#run_spinself-sim-abstract-method","title":"<code>run_spin(self, sim)</code> (Abstract Method)","text":"<ul> <li>Must be implemented in derived classes.</li> <li>Placeholder prints a message if not overridden.</li> </ul>"},{"location":"math_docs/source_section/state_info/#run_freespinself-abstract-method","title":"<code>run_freespin(self)</code> (Abstract Method)","text":"<ul> <li>Must be implemented in derived classes.</li> <li>Placeholder prints a message if not overridden.</li> </ul>"},{"location":"math_docs/source_section/state_info/#run_simsself-betmode_copy_list-betmode-sim_to_criteria-total_threads-total_repeats-num_sims-thread_index-repeat_count-compresstrue-write_event_listtrue-none","title":"<code>run_sims(self, betmode_copy_list, betmode, sim_to_criteria, total_threads, total_repeats, num_sims, thread_index, repeat_count, compress=True, write_event_list=True) -&gt; None</code>","text":"<ul> <li>Runs multiple simulations, setting up bet modes and criteria per simulation.</li> <li>Tracks and prints RTP calculations.</li> <li>Writes temporary JSON files for multi-threaded results.</li> <li>Generates lookup tables for criteria and payout distributions.</li> </ul>"},{"location":"math_docs/source_section/state_info/#summary","title":"Summary","text":"<ul> <li><code>GeneralGameState</code> provides a foundation for defining and managing game states.</li> <li>It includes methods for configuring symbols, handling wins, recording events, and executing game simulations.</li> <li>Certain methods must be overridden in derived classes to customize behavior.</li> </ul>"},{"location":"math_docs/source_section/tumble_info/","title":"Tumble","text":""},{"location":"math_docs/source_section/tumble_info/#tumbling-boards","title":"Tumbling boards","text":"<p>The <code>Tumble</code> class inherits <code>Board</code> and handles removing winning symbols from <code>self.board</code> and filling vacant positions with symbols which appear directly above winning positions using the properties <code>reel_positions</code> and <code>reelstrip_id</code>. Examples of applications surrounding tumbling (cascading) events can be found in the <code>0_0_cluster</code> and <code>0_0_scatter</code> sample games. </p> <p>The win evaluation functions for the cluster and scatter win-types assign the property <code>explode = True</code> to winning symbol objects. A new board is select by scanning the current <code>self.board</code> object reel-by-reel and counting the number of symbols which satisfy <code>sym.check_attribute(\"explode\")</code>. This same number of symbols is then appended, counting backwards from the initial <code>self.reel_positions</code> values. If padding symbols are used, the symbol stored in <code>top_symbols</code> will be used to fill the first vacated position. </p>"},{"location":"math_docs/source_section/ways_info/","title":"Ways wins evaluation","text":"<p>The <code>WaysWins</code> object evaluates winning symbol combinations for the current <code>self.board</code> state. Generally 3 or more consecutive symbols result in a win, though these specific combination numbers and payouts can be defined in:</p> <pre><code>config.paytable = {(kind[int], symbol[string]): payout[float]}\n</code></pre> <p>The ways calculation will search for like-symbols (or Wilds) on consecutive reels. The maximum number of ways is determined from the board size: <code>max_ways = (num_rows)^(num_columns)</code>.  Note: the ways calculation does not account for Wild symbols appearing on the first reel. </p> <p>The Ways evaluation takes also takes into account multiplier values attached to symbols containing the <code>multiplier</code> attribute. Unlike lines calculations where multiplier values are added together for symbols on consecutive reels, the total number of ways is instead multiplied by the multiplier value. Leading to the payout amount to grow substantially more quickly. So for example given the board:</p> <pre><code>L5 H1 L4 L4 L4 \nL1 H4 L3 H2 L4 \nH1 H1 H1 L3 H3 \n</code></pre> <p>If there is a multiplier value of, say 3x on the <code>H1</code> symbol on reel 3, the total ways for symbol <code>H1</code> is <code>(3,H1)</code> pays:</p> <pre><code>(1) * (2) * (3) = 6 ways\n</code></pre> <p>The <code>return_data</code> will include all winning symbol names, number of consecutive like-symbols, winning positions and total win amounts for each unique symbol type. the <code>meta</code> tag will additionally include the total number of ways a symbol wins, which will range from <code>1</code> to <code>(num_rows)^(num_columns)</code> and and additional symbol and/or global multiplier contributions.</p>"},{"location":"math_docs/source_section/win_manager/","title":"Wallet Manger","text":"<p>When a set of simulations are setup and executed through the <code>src/state/run_sims()</code> function, a new instance of the <code>WinManager</code> class is spawned. This class is responsible for tracking <code>basegame</code> and <code>freegame</code> wins for single simulation rounds (when running <code>run_spin()</code>), and also for cumulative win amounts for a given <code>BetMode</code>. </p> <pre><code>class WinManager:\n    def __init__(self, base_game_mode, free_game_mode):\n        self.base_game_mode = base_game_mode\n        self.free_game_mode = free_game_mode\n\n        self.total_cumulative_wins = 0\n        self.cumulative_base_wins = 0\n        self.cumulative_free_wins = 0\n\n        self.running_bet_win = 0.0\n\n        self.basegame_wins = 0.0\n        self.freegame_wins = 0.0\n\n        self.spin_win = 0.0\n        self.tumble_win = 0.0\n</code></pre>"},{"location":"math_docs/source_section/win_manager/#cumulative-wins","title":"Cumulative wins","text":"<p>The cumulative win-amounts are useful in the terminal printouts to quickly check the RTP splits for a given multiprocessing thread. These cumulative values are updated each time a simulation is run and successfully passed, within <code>state.imprint_wins()</code> basegame and freegame win amounts are updated using <code>win_manager.update_end_round_wins()</code>. </p> <p><code>total_cumulative_wins</code> incorporate wins from all game-types on a single betmode level, while <code>cumulative_base_wins</code> and <code>cumulative_free_wins</code> track the cumulative win amounts for the basegame and freegame respectively. </p>"},{"location":"math_docs/source_section/win_manager/#spin-level-wins","title":"Spin-level wins","text":"<p>The <code>running_bet_win</code> tracks wins from the basegame and freegame modes and continuously increases during simulation steps. The final <code>running_bet_win</code> value will equal the payout multiplier <code>basegame_wins</code> and <code>freegame_wins</code>are single simulation level parameters which are reset when <code>run_spin()</code> is called. These values are subsequently used for the <code>lookUpTableSegmented</code> files, which helps to identify the contribution of different game-types to the final payout multiplier. </p> <p>The <code>spin_win</code> property tracks the win for a given <code>reveal</code> event. So for example is reset for each spin within a <code>freegame</code>. Finally the <code>tumble_win</code> property is used for tracking wins where there are consecutive win events within a single reveal, most commonly seen within tumbling/cascading games. We may want to keep track of the cumulative win amount resulting from multiple tumble events to update win-banners or apply multipliers at the end of the sequence. </p>"},{"location":"math_docs/source_section/win_manager/#update-functions","title":"Update functions","text":"<p>There are several <code>WinManager</code> update functions used to update and reset the <code>spin_win</code> and gametype wins. The <code>running_bet_win</code> property does not need to be called explicitly, nor does the <code>cumulative_wins</code> (as this is called when the simulation is accepted and saved). The gametype should be updated explicitly though when the basegame actions have concluded, as well as at the end of each freegame spin (if applicable). This can be seen the sample <code>gamestate.run_spin()</code> game files:</p> <pre><code>self.win_manager.update_gametype_wins(self.gametype)\n</code></pre>"},{"location":"math_docs/uploads_section/upload_info/","title":"Uploads","text":""},{"location":"math_docs/uploads_section/upload_info/#uploading-to-s3","title":"Uploading to S3","text":"<p>Note: This is a temporary/alternate method of uploading math-engine outputs to S3 for storage/testing. Eventually games will be uploaded directly to the RGS via an ACP. In the meantime the <code>upload_to_aws()</code> function to be used in conjunction with the users AWS access and secret keys, imported from a <code>.env</code> file. </p> <p>This function will compare file details stored locally with those provided in the games respective <code>config.json</code> file. The lookup table RTP is verified (unless specifically overridden) before uploading via the <code>AWS boto3</code> client. </p>"},{"location":"math_docs/utils_section/utilities/","title":"Utilities","text":""},{"location":"math_docs/utils_section/utilities/#various-useful-functions","title":"Various useful functions","text":""},{"location":"math_docs/utils_section/utilities/#game-analytics","title":"Game analytics","text":"<p>The <code>run</code> function within <code>run_analysis.py</code> is a helper function for analyzing optimized win-distributions.  Note: This program assumes a specific format for optimized game lookup tables, as generated by the provided optimization algorithm. Additionally, automatic generation of hit-rates and simulation counts assumes the existence of a <code>force_record_&lt;mode&gt;.json</code> file, where wins have been recorded with the keys:</p> <pre><code>'symbol': '&lt;name&gt;',\n'kind' : '&lt;num_symbols_in_win&gt;'\n</code></pre> <p>For example within the <code>Lines</code> class we record wins with the format:</p> <pre><code>def record_line(kind: int, symbol: str, mult: int, gametype: str) -&gt; None:\n    \"\"\"Force file description for line-win.\"\"\"\n    gamestate.record({\"kind\": kind, \"symbol\": symbol, \"mult\": mult, \"gametype\": gametype})\n</code></pre> <p>A <code>.xlsx</code> file is produced detailing the hit-rates, RTP contributions and number of simulations recorded within of pre-defined win-ranges. Assuming that the <code>gametype</code> is recorded, hit-rates for game-types matched to <code>BetMode.criteria</code> inputs. This allows for visualizing if win-ranges are occurring in or out of the feature game. This is particularly useful when setting <code>scale_factor</code> values within the <code>GameOptimization.scaling</code> class. </p> <p>Valid symbol names are extracted from the <code>GameConfig.paytable</code> component. Using recorded <code>kind</code> and <code>symbol</code> elements, hit-rates, simulation counts and average payout multiplier amounts for a given simulation are generated.</p> <p>Custom search keys can be passed to the <code>run()</code> function, providing the hit-rates for specific events within the <code>gamestate.record()</code> function. </p>"},{"location":"math_docs/utils_section/utilities/#analysis","title":"Analysis","text":"<p>Once a lookup table has been optimized it is often useful to analyze the resulting win-distribution, which is a dictionary where the keys are all ordered, unique payouts and the values represent the probability of obtaining this specific payout value.</p>"},{"location":"math_docs/utils_section/utilities/#misc","title":"Misc","text":""},{"location":"math_docs/utils_section/utilities/#swap-lookups","title":"Swap lookups","text":"<p>The optimization algorithm outputs several viable lookup tables with the <code>&lt;game&gt;/library/optimization_files/</code> folder. This file provides functions for swapping out weights in the  <code>&lt;game&gt;/library/lookup_tables/lookUpTable_&lt;mode&gt;_0.csv</code> file/.</p>"},{"location":"math_docs/utils_section/utilities/#get-file-hash","title":"Get file hash","text":"<p>Helper functions for printing the SHA256 values of a single file or all non-python files within a directory to console. These values can be compared with SHA values with <code>config.json</code> files to check if file contents have been altered.</p>"},{"location":"rgs_docs/RGS/","title":"RGS Endpoints","text":"<p>This specification outlines the API endpoints available to providers for communicating with the Stake Engine. These APIs enable key operations such as creating bets, completing bets, validating sessions, and retrieving player balances.</p>"},{"location":"rgs_docs/RGS/#introduction","title":"Introduction","text":"<p>This document defines how the provider\u2019s frontend communicates with the Stake Engine endpoints. It includes a detailed description of the core API functionality, along with the corresponding request and response structures.</p>"},{"location":"rgs_docs/RGS/#url-structure","title":"URL Structure","text":"<p>Games are hosted under a predefined URL. Providers should use the parameters below to interact with the RGS on behalf of the user and correctly display game information.</p> <pre><code>https://{{.TeamName}}.cdn.stake-engine.com/{{.GameID}}/{{.GameVersion}}/index.html?sessionID={{.SessionID}}&amp;lang={{.Lang}}&amp;device={{.Device}}&amp;rgs_url={{.RgsUrl}}\n</code></pre>"},{"location":"rgs_docs/RGS/#query-params-in-url","title":"Query Params in URL","text":"Field Description sessionID Unique session ID for the player. Required for all requests made by the game. lang Language in which the game will be displayed. device Specifies 'mobile' or 'desktop'. rgs_url The URL used for authentication, placing bets, and completing rounds. This URL should not be hardcoded, as it may change dynamically."},{"location":"rgs_docs/RGS/#language","title":"Language","text":"<p>The <code>lang</code> parameter should be an ISO 639-1 language code.</p> <p>Supported languages:</p> <ul> <li><code>ar</code> (Arabic)</li> <li><code>de</code> (German)</li> <li><code>en</code> (English)</li> <li><code>es</code> (Spanish)</li> <li><code>fi</code> (Finnish)</li> <li><code>fr</code> (French)</li> <li><code>hi</code> (Hindi)</li> <li><code>id</code> (Indonesian)</li> <li><code>ja</code> (Japanese)</li> <li><code>ko</code> (Korean)</li> <li><code>pl</code> (Polish)</li> <li><code>pt</code> (Portuguese)</li> <li><code>ru</code> (Russian)</li> <li><code>tr</code> (Turkish)</li> <li><code>vi</code> (Vietnamese)</li> <li><code>zh</code> (Chinese)</li> </ul>"},{"location":"rgs_docs/RGS/#understanding-money","title":"Understanding Money","text":"<p>Monetary values in the Stake Engine are integers with six decimal places of precision:</p> Value Actual Amount 100,000 0.1 1,000,000 1 10,000,000 10 100,000,000 100 <p>For example, to place a $1 bet, pass <code>\"1000000\"</code> as the amount.</p> <p>Currency impacts only the display layer; it does not affect gameplay logic.</p>"},{"location":"rgs_docs/RGS/#supported-currencies","title":"Supported Currencies","text":"<ul> <li>USD (United States Dollar)</li> <li>CAD (Canadian Dollar)</li> <li>JPY (Japanese Yen)</li> <li>EUR (Euro)</li> <li>RUB (Russian Ruble)</li> <li>CNY (Chinese Yuan)</li> <li>PHP (Philippine Peso)</li> <li>INR (Indian Rupee)</li> <li>IDR (Indonesian Rupiah)</li> <li>KRW (South Korean Won)</li> <li>BRL (Brazilian Real)</li> <li>MXN (Mexican Peso)</li> <li>DKK (Danish Krone)</li> <li>PLN (Polish Z\u0142oty)</li> <li>VND (Vietnamese \u0110\u1ed3ng)</li> <li>TRY (Turkish Lira)</li> <li>CLP (Chilean Peso)</li> <li>ARS (Argentine Peso)</li> <li>PEN (Peruvian Sol)</li> </ul>"},{"location":"rgs_docs/RGS/#social-casino-currencies","title":"Social Casino Currencies","text":"<ul> <li>XGC (Gold)</li> <li>XSC (Stake Cash)</li> </ul>"},{"location":"rgs_docs/RGS/#bet-levels","title":"Bet Levels","text":"<p>Although bet levels are not mandatory, bets must satisfy these conditions:</p> <ol> <li>The bet must fall between <code>minBet</code> and <code>maxBet</code> (returned from <code>/wallet/authenticate</code>).</li> <li>The bet must be divisible by <code>stepBet</code>.</li> </ol> <p>It is recommended to use the predefined <code>betLevels</code> to guide players.</p> <p>Example:</p> <pre><code>{\n  \"minBet\": 100000,\n  \"maxBet\": 1000000000,\n  \"stepBet\": 10000,\n  \"betLevels\": [\n    100000, // $0.10\n    200000,\n    400000,\n    600000,\n    ...\n    1000000000 // $1000\n  ]\n}\n</code></pre>"},{"location":"rgs_docs/RGS/#bet-modes-cost-multipliers","title":"Bet Modes / Cost Multipliers","text":"<p>Games may have multiple bet modes defined in the game configuration. Refer to the Math SDK Documentation.</p> <p>When making a play request:</p> <pre><code>Player debit amount = Base bet amount \u00d7 Bet mode cost multiplier\n</code></pre>"},{"location":"rgs_docs/RGS/#wallet","title":"Wallet","text":"<p>The wallet endpoints enable interactions between the RGS and the Operator's Wallet API, managing the player's session and balance operations.</p>"},{"location":"rgs_docs/RGS/#authenticate-request","title":"Authenticate Request","text":"<p>Validates a <code>sessionID</code> with the operator. This must be called before using other wallet endpoints. Otherwise, they will throw <code>ERR_IS</code> (invalid session).</p>"},{"location":"rgs_docs/RGS/#round","title":"Round","text":"<p>The <code>round</code> returned may represent a currently active or the last completed round. Frontends should continue the round if it remains active.</p>"},{"location":"rgs_docs/RGS/#request","title":"Request","text":"<pre><code>POST /wallet/authenticate\n</code></pre> <pre><code>{\n  \"sessionID\": \"xxxxxxx\",\n}\n</code></pre>"},{"location":"rgs_docs/RGS/#response","title":"Response","text":"<pre><code>{\n  \"balance\": {\n    \"amount\": 100000,\n    \"currency\": \"USD\"\n  },\n  \"config\": {\n    \"minBet\": 100000,\n    \"maxBet\": 1000000000,\n    \"stepBet\": 100000,\n    \"defaultBetLevel\": 1000000,\n    \"betLevels\": [...],\n    \"jurisdiction\": {\n      \"socialCasino\": false,\n      \"disabledFullscreen\": false,\n      \"disabledTurbo\": false,\n      ...\n    }\n  },\n  \"round\": { ... }\n}\n</code></pre>"},{"location":"rgs_docs/RGS/#balance-request","title":"Balance Request","text":"<p>Retrieves the player\u2019s current balance. Useful for periodic balance updates.</p>"},{"location":"rgs_docs/RGS/#request_1","title":"Request","text":"<pre><code>POST /wallet/balance\n</code></pre> <pre><code>{\n  \"sessionID\": \"xxxxxx\"\n}\n</code></pre>"},{"location":"rgs_docs/RGS/#response_1","title":"Response","text":"<pre><code>{\n  \"balance\": {\n    \"amount\": 100000,\n    \"currency\": \"USD\"\n  }\n}\n</code></pre>"},{"location":"rgs_docs/RGS/#play-request","title":"Play Request","text":"<p>Initiates a game round and debits the bet amount from the player's balance.</p>"},{"location":"rgs_docs/RGS/#request_2","title":"Request","text":"<pre><code>{\n  \"amount\": 100000,\n  \"sessionID\": \"xxxxxxx\",\n  \"mode\": \"BASE\"\n}\n</code></pre>"},{"location":"rgs_docs/RGS/#response_2","title":"Response","text":"<pre><code>{\n  \"balance\": {\n    \"amount\": 100000,\n    \"currency\": \"USD\"\n  },\n  \"round\": { ... }\n}\n</code></pre>"},{"location":"rgs_docs/RGS/#end-round-request","title":"End Round Request","text":"<p>Completes a round, triggering a payout and ending all activity for that round.</p>"},{"location":"rgs_docs/RGS/#request_3","title":"Request","text":"<pre><code>POST /wallet/endround\n</code></pre> <pre><code>{\n  \"sessionID\": \"xxxxxx\"\n}\n</code></pre>"},{"location":"rgs_docs/RGS/#response_3","title":"Response","text":"<pre><code>{\n  \"balance\": {\n    \"amount\": 100000,\n    \"currency\": \"USD\"\n  }\n}\n</code></pre>"},{"location":"rgs_docs/RGS/#game-play","title":"Game Play","text":""},{"location":"rgs_docs/RGS/#event","title":"Event","text":"<p>Tracks in-progress player actions during a round. Useful for resuming gameplay if a player disconnects.</p>"},{"location":"rgs_docs/RGS/#request_4","title":"Request","text":"<pre><code>POST /bet/event\n</code></pre> <pre><code>{\n  \"sessionID\": \"xxxxxx\",\n  \"event\": \"xxxxxx\"\n}\n</code></pre>"},{"location":"rgs_docs/RGS/#response_4","title":"Response","text":"<pre><code>{\n  \"event\": \"xxxxxx\"\n}\n</code></pre>"},{"location":"rgs_docs/RGS/#response-codes","title":"Response Codes","text":"<p>Stake Engine uses standard HTTP response codes (200, 400, 500) with specific error codes.</p>"},{"location":"rgs_docs/RGS/#400-client-errors","title":"400 \u2013 Client Errors","text":"Status Code Description ERR_VAL Invalid Request ERR_IPB Insufficient Player Balance ERR_IS Invalid Session Token / Session Timeout ERR_ATE Failed User Authentication / Token Expired ERR_GLE Gambling Limits Exceeded ERR_LOC Invalid Player Location"},{"location":"rgs_docs/RGS/#500-server-errors","title":"500 \u2013 Server Errors","text":"Status Code Description ERR_GEN General Server Error ERR_MAINTENANCE RGS Under Planned Maintenance"},{"location":"rgs_docs/RGS/#math-publication-file-formats","title":"Math Publication File Formats","text":"<p>When publishing math results, ensure that the file-format is abided by. These are strict conditions for successful math file publication. </p>"},{"location":"rgs_docs/data_format/","title":"Math verification","text":"<p>When uploading static math files to the RGS, Stake Engine will carry out preliminary checks to ensure ensure game-logic is of the expected format. The corresponding payout multipliers and probabilities are analyzed as a means of providing a quick summary of game statistics on the backend.</p>"},{"location":"rgs_docs/data_format/#minimum-file-requirements","title":"Minimum file requirements","text":"<p>For a game with one game-mode, there will be 3 files required for the Math to be published successfully.</p> <ul> <li>Index file (must be called *index.json and contain the mode name, cost multiplier and logic/CSV filenames)</li> <li>Lookup table (CSV file, with each line containing ID, Probability, Payout)</li> <li>Game logic (zStandard compressed JSON-lines (__.jsonl.zst))</li> </ul>"},{"location":"rgs_docs/data_format/#index-file-format","title":"Index file format","text":"<p>When selecting a directory to upload from for the Stake Engine math there must exist a JSON-encoded file called index.json with the strictly enforced form:</p> <pre><code>{\n    \"modes\": [\n        {\n            \"name\": &lt;string&gt;,\n            \"cost\": &lt;float&gt;,\n            \"events\": &lt;string&gt;\"&lt;logic_file&gt;.jsonl.zst\",\n            \"weights\": &lt;string&gt;\"&lt;lookup_table&gt;.csv\"\n        },\n        ...\n    ]\n}\n</code></pre> <p>For example, for a game with 2-modes:</p> <pre><code>{\n    \"modes\": [\n        {\n            \"name\": \"base\",\n            \"cost\": 1.0,\n            \"events\": \"books_base.jsonl.zst\",\n            \"weights\": \"lookUpTable_base_0.csv\"\n        },\n        {\n            \"name\": \"bonus\",\n            \"cost\": 100.0,\n            \"events\": \"books_bonus.jsonl.zst\",\n            \"weights\": \"lookUpTable_bonus_0.csv\"\n        }\n    ]\n}\n</code></pre>"},{"location":"rgs_docs/data_format/#csv-format","title":"CSV format","text":"<p>When calculating various statistical values on the RGS side, it is much more efficient and robust to work with unsigned integer values (since no payouts or probabilities will ever be negative). This avoids misinterpreting values due to rounding or floating-point errors. For every game-round uploded within the game-logic there must a summary CSV table containing rows of <code>uint64</code> values. We require the payoutMuliplier value in the third column to exactly match those provided in the game-logic file. There values are extracted and hashed to ensure identical <code>payoutMultiplier</code> values. </p> <pre><code>    simulation number, round probability, payout multiplier\n</code></pre> <p>For example:</p> <pre><code>1,199895486317,0\n2,25668581149,20\n3,126752606,140\n...\n</code></pre>"},{"location":"rgs_docs/data_format/#game-logic-format","title":"Game logic format","text":"<p>Round information returned through the /play API corresponds to a single simulation outcome returned in JSON format. For efficiency, we require this data to be stored in compressed .jsonl format. Currently zStandard (.zst) encoding must be used, though this will be expanded upon in the near future. In order to identify simulation IDs, payouts and logic we enforce the condition that every simulation contains the key fields:</p> <pre><code>    \"id\": &lt;int&gt;,\n    \"events\" &lt;list&lt;dict&gt;&gt;,\n    \"payoutMultiplier\": &lt;int&gt;\n</code></pre> <p>For example, at a minimum the game round, printed to jsonl before compression will have the format:</p> <pre><code>{\n    \"id\": 1, \n    \"events\": [{}, ...],\n    \"payoutMultiplier\": 1150\n}\n</code></pre> <p>Where the payoutMultiplier value corresponds to an 11.5x payout for a base game round (costing 1.0x). The three JSON key fields: id, events, payoutMultipler are required for every round returned. </p>"},{"location":"simple_example/simple_example/","title":"Getting Started with RGS Responses","text":"<p>This brief tutorial is intended to get you up and running with the RGS using a simple game called fifty-fifty. </p>"},{"location":"simple_example/simple_example/#game-overview","title":"Game Overview","text":"<p>The rules are straightforward: - You request a response from the RGS\u2019s <code>/play</code> API. - You have a 50/50 chance of either:</p> <ul> <li>2x your bet back</li> <li>Losing your 1x bet.</li> </ul> <p>Your balance is displayed alongside the outcome of the previously completed round. The JSON response for each round is shown on the right-hand side of the screen.</p> <p>If your win is greater than 0, you\u2019ll need to manually call the <code>/end-round</code> API to finalize the bet\u2014just like in a custom frontend implementation.</p> <p>For more information, see RGS Technical Details</p>"},{"location":"simple_example/simple_example/#simple-math-results","title":"Simple Math Results","text":"<p>Navigate to the <code>math-sdk/games/fifty_fifty/</code> directory and execute the <code>run.py</code> script. This will generate:</p> <ul> <li>A Zstandard-compressed set of simulation results</li> <li>A lookup table matching each result to its simulation</li> <li>The required <code>index.json</code> file</li> </ul> <p>All necessary files to publish the game to the Stake Engine will be placed in <code>library/publish_files/</code>.</p>"},{"location":"simple_example/simple_example/#simple-frontend-implementation","title":"Simple Frontend Implementation","text":"<p>We\u2019ll use Svelte 5 bundled with Vite to create a static frontend. We'll initialize the project using Node Package Manager (NPM) and optionally Node Version Manager (NVM).</p> <p>Note: This guide assumes you are using NPM version <code>v22.16.0</code>.</p>"},{"location":"simple_example/simple_example/#setup-steps","title":"Setup Steps","text":"<ol> <li> <p>Create the Vite project:     <code>npm create vite@latest</code></p> </li> <li> <p>Edit the <code>vite.config.ts</code> file:     Make sure the defineConfig function includes: <code>base: \"./\"</code> (under plugins),</p> </li> <li> <p>Replace styles and main component:</p> <ul> <li>Copy the contents of <code>css.txt</code> into your generated <code>app.css</code></li> <li>Replace the contents of <code>app_svelte.txt</code> into: <code>src/App.svelte</code></li> </ul> </li> <li> <p>Build the project:     <code>yarn build</code></p> </li> <li> <p>Deploy:</p> <ul> <li>Upload the contents of the <code>dist/</code> folder to the Stake Engine under frontend files</li> </ul> </li> </ol>"},{"location":"simple_example/simple_example/#what-this-frontend-does","title":"What This Frontend Does","text":"<p>This simple Svelte app will:</p> <ul> <li>Authenticate your session with the RGS</li> <li>Request a response from the <code>/play</code> API</li> <li>(If applicable) Call the <code>/end-round</code> API to finalize a win</li> </ul> <p>Once the math/frontend files have been uploaded to Stake Engine, launcing the game should result in the following:</p> <p></p> <p>Pressing Place BET will populate the play/ response field with the RGS game round structure.  If the round-win is &gt;0, press END ROUND to finalise the bet, which will subsequently update your balance and close the bet.</p>"}]}