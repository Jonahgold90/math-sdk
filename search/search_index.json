{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Carrot Math Engine","text":""},{"location":"#powered-by-carrotrgs","title":"Powered by CarrotRGS","text":"<p>Welcome to the Carrot-Math-Engine!</p> <p>This engine provides a framework for creating and optimizing slot games, and outputs all files in a format agreeable to the Carrot RGS. This engine is used to define game rules, implement game logic, optimize win-distributions, generate compressed simulation results and perform statistical analysis on custom-defined events. By using a discrete set of outcomes, we can enforce strict control on game mechanics and hit-rates, without the need to explicitly solve potentially complex mathematical models.</p>"},{"location":"#directory-structure","title":"Directory Structure","text":"<pre><code>src/ \n    calculations/ # Board and Symbol setup, various win-type game logic\n    config/ # Creates configuration files required by the RGS, frontend and optimization algorithm\n    events/ # Data structures passed between math-engine and frontend engine\n    executables/ # Commonly used groupings of game logic and events\n    state/ # Tracks the game-state of all simulations \n    wins/ # Wallet manager handling various win-criteria\n    write_data/ # Handles writing simulation data, compression and force-files\n\ngames/\n    0_0_cluster # Sample cascading cluster-wins game\n    0_0_lines # Basic win-lines example game\n    0_0_ways # Basic ways-wins example game\n    0_0_scatter # Pay-anywhere cascading example game\n    0_0_expwilds # Example of expanding Wild-reel game, with prize-collection feature game\n\ntests/ # [**TBC**] Test cases for various win-types\nutils/ # [**TBC**] Useful functions to aid with file and game analysis\nuploads/ # [**TBC**] Data transformation and upload verification\noptimization/ # [**TBC**] Optimization algorithm\ndocs/ # Markdown files\n</code></pre>"},{"location":"general_overview/","title":"Setup and installation","text":""},{"location":"general_overview/#installing-the-carrot-mathengine","title":"Installing the Carrot MathEngine","text":"<p>This guide details the recommended process for installing the Carrot-MathEngine and all required packages using the setuptools standard package.</p>"},{"location":"general_overview/#step-1-create-and-activate-a-virtual-environment","title":"Step 1: Create and Activate a Virtual Environment","text":"<p>It's recommended to use a virtual environment to manage dependencies. Using the Virtual Environment manager (venv), install Python version &gt;=3.12 using:</p> <pre><code>python3.12 -m venv env\n</code></pre> <p>Activate the virtual environment:</p> <ul> <li>Windows:   <code>sh   venv \\\\scripts \\\\activate</code></li> <li>macOS/Linux:   <code>sh   source env/bin/activate</code></li> </ul>"},{"location":"general_overview/#step-2-install-dependencies","title":"Step 2: Install Dependencies","text":"<p>Use <code>pip</code> to install dependencies from the <code>requirements.txt</code> file:</p> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"general_overview/#step-3-install-the-package-in-editable-mode","title":"Step 3: Install the Package in Editable Mode","text":"<p>Using the <code>setup.py</code> file, the package should be installed it in editable mode (for development purposes) with the command:</p> <pre><code>pip install -e .\n</code></pre> <p>This allows modifications to the package source code to take effect without reinstallation. </p>"},{"location":"general_overview/#step-4-verify-installation","title":"Step 4: Verify Installation","text":"<p>You can check that the package is installed by running:</p> <pre><code>pip list\n</code></pre> <p>or testing the package import in Python:</p> <pre><code>python\n&gt;&gt;&gt; import your_package_name\n</code></pre>"},{"location":"general_overview/#deactivating-the-virtual-environment","title":"Deactivating the Virtual Environment","text":"<p>When finished, deactivate the virtual environment with:</p> <pre><code>deactivate\n</code></pre>"},{"location":"general_overview/#installing-cargo","title":"Installing Cargo","text":"<p>If the optimization algorithm is being utilized, Rust and Cargo should be installed. </p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre>"},{"location":"fe_assets/fe_readme/","title":"Carrot Game SDK","text":"<p>This is a web game engine powered by Svelte 5, PixiJS 8 and TurboRepo.</p>"},{"location":"fe_assets/fe_readme/#dependencies","title":"Dependencies","text":"<p>Besides basic web skills (html, css and javascript), here it shows a list of npm dependencies of this repo. It would be great to start with understanding them before kicking off Get Started.</p> <ul> <li>pixijs: https://www.npmjs.com/package/pixi.js and more...</li> <li>svelte: https://www.npmjs.com/package/svelte and more...</li> <li>turborepo: https://www.npmjs.com/package/turbo and more...</li> <li>pixi-svelte: https://www.npmjs.com/package/pixi-svelte and more...</li> <li>This is an in-house package. It combines pixi and svelte together and uses pixijs in a declarative way.</li> <li>sveltekit: https://www.npmjs.com/package/@sveltejs/kit and more...</li> <li>storybook: https://www.npmjs.com/package/storybook and more...</li> <li>xstate: https://www.npmjs.com/package/xstate and more...</li> <li>typescript: https://www.npmjs.com/package/typescript and more...</li> <li>pnpm: https://www.npmjs.com/package/pnpm and more...</li> </ul>"},{"location":"fe_assets/fe_readme/#get-started","title":"Get started","text":"<p>Here is a complete tutorial to start our sample games in the storybook. Please ignore those steps that you already know or done.</p> <ul> <li>It is preferred to use VS Code as IDE. download</li> <li>Install node with version 18.18.0. download</li> </ul> <pre><code># Download and install nvm:\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash\n\n# in lieu of restarting the shell\n\\. \"$HOME/.nvm/nvm.sh\"\n\n# Download and install Node.js:\nnvm install 18.18.0\n\n# Verify the node versions. Should print \"v18.18.0\".\nnode -v\n</code></pre> <ul> <li>Install pnpm with version 10.5.0.</li> </ul> <pre><code># Install pnpm\nnpm install pnpm@10.5.0 -g\n\n# Verify the pnpm versions. Should print \"v10.5.0\"\npnpm -v\n</code></pre> <ul> <li>Clone the repo to your local in VS Code terminal or others.</li> </ul> <pre><code>git clone https://github.com/twist-gaming/carrot-game-sdk.git\ncd carrot-game-sdk\n</code></pre> <ul> <li>Install dependencies.</li> </ul> <pre><code>pnpm install\n</code></pre> <ul> <li>Run <code>pnpm run storybook --filter=&lt;MODULE_NAME&gt;</code> to storybook of a sample game in a turborepo way. <code>&lt;MODULE_NAME&gt;</code> is the name in the package.json file of a module in apps and packages folders. For example, we have <code>\"name\": \"lines\"</code> in the apps/lines/package.json, so we can find it and run its storybook by:</li> </ul> <pre><code>pnpm run storybook --filter=lines\n</code></pre> <ul> <li>You should see this:</li> </ul> <p></p>"},{"location":"fe_assets/fe_readme/#_1","title":"Frontend Documentation","text":"<ul> <li>Now switch to MODE_BASE/book/random in the left sidebar, you will see an <code>Action</code> button appear on the left right conner of the game.</li> </ul>"},{"location":"fe_assets/fe_readme/#_2","title":"Frontend Documentation","text":"<ul> <li>Click on the <code>Action</code> button and wait for a base game to finish.</li> <li>Congratulations! You are now in the zone of game development with us.</li> </ul>"},{"location":"fe_assets/fe_readme/#explore-storybook","title":"Explore Storybook","text":"<p>Storybook is a powerful and handy tool to test your games. For example:</p> <ul> <li><code>MODE_BASE/book/random</code>: It tests the  component with a random book of base mode.</li> <li><code>MODE_BASE/bookEvent/reveal</code>: It tests the  component with a \"reveal\" bookEvent of the base mode. It will spin the reels.</li> <li><code>MODE_BONUS/book/random</code>: It tests the  component with a random book of bonus mode.</li> <li><code>MODE_BONUS/bookEvent/reveal</code>: It tests the  component with a \"reveal\" bookEvent of the bonus mode. It will spin the reels.</li> <li>...</li> <li><code>COMPONENTS/&lt;GAME&gt;/component</code>: It tests the  component. In this case, it doesn't skip the loading screen.</li> <li><code>COMPONENTS/&lt;GAME&gt;/preSpin</code>: It tests the  component with the preSpin function.</li> <li><code>COMPONENTS/&lt;GAME&gt;/emitterEvent</code>: It tests the  component with an emitterEvent \"boardHide\".</li> <li>...</li> <li><code>COMPONENTS/&lt;Symbol&gt;/component</code>: It tests the  component with controls e.g. state of the symbol.</li> <li><code>COMPONENTS/&lt;Symbol&gt;/symbols</code>: It tests the  component with all the symbols and all the states.</li> </ul> <p> </p>"},{"location":"fe_assets/fe_readme/#_3","title":"Frontend Documentation","text":"<p>With all the above stories and the stories you create and customise by yourself, it is able to test the game as a whole, intermediate components or atomic components. It is also able to test your game with a book, a sequence of bookEvents or a single bookEvent. If each bookEvent is implemented well with emitterEvents and its story is resolved properly, the game is almost finished.</p>"},{"location":"fe_assets/fe_readme/#flow-chart","title":"Flow Chart","text":"<p>Here it is a simplified flow chart of steps how a game is processed after RGS request. The real situation might be more complicated, but it follows the same idea.</p> <p></p> <ul> <li> <p><code>playBookEvents()</code>: This is a function that's created by <code>createPlayBookUtils()</code> from <code>packages/utils-book</code>. What it does is to go through bookEvents one by one, handle each with async function (<code>playBookEvent()</code>) and resolve them one after another (<code>sequence()</code>) with the order of the bookEvents array.</p> </li> <li> <p>That means the order of bookEvents matters and it determines the order of the game. For example, we don't wanna see the \"win\" before \"spin\", so we should put \"win\" after the \"spin\". This function is also used in the <code>MODE_XXX/book/random</code> stories.</p> </li> <li> <p><code>sequence()</code>: This is an in-house async function to achieve resolving async functions/promises one after another. On the contrast, <code>Promise.all()</code> will trigger all the async functions/promises together at the same time, which is not what we desire for the sequence of the game.</p> </li> <li> <p><code>playBookEvent()</code>: This is a function that takes in a bookEvent with some context (usually all the bookEvents), then find the bookEventHandler in bookEventHandlerMap based on <code>bookEvent.type</code> to process it. This function is also used in the <code>MODE_XXX/bookEvent/xxx</code> stories.</p> </li> </ul> <pre><code>const playBookEvents = async (\n  bookEvents: TBookEvent[],\n  bookEventContext?: BookEventContextFromMapWithoutBookEvents,\n) =&gt; {\n  const finalBookEventContext =\n    bookEventContext || ({} as BookEventContextFromMapWithoutBookEvents);\n\n  await sequence(bookEvents, async (bookEvent) =&gt; {\n    await playBookEvent(bookEvent, { ...finalBookEventContext, bookEvents });\n  });\n};\n</code></pre>"},{"location":"fe_assets/fe_readme/#bookevent","title":"BookEvent","text":"<ul> <li><code>Book</code>: A book is a json data that is returned from the RGS (Remote Game Server) for each game requested. It is randomly picked from over a million of books, which we call it math.</li> </ul> <pre><code>// Example of a base game book\n{\n  id: 1,\n  payoutMultiplier: 0.0,\n  events: [\n    {\n      index: 0,\n      type: 'reveal',\n      board: [\n        [{ name: 'L2' }, { name: 'L1' }, { name: 'L4' }, { name: 'H2' }, { name: 'L1' }],\n        [{ name: 'H1' }, { name: 'L5' }, { name: 'L2' }, { name: 'H3' }, { name: 'L4' }],\n        [{ name: 'L3' }, { name: 'L5' }, { name: 'L3' }, { name: 'H4' }, { name: 'L4' }],\n        [{ name: 'H4' }, { name: 'H3' }, { name: 'L4' }, { name: 'L5' }, { name: 'L1' }],\n        [{ name: 'H3' }, { name: 'L3' }, { name: 'L3' }, { name: 'H1' }, { name: 'H1' }],\n      ],\n      paddingPositions: [216, 205, 195, 16, 65],\n      gameType: 'basegame',\n      anticipation: [0, 0, 0, 0, 0],\n    },\n    { index: 1, type: 'setTotalWin', amount: 0 },\n    { index: 2, type: 'finalWin', amount: 0 },\n  ],\n  criteria: '0',\n  baseGameWins: 0.0,\n  freeGameWins: 0.0,\n}\n</code></pre> <ul> <li><code>BookEvent</code>: A bookEvent is a json data that is one of the element of the <code>book.events</code> array.</li> </ul> <pre><code>// Example of a \"reveal\" bookEvent\n{\n  index: 0,\n  type: 'reveal',\n  board: [\n    [{ name: 'L2' }, { name: 'L1' }, { name: 'L4' }, { name: 'H2' }, { name: 'L1' }],\n    [{ name: 'H1' }, { name: 'L5' }, { name: 'L2' }, { name: 'H3' }, { name: 'L4' }],\n    [{ name: 'L3' }, { name: 'L5' }, { name: 'L3' }, { name: 'H4' }, { name: 'L4' }],\n    [{ name: 'H4' }, { name: 'H3' }, { name: 'L4' }, { name: 'L5' }, { name: 'L1' }],\n    [{ name: 'H3' }, { name: 'L3' }, { name: 'L3' }, { name: 'H1' }, { name: 'H1' }],\n  ],\n  paddingPositions: [216, 205, 195, 16, 65],\n  gameType: 'basegame',\n  anticipation: [0, 0, 0, 0, 0],\n}\n\n// Example of a setTotalWin bookEvent\n{ index: 1, type: 'setTotalWin', amount: 0 },\n</code></pre> <ul> <li> <p><code>BookEventHandler</code>: An async function that takes in a bookEvent and do some operations with it. Usually it broadcasts some emitterEvents, so the components will handle.</p> </li> <li> <p><code>bookEventHandlerMap</code>: An object that the key is <code>bookEvent.type</code> and value is a bookEventHandler. We can find this big-boy object in <code>src/game/bookEventHandlerMap.ts</code>.</p> </li> </ul> <pre><code>// Example of \"updateFreeSpin\" bookEventHandler\nexport const bookEventHandlerMap: BookEventHandlerMap&lt;BookEvent, BookEventContext&gt; = {\n  ...,\n  updateFreeSpin: async (bookEvent: BookEventOfType&lt;'updateFreeSpin'&gt;) =&gt; {\n    stateApp.eventEmitter.next({ type: 'freeSpinCounterShow' });\n    stateApp.eventEmitter.next({\n      type: 'freeSpinCounterUpdate',\n      current: bookEvent.amount,\n      total: bookEvent.total,\n    });\n  },\n  ...,\n}\n</code></pre> <ul> <li>In simple terms, a book is composed by multiple bookEvents. Different combinations of bookEvents will determine the different behaviours of a game e.g. win/lose, a big/small win, a base/bonus game, 1/10/15 spins and so on.</li> </ul>"},{"location":"fe_assets/fe_readme/#emitterevent","title":"EmitterEvent","text":"<ul> <li><code>EmitterEvent</code>: An emitterEvent is a json data that <code>stateApp.eventEmitter.next(emitterEvent)</code> or <code>stateApp.eventEmitter.asyncNext(emitterEvent)</code> broadcasts, so that a component which has <code>stateApp.eventEmitter.registerOnMount(emitterEventHandlerMap)</code> can receive the data and deal with it in a synchronous or asynchronous way. For a game we have many animations, so sometimes we need to \"await\" for those animations to finish before going to the next step.</li> </ul> <pre><code>// Example of an emitterEvent\n{\n  type: 'freeSpinCounterUpdate',\n  current: undefined,\n  total: bookEvent.totalFs,\n}\n</code></pre> <ul> <li><code>EmitterEventHandler (Synchronous)</code>: A sync function that takes in an emitterEvent. It usually deal with some sync operations e.g. show/hide component, tidy up, update some numbers and so on.</li> </ul> <pre><code>// Example of broadcasting\nstateApp.eventEmitter.next({\n  type: 'freeSpinCounterUpdate',\n  current: undefined,\n  total: bookEvent.totalFs,\n});\n\n// Example of receiving\ncontext.stateApp.eventEmitter.registerOnMount({\n  // emitterEventHandlerMap\n  ...,\n  freeSpinCounterUpdate: (emitterEvent) =&gt; {\n    if (emitterEvent.current !== undefined) current = emitterEvent.current;\n    if (emitterEvent.total !== undefined) total = emitterEvent.total;\n  },\n  ...,\n});\n</code></pre> <ul> <li><code>EmitterEventHandler (Asynchronous)</code>: An async function that takes in an emitterEvent. It usually deal with some async operations e.g. wait for fading in/out component, wait for animations to finish, wait for numbers to increase/decrease with Tween and so on.</li> </ul> <pre><code>// Example of broadcasting\nawait stateApp.eventEmitter.asyncNext({\n  type: 'freeSpinIntroUpdate',\n  totalFreeSpins: bookEvent.totalFs,\n});\n\n// Example of receiving\ncontext.stateApp.eventEmitter.registerOnMount({\n  // emitterEventHandlerMap\n  ...,\n  freeSpinIntroUpdate: async (emitterEvent) =&gt; {\n    freeSpinsFromEvent = emitterEvent.totalFreeSpins;\n    await waitForResolve((resolve) =&gt; (oncomplete = resolve)); // Wait for an animation to finish.\n  },\n  ...,\n});\n</code></pre> <ul> <li><code>emitterEventHandlerMap</code>: An object that the key is <code>emitterEvent.type</code> and value is an emitterEventHandler. We can find this object in each component. For example, <code>src/components/FreeSpinCounter.svelte</code>.</li> <li>Each emitterEventHandler can do a lot or a little, but we prefer each emitterEventHandler just doing a minimum job to achieve the duty that's described by its name. This way we follow the single responsibility principle of SOLID. For example, <code>freeSpinCounterShow</code> just shows this component and does nothing more.</li> </ul> <pre><code>// Example of FreeSpinCounter.svelte and its emitterEventHandlers\n&lt;script lang=\"ts\" module&gt;\n  export type FreeSpinCounterEmitterEvent =\n    | { type: 'freeSpinCounterShow' }\n    | { type: 'freeSpinCounterHide' }\n    | { type: 'freeSpinCounterUpdate'; current?: number; total?: number };\n&lt;/script&gt;\n\n&lt;script lang=\"ts\"&gt;\n  ...\n\n  context.stateApp.eventEmitter.registerOnMount({\n    // emitterEventHandlerMap\n    freeSpinCounterShow: () =&gt; (show = true),\n    freeSpinCounterHide: () =&gt; (show = false),\n    freeSpinCounterUpdate: (emitterEvent) =&gt; {\n      if (emitterEvent.current !== undefined) current = emitterEvent.current;\n      if (emitterEvent.total !== undefined) total = emitterEvent.total;\n    },\n  });\n&lt;/script&gt;\n\n&lt;MainContainer&gt;\n  ...\n&lt;/MainContainer&gt;\n</code></pre>"},{"location":"fe_assets/fe_readme/#task-breakdown","title":"Task Breakdown","text":"<ul> <li>If an emitterEventHandler does too much work, then it's better we consider to split it into smaller emitterEventHandlers as a process of task-breakdown. For example, \"tumbleBoard\" bookEvent is a fairly complicated bookEvent. Instead of having one \"tumbleBoard\" emitterEvent, we split it into \"tumbleBoardInit\", \"tumbleBoardExplode\", \"tumbleBoardRemoveExploded\", \"tumbleBoardSlideDown\". This way we can implement a complicated emitterEvent step by step and more importantly, we can test the implementations one by one in storybook.</li> </ul> <pre><code>// Example of TumbleBoard.svelte and task-breakdown\ncontext.stateApp.eventEmitter.registerOnMount({\n  // emitterEventHandlerMap\n  tumbleBoardShow: () =&gt; {},\n  tumbleBoardHide: () =&gt; {},\n  tumbleBoardInit: () =&gt; {},\n  tumbleBoardReset: () =&gt; {},\n  tumbleBoardExplode: () =&gt; {},\n  tumbleBoardRemoveExploded: () =&gt; {},\n  tumbleBoardSlideDown: () =&gt; {},\n});\n</code></pre> <ul> <li>Now it's easy to tell that, there's one single idea that's been applied across the whole carrot-game-sdk which is <code>Task Breakdown</code>. Stateless games can be complicated with different types of spins, number of spins, win rules, number of bookEvents, game modes, global multiplier, multiplier symbols and so on. However with the data structure of math and the in-house functions we have, we are able to break down a game into small tasks/emitterEvents as atomic pieces of code. It enables us to test the atomics independently as well. Visually it's something like this:</li> </ul>"},{"location":"fe_assets/fe_readme/#new-bookevent-steps-to-implement-and-test","title":"New BookEvent: Steps to Implement and Test","text":"<ul> <li> <p><code>New BookEvent</code>: Assume that you have a game already and you have added a new bookEvent <code>updateGlobalMult</code> to the bonus game mode (<code>MODE_BONUS</code>) in math, here we will go through the steps together to implement the new bookEvent and add it to the game. Along the way we will introduce part of our file structure as well.</p> </li> <li> <p><code>src/stories/data/bonus_books.ts</code>: This file includes the an array of bonus books that story <code>MODE_BONUS/book/random</code> will randomly pick at. This is to simulate requesting data from RGS. All we need to do is to copy/paste data from our new math package and format it.</p> </li> </ul> <pre><code>// Example of \"updateGlobalMult\" bookEvent. That's been added in our `bonus_books.ts` during generating math.\n{\n  type: 'updateGlobalMult',\n  globalMult: 3,\n},\n</code></pre> <ul> <li><code>src/stories/data/bonus_events.ts</code>: This file includes the an object of every type of bookEvent that story <code>MODE_BONUS/bookEvent/xxx</code> uses. All we need to do is to copy/paste data from our new math package and format it.</li> </ul> <pre><code>export default {\n  ...,\n  updateGlobalMult: {\n    type: 'updateGlobalMult',\n    globalMult: 3,\n  },\n  ...,\n}\n</code></pre> <ul> <li><code>src/stories/ModeBaseBookEvent.stories.svelte</code>: This file implements all the sub stories in story <code>MODE_BONUS/book/updateGlobalMult</code>. With the following code added in this file, you will see the a new story <code>MODE_BONUS/book/updateGlobalMult</code> that's added in our storybook with an <code>Action</code> button. Now if we click on it and nothing would happen, but it's a good start because we set up the testing environment first. Next step is to add code of bookEventHandler to handle it.</li> </ul> <pre><code>&lt;Story\n  name=\"updateGlobalMult\"\n  args={templateArgs({\n    skipLoadingScreen: true,\n    data: events.updateGlobalMult,\n    action: async (data) =&gt; await playBookEvent(data, { bookEvents: [] }),\n  })}\n/&gt;\n</code></pre> <ul> <li><code>src/game/typesBookEvent.ts</code>: This file contains typescript types of all the bookEvents. Let's add the type of our new bookEvent to get the intellisense from typescript for the following step.</li> <li><code>type BookEvent</code> is a union type.</li> </ul> <pre><code>type BookEventUpdateGlobalMult = {\n  index: number;\n  type: 'updateGlobalMult';\n  globalMult: number;\n};\n\nexport type BookEvent =\n  | ...\n  | BookEventUpdateGlobalMult\n  | ...\n;\n</code></pre> <ul> <li><code>src/game/bookEventHandlerMap.ts</code>: This file includes all the bookEventHandlers. Let's add a new one for the new bookEvent. Check the intellisense that the previous step brings, it provides a better developer experience.</li> </ul> <p></p>"},{"location":"fe_assets/fe_readme/#_4","title":"Frontend Documentation","text":"<ul> <li><code>src/components/GlobalMultiplier.svelte</code>: This file is created as our target svelte component for updateGlobalMulti bookEvent. Technically speaking, all the jobs that's related to global multiplier of the game should only be in this svelte component. Similar to the bookEvent types, let's add the typescript types for new emitterEvents first.</li> <li><code>type GlobalMultiplierEmitterEvent</code> is a union type.</li> </ul> <pre><code>&lt;script lang=\"ts\" module&gt;\n  export type GlobalMultiplierEmitterEvent =\n    | { type: 'globalMultiplierShow' }\n    | { type: 'globalMultiplierHide' }\n    | { type: 'globalMultiplierUpdate'; multiplier: number };\n&lt;/script&gt;\n</code></pre> <ul> <li><code>src/game/typesEmitterEvent.ts</code>: This file has typescript types of all the emitterEvents of the game. Let's add the type of our new emitterEvents for intellisense.</li> <li><code>type GameEmitterEvent</code> is a union type.</li> </ul> <pre><code>...\nimport type { GlobalMultiplierEmitterEvent } from '../components/GlobalMultiplier.svelte';\n...\n\nexport type GameEmitterEvent =\n  | ...\n  | GlobalMultiplierEmitterEvent\n  | ...\n;\n</code></pre> <ul> <li><code>src/components/GlobalMultiplier.svelte</code>: Back to our component file, the intellisense is there. Let's add the code to process the values with a spine animation as well.</li> </ul>"},{"location":"fe_assets/fe_readme/#_5","title":"Frontend Documentation","text":"<pre><code>&lt;script lang=\"ts\" module&gt;\n  export type GlobalMultiplierEmitterEvent =\n    | { type: 'globalMultiplierShow' }\n    | { type: 'globalMultiplierHide' }\n    | { type: 'globalMultiplierUpdate'; multiplier: number };\n&lt;/script&gt;\n\n&lt;script lang=\"ts\"&gt;\n  ...\n\n  context.stateApp.eventEmitter.registerOnMount({\n    // emitterEventHandlerMap\n    globalMultiplierShow: () =&gt; (show = true),\n    globalMultiplierHide: () =&gt; (show = false),\n    globalMultiplierUpdate: async (emitterEvent) =&gt; {\n      console.log(emitterEvent.multiplier)\n    },\n  });\n&lt;/script&gt;\n\n&lt;SpineProvider key=\"globalMultiplier\" width={PANEL_WIDTH}&gt;\n  ...\n  &lt;SpineTrack trackIndex={0} {animationName} /&gt;\n&lt;/SpineProvider&gt;\n</code></pre> <ul> <li><code>Test</code>: Run <code>pnpm run storybook --filter=&lt;MODULE_NAME&gt;</code> in the terminal. We should see this:</li> </ul>"},{"location":"fe_assets/fe_readme/#_6","title":"Frontend Documentation","text":"<ul> <li>Now click on the <code>Action</code> button and we should see the <code>&lt;GlobalMultiplier /&gt;</code> animates correctly followed by the \"Action is resolved\" message, otherwise we need to go back to the component and figure out what's wrong until it's resolved.</li> </ul>"},{"location":"fe_assets/fe_readme/#_7","title":"Frontend Documentation","text":"<ul> <li>If you find out the component hard to debug, we'd better start creating <code>COMPONENTS/&lt;GlobalMultiplier&gt;/component</code> or something even more lower level like <code>COMPONENTS/&lt;GlobalMultiplierSpine&gt;/component</code>. For which <code>&lt;GlobalMultiplierSpine /&gt;</code> component takes props instead of being controlled by emitterEvents. It's more friendly to test the component with the storybook controls.</li> </ul>"},{"location":"fe_assets/fe_readme/#to-be-continued","title":"To Be Continued","text":""},{"location":"gamestate_section/events_info/","title":"Game Event Structures","text":"<p>Events are the JSON objects returned from the RGS <code>play/</code> API and make up the vast majority of data with a game's library. Events contain all information required by the front-end to display the current state of the game. Anything not contained within or implied by the events cannot be shown to the player. For a typical game this includes, but is not limited to</p> <ul> <li>Active gameboard symbols</li> <li>Freespin counters</li> <li>Win counters</li> <li>Symbol win information</li> <li>Multipliers</li> <li>Special symbol actions </li> <li>....</li> </ul> <p>The events are crucial as all events need to be handled by the front-end. The user is free to determine their event structure, though to follow the example games, all events have the format,</p> <pre><code>event = {\n    \"index\": [int],\n    \"type\": [str],\n    \"&lt;field_1&gt;\": [T],\n    ...\n    \"&lt;field_n&gt;\": [T]\n}\n</code></pre> <p><code>\"index\"</code> keeps track of the current number of events in a simulation, <code>\"type\"</code> is a unique keyword used to identify an event and is generally a one-word description. <code>\"fields\"</code> are strings who's corresponding value can have any data-type, as required. Once constructed, the event is appended to the book, \"events\" field\":</p> <pre><code>gamestate.book.add_event(event)\n</code></pre> <p>Events are handled separately in the gamestate to game calculations or executables. They are imported explicitly and not attached to the gamestate object. Once the math-engine has made the appropriate board transformation or action, the event should be emitted immediately, as it will provide a snapshot of the current state of the game. For example:</p> <pre><code> from src.Events.Events import update_freespin_event\n run_spin():\n    ...\n    update_freespin_event(self)\n    ....\n</code></pre> <p>These events should be sent anytime new information needs to be communicated to the player.</p>"},{"location":"gamestate_section/force_info/","title":"Custom Defined Events","text":"<p>Every betmode will have a corresponding <code>force_record_&lt;betmode&gt;.json</code>. This file records the <code>book-id</code> corresponding to a custom defined search key. Anytime <code>self.record()</code> is called where</p> <pre><code>def record(self, description: dict) -&gt; None:\n    self.temp_wins.append(description)\n    self.temp_wins.append(self.book_id)\n</code></pre> <p>The current simulation number will be appended to the description/key if it exists, otherwise a new dictionary entry is made based on the description passed to the <code>record()</code> function. For example, we may want to keep track of how many Scatter symbols caused a freegame trigger. Which will be useful for later analysis to investigate the frequency of any custom defined event. In the freespin trigger executable function for example,</p> <pre><code>def run_freespin_from_base(self, scatter_key: str = \"scatter\") -&gt; None:\n    self.record(\n        {\n            \"kind\": self.count_special_symbols(scatter_key),\n            \"symbol\": scatter_key,\n            \"gametype\": self.gametype,\n        }\n    )\n    self.update_freespin_amount()\n    self.run_freespin()\n</code></pre> <p>This will ultimately output a <code>force_record_&lt;betmode&gt;.json</code> with the entries:</p> <pre><code>[\n    {\n        \"search\": {\n            \"gametype\": \"basegame\",\n            \"kind\": 5,\n            \"symbol\": \"scatter\"\n        },\n        \"timesTriggered\": 22134,\n        \"bookIds\": [\n            7,\n            12,\n            ....\n        ]\n    },\n    {\n        \"search\": {\n            \"gametype\": \"basegame\",\n            \"kind\": 6,\n            \"symbol\": \"scatter\"\n        },\n        \"timesTriggered\": 1196,\n        \"bookIds\": [\n            9,\n            10\n            ...\n        ]\n    },\n    ...\n]\n</code></pre>"},{"location":"gamestate_section/force_info/#summary-force-file","title":"Summary force file","text":"<p>Once all simulations have been completed, a <code>force.json</code> file is produced, which contains all unique search fields and keys. The intended use for this file is for prototyping, where a drop-down menu, or something of the sort can be created for all possible search conditions.</p>"},{"location":"gamestate_section/force_info/#accounting-for-discarded-simulations","title":"Accounting for discarded simulations","text":"<p>The <code>record()</code> function does not directly append the key/book-id to the force file. This action is only performed once a simulation has completed and is accepted. This is to ensure that keys/ids are not prematurely added if a simulation is rejected. Therefore keys and corresponding simulation ids are appended to <code>self.temp_wins</code> and <code>self.temp_wins</code> before being finalized within the <code>imprint_wins()</code> function within <code>src/state/state.py</code>. Keys must be unique, and book-ids are not repeated within keys, though the same book-id may appear within several keys.</p>"},{"location":"gamestate_section/repeat_info/","title":"Simulation Acceptance Criteria","text":"<p>When setting up the game configuration file each mode is split into different win-criteria. Given a total number of simulations for a given bet-mode, the number of simulations required for each criteria is set using a <code>quota</code>, which determines the ratio of the total number of simulations satisfying a particular win criteria. </p> <p>Following the example used in the Sample Games, the win criteria has been split into the following unique conditions:</p> <ol> <li><code>0</code> win amounts</li> <li><code>basegame</code> wins </li> <li><code>freegame</code> scenarios</li> <li><code>max-win</code> scenarios</li> </ol> <p>The purpose of segmenting these game outcomes is to ensure that there are sufficiently many simulations scenarios satisfying a certain criteria. For example if the hit-rate for a max-win is 1% of the avaliable RTP for a game with a 5000x payout would be 1 in 500,000 outcomes. Though if we are only producing 1 Million simulations in total for this mode, we would like to have more than 2 simulations in total which result in the maximum win amount. This reduces the posibility of any players seeing the same outcomes for a specific win amount. </p> <p>In the aforementioned list <code>0</code> dictates that the payout multiplier is ==0 for that simulation number. <code>basegame</code> is essentially any basegame spin where the payout is &gt;0  and the <code>freegame</code> is not triggered. <code>freegame</code> is any scenario where the <code>freegame</code> is triggerd from the basegame. <code>max-win</code> is any outcome where the maximum payout multiplier is awarded.</p> <p>This segmentation of wins is also used by the optimization algorithm.</p> <p>Pertanent to this section though, the simulation acceptance criteria is intergral to the <code>repeat</code> condition implented in all sample games. When the <code>GameState</code> is setup, the acceptance criteria is assigned to a specific simulation number before any simulations are carried out. So simulation 10, for example, is predetermined to be a simulation which triggers a <code>freegame</code>. </p> <p>When the <code>run_spin()</code> function is called and the game-round ends, wheather or not the simulation is recorded and added to the library is partially determined by the final win condition. If the only condition is that the simulation must be a <code>0</code> payout, then the <code>final_win</code> value is checked. If this condition is satisfied the <code>self.repeat = False</code> and the outcome is saved. Likewise if a particular simualation is determined to be <code>freegame</code> criteria, at the end of the spin we verify if the freegame has been triggered and accept the simulation result if so. There can be as many conditions are required in the <code>self.check_repeat()</code> function. Just be aware that the more stringent the criteria, the longer a simulation will likely take to run. This time can be quite substancial if the required criteria is unlikely to be achieved naturally. For the <code>max-win</code> scenarios for example, generally a specificly made reelstrip is used, and the probability if achieving higher multipliers, prizes etc.. is dictated  in the bet-mode distribution.</p>"},{"location":"gamestate_section/repeat_info/#predetermining-acceptance","title":"Predetermining Acceptance","text":"<p>While it would be useful to run the simulations first and then assign the distribution criteria afterwards, this can cause issues when multi-threading larger simulation batches. Simulations relating to max-wins for example typically take substancially longer to succede than say <code>0</code> win simulations. This means that all crietria except the max-win are likely to be filled first, leaving the final thread to deal with many or all of the max-win simulations. For this reason, the <code>quota</code> in the BetMode distribution conditions is used in conjunction with the total number of simulations. </p>"},{"location":"gamestate_section/win_info/","title":"Win calculations","text":"<p>There are several built-in win methods included in the engine:</p> <ol> <li>Lines pays</li> <li>Ways pays</li> <li>Cluster pays</li> <li>Scatter pays</li> </ol>"},{"location":"gamestate_section/win_info/#_1","title":"Wins","text":"<p>Irrespective of the win method applied, win information is stored in the gamestate object win_data:</p> <pre><code> win_data = {\n    'totalWin': [float],\n    'wins': [List[Dict]]\n }\n</code></pre> <p>This initialized <code>win_data</code> structure is the return value for all provided win calculation functions. If using the predefined win events, the dictionary items within <code>wins</code> must contain the \"position\" key to account for modifying the row number if needed for the padding symbols. All wins information for the current game board should be included in this structure. Such as all winning symbol combinations, win amounts and positions. The built-in functions also include a `meta' key which includes any additional information which the front-end may need to display. For the win-lines, as an example this appears as:</p> <pre><code>'wins': {\n    'symbol': 'H1',\n    'kind': 5,\n    'win': 300,\n    'positions': [{'reel':1, 'row':1}, ...],\n    'meta':{\n        'lineIndex': 12,\n        'multiplier': 10,\n        'winWithoutMult': 30,\n        'globalMult': 1,\n        'lineMultiplier': 10\n    }\n}\n</code></pre> <p>This additional information includes any symbol or global multiplier values applied, the base win amount, and the <code>lineIndex</code>, as defined in config.paylines = {[], ...}``</p>"},{"location":"gamestate_section/win_info/#multiplier-methods","title":"Multiplier methods","text":"<p>For generality all win methods utilize functions from the <code>wins/multiplier_strategy</code> file. By calling <code>apply_mult()</code> with a specified strategy (<code>global</code>, <code>symbol</code>, <code>combined</code>), base win amount and winning symbol positions, total win amounts are returned inclusive of any global multipliers or symbol multipliers. By default, if the <code>combined</code> or <code>symbol</code> strategy is used, multiplier values are added together from winning symbol positions, where the symbol object contains the <code>multiplier</code> attribute.</p>"},{"location":"gamestate_section/win_info/#overlay-values","title":"Overlay values","text":"<p>The cluster and scatter pay sample games, there is an <code>overlay</code> key included ine <code>win_data</code> \"meta\" tag of the structure:</p> <pre><code>'meta': {\n    ...\n    'overlay': {'reel': [int], 'row': [int]}\n}\n</code></pre> <p>This position is calculated as the board position closest to the  centre-of-mass of winning clusters.</p>"},{"location":"gamestate_section/win_info/#wallet-manager","title":"Wallet manager","text":"<p>When writing game logic, the intent is to have a clear seperation of logic, events and wins for clarity. The wins are all handled through a <code>WalletManager</code> class, which will handle outcomes from single spins while also keeping track of total cumulative win amount for RTP calculations, as well as which gametype the wins arise from.</p> <p>This can be seen in a typical gamestate <code>run_spin()</code> function where wins are calculated, the wallet is updated and corresponding win events are emitted:</p> <pre><code>self.win_data = self.get_lines()\nself.win_manager.update_spinwin(self.win_data[\"totalWin\"])\nself.emit_linewin_events()\n</code></pre> <p>Within a single spin there are wallet manager values associed with:</p> <ol> <li><code>spin_win</code> <ul> <li>This is the win associated with a specific <code>reveal</code> event. If the freegame is entered, this value is reset for each new spin. </li> <li>Updated using <code>wallet_manager.update_spinwin(win_amount: float)</code></li> </ul> </li> <li><code>running_bet_win</code><ul> <li>This is the cumulative win amount for a simulation. The final value which the <code>running_bet_win</code> is updated with should match the <code>payout_multiplier</code> for that simuation. </li> <li>This value is automatically updated with the <code>wallet_manager.set_spinwin(win_amount: float)</code> method.</li> </ul> </li> <li><code>basegame_wins</code>/<code>freegame_wins</code><ul> <li>This value is updated once all basegame actions are completed, or at the end of each freegame spin.</li> <li>Updated using <code>wallet_manager.update_gametype_wins(self.gametype)</code></li> <li>Important! As part of the final payout verification self.final_win and sum(self.basegame_wins + self.freegame_wins) must match. If these two payouts do not match a <code>RuntimeError</code> is raised. </li> <li>This is useful for game analysis and applying the correct parameters to the optimization algorithm. </li> </ul> </li> <li>Cumulative simulation wins<ul> <li><code>total_cumulative_wins</code>, <code>cumulative_base_wins</code> and <code>cumulative_free_wins</code> wins are updated at the end of each simulation. This value is used to display the runtime RTP for all simulations when printed in the terminal.</li> <li>Updated using <code>wallet_manager.update_end_round_wins()</code> within the <code>imprint_wins</code> function.</li> </ul> </li> </ol>"},{"location":"gamestate_section/configuration_section/betmode_dist/","title":"Distribution Conditions","text":"<p>Within each <code>BetMode</code> there is a set of <code>Distribution</code> Classes which determine the win-criteria within each bet-mode. Required fields are:</p> <ol> <li>Criteria<ul> <li>A shorthand name describing the win condition in a single word</li> </ul> </li> <li>Quota<ul> <li>This is the amount of simulations (as a ratio of the total number of bet-mode simulation) which need to satisfy the corresponding criteria. The quota is normalised when assigning criteria to simulations, so the sum of all quotas does not need to be 1. There is a minimum of 1 simulation assigned per criteria.</li> </ul> </li> <li> <p>Conditions</p> <ul> <li>Conditions can have an arbitary number of keys. Though the required keys are:<ul> <li><code>reel_weights</code> </li> <li><code>force_wincap</code></li> <li><code>force_freegame</code></li> </ul> </li> </ul> <p>Note that <code>force_wincap</code> and <code>force_freegame</code> are set to <code>False</code> by default and do not have to be explicitly added.</p> <p>The most common use for the Distribution Conditions is when drawing a random value using the BetMode's built-in method <code>get_distribution_conditions()</code>. i.e. <code>python     multiplplier = get_random_outcome(betmode.get_distribution_conditions()['mult_values'])</code> Or to check if a board forcing the <code>freegame</code> should be drawn with: <code>python if get_distribution_conditions()['force_freegame']:     ...</code></p> </li> <li> <p>Win criteria (optional)</p> <p>There is also a <code>win_criteria</code> condition which incorporates a payout multiplier into the simulation acceptance. The two commonly used condtions are <code>win_criteria = 0.0</code> and <code>win_criteria = self.wincap</code>. When calling <code>self.check_repeat()</code> at the end of a simulation, if <code>win_criteria</code> is not <code>None</code> (default), the final win amount must match the value passed. </p> <p>The intention behind betmode distribution conditions is to give the option to handle game actions in a way which depends on the (known) expected simulation. This is most clear if for example a simulation is known to correspond to a <code>max-win</code> scenario. Instead of repeatly drawing random outcomes which are most likely to be rejected, we can alter the probabilties of larger payouts occurring by biasing a particular reelset, weighting larger prize or multiplier values etc..</p> </li> </ol>"},{"location":"gamestate_section/configuration_section/betmode_overview/","title":"BetMode","text":"<p>All valid bet-modes are defined in the array <code>self.bet_modes = [ ...]</code>  The <code>BetMode</code> class is an important configuration for when setting up game the behaviour of a game. A full description of all features is defined here</p> <p>This class is used to set maximum win amounts, RTP, bet cost, and distribution conditions. Additional noteworthy tags are:</p> <ol> <li><code>auto_close_disabled</code><ul> <li>When this flag is <code>False</code> (default) the RGS endpoint API <code>/endround</code> is called automatically to close out the bet for efficiency. When the bet is closed however, the player cannot resume their bet. It may be desirable in bonus modes for example, to set this flag to <code>True</code> so that the player can resume interrupted play even if the payout is <code>0</code>. This means that the front-end will have to manually close out the bet in this instance.</li> </ul> </li> <li><code>is_feature</code><ul> <li>When this flag is true, it tells the frontend to preserve the current bet-mode without the need for player interaction. So if the player changes to <code>alt_mode</code> where this mode has <code>is_feature = True</code>, every time the spin/bet button is pressed, it will call the last selected bet-mode. Unlike in bonus games, where the player needs to confirm the bet-mode choice after each round completion.</li> </ul> </li> <li><code>is_buybonus</code><ul> <li>This is a flag used for the frontend framework to determine if the mode has been purchased directly (and hence may require a change in assets).</li> </ul> </li> </ol>"},{"location":"gamestate_section/configuration_section/config_overview/","title":"Game Configuration Files","text":"<p>The GameState object requires certain parameters to be specified, and should be manually filled out for each new game. These elements are all defined in the <code>__init__</code> function. Full details of the expected inputs and data-types are given in the Source Files/Config section. </p> <p>General aspects of the game setup which should be considered when creating a <code>game_config.py</code> are:</p>"},{"location":"gamestate_section/configuration_section/config_overview/#gametypes","title":"Gametypes","text":"<p>Several parts of the engine such as win amount verification, special symbol triggers/attributes and win-levels require the engine to know if the current state of the game is in the basegame or freegame. For example it is common to perform a weighted draw of some value:  <code>python  #Within game config:  self.multiplier_values = {     \"basegame\":{1:100, 2:50, 3: 10},      \"freegame\":{2:20, 3:50, 5: 20, 10:10, 20:1}}  ....  #Within gamestate:  multiplier = get_random_outcome(self.config.multiplier_values[self.gametype])</code> Typically special rules apply when the player enters a freegame. The configuration file allows the user to specify the key corresponding to each gametype. By default this is set to <code>basegame</code> and <code>freegame</code> respectively. All simulations will start in the basegame mode unless otherwise specified, and the transition to the freegame state is handled in the default <code>reset_fs_spin()</code> function, which is called as soon as the <code>run_freespin()</code> function is entered. </p>"},{"location":"gamestate_section/configuration_section/config_overview/#path-construction","title":"Path construction","text":"<p>When simulation results are saved, there are several files which are saved upon completing the simulation, along with the path to reel-strips the existence of the following output files are verified, and created if they do not exist. These paths can be checked by accessing self.config.&lt; path_label &gt;</p> <ul> <li>library_path: <code>games/game_id/library/</code></li> <li>books_path/books_compressed_path: <code>games/game_id/library/books/</code></li> <li>lookup_path: <code>games/game_id/library/lookup_tables/</code></li> <li>config_path: <code>games/game_id/library/configs/</code></li> <li>force_path: <code>games/game_id/library/forces</code></li> <li>temp_path: <code>games/game_id/library/temp_multi_threaded_files/</code></li> <li>reels_path: <code>games/game_id/reels/</code></li> </ul>"},{"location":"gamestate_section/configuration_section/config_overview/#reels","title":"Reels","text":"<p>Most games will use distinct reelstrips for different gametypes. It is commonplace for game-modes to have multiple possible reels per mode. One method of adjusting the overall RTP of a game is to have a multiple reelstrips with varying RTP, which can be selected from a weighted draw when calling <code>self.create_board_from_reelstrips()</code>. Reelstrips are stored as a dictionary in the <code>self.config.reels</code> object. The reelstrip key and csv file name should be specified:</p> <pre><code>        reels = {\"BR0\": \"BR0.csv\", \"FR0\": \"FR0.csv\"}\n        self.reels = {}\n        for r, f in reels.items():\n            self.reels[r] = self.read_reels_csv(str.join(\"/\", [self.reels_path, f]))\n</code></pre> <p>Reelstrip weightings are required distribution conditions. An example of using multiple reelstrips for each gametype can be applied as:</p> <pre><code>    conditions={\n        \"reel_weights\": {self.basegame_type: {\"BR0\": 2, \"BR1\": 1}, self.freegame_type: {\"FR0\":5, \"FR1\": 1}},\n    },\n</code></pre>"},{"location":"gamestate_section/configuration_section/config_overview/#scatter-triggers-and-anticipation","title":"Scatter triggers and Anticipation","text":"<p>Freegame entry from the basegame or retriggers in the freegame should be specified in the format <code>{num_scatters: num_spins}</code>,</p> <pre><code>    self.freespin_triggers = {\n        self.basegame_type: {3: 10, 4: 15, 5: 20},\n        self.freegame_type: {2: 4, 3: 6, 4: 8, 5: 10},\n    }\n</code></pre>"},{"location":"gamestate_section/configuration_section/config_overview/#symbol-initialization","title":"Symbol initialization","text":"<p>A symbol is determined to be valid if the name exists either in <code>self.paytable</code> or in <code>self.special_symbols</code>. If a symbol that does not exist in either of these fields is detected when loading reelstrips, a <code>RuntimeError</code> is raised.</p>"},{"location":"gamestate_section/configuration_section/config_overview/#symbol-values","title":"Symbol values","text":"<p>Winning symbols are determined from the <code>self.paytable</code> dictionary object in the game configuration. The expected format is:</p> <pre><code>    self.paytable = {\n        (kind[int], name[str]): value[float],\n        ...\n    }\n</code></pre> <p>Where <code>kind</code> is the number of winning symbols. For cascading games, or other circumstances where multiple winning symbol numbers pay the same about, for example in the scatter pays example game where 13+ symbols pay the same amount, <code>self.pay_group</code> can be defined. By then calling <code>self.paytable = self.convert_range_table(pay_group)</code> a paytable of the expected format is generated. The format of the pay-group objects (inclusive of both values in the kind-range) is given as:</p> <pre><code>    self.pay_group = {\n        ((min_kind[int],max_kind[int]), name[str]): value[float],\n        ...\n    }\n</code></pre>"},{"location":"gamestate_section/configuration_section/config_overview/#special-symbols","title":"Special symbols","text":"<p>Special symbol attributes are assigned based on names appearing in <code>self.special_symbols = {attribute[str]: [name[str], ...]}</code>. Multiple symbols can share attributes and multiple attributes can be applied to the same symbol. Most games will at least have a <code>wild</code> and <code>scatter</code> attribute. Once the symbol is initialised, the value of the attribute is accessed through <code>symbol.attribute</code> or symbol.get_attribute(attribute) see Symbols for more information regarding symbol object structures. By default the attribute is set to <code>True</code>, unless otherwise overridden using the <code>gamestate.special_symbol_functions</code>, defined in the gamestate override.</p>"},{"location":"gamestate_section/syms_board_section/board_info/","title":"Active Game Board","text":"<p>The active game-board is created as a 2D array of symbol objects. Each object within the array creates a new object instance. </p>"},{"location":"gamestate_section/syms_board_section/board_info/#displaying-the-board","title":"Displaying the board","text":"<p>The board can be displayed by calling the <code>print_board()</code> method in the <code>Board</code> class, which will display a correctly orientated printout of all symbol names</p> <pre><code>self.print_board(self.board) -&gt;\n</code></pre> <pre><code>L5 L3 L4 L4 L4 \nL3 H4 L3 H1 L4 \nL3 H1 S  L3 H1 \n</code></pre>"},{"location":"gamestate_section/syms_board_section/board_info/#active-special-symbols","title":"Active special symbols","text":"<p>When the game board is generated any symbols appearing in <code>config.special_symbols = {'property' : [symbols, ..]}</code> will be appended to the gamestate property <code>special_symbols_on_board = {'property': [{'reel': reel[int], 'row': row[int]}]}</code>. This property is particularly useful for checking aspects such as freegame entry conditions:</p> <pre><code>    if len(self.special_symbols_on_board['scatter']) &gt;= min_scatter:\n        self.run_freespin_from_base()\n</code></pre> <p>Care should be taken to update any new symbols which may appear on the board either from cascading events or through the application of some special action, such as removing symbols from the game board. If custom functions are being used which involve altering active symbols, the method <code>get_special_symbols_on_board()</code> from the <code>Board</code> class should be invoked.</p>"},{"location":"gamestate_section/syms_board_section/board_info/#tumbling-the-board","title":"Tumbling the board","text":"<p>For cascading games (such as the Scatter and Cluster example games), winning symbols are removed from the board and symbols above tumble down to fill these vacant positions. Winning symbols are assigned the attribute <code>explode</code>. Subsequently when the <code>tumble_board()</code> method is called from the <code>Tumble</code> class, </p>"},{"location":"gamestate_section/syms_board_section/board_info/#topbottom-symbols","title":"Top/bottom symbols","text":"<p>In the <code>config</code> class, there is a boolean option <code>include_padding</code>. This is to account for games where it is desirable for the player to see the symbols immediately above/below the active board. Usually this is displayed as a symbol being partially in-frame. If this flag is set to true, the row indexing for the active game board will start at <code>row=1</code>, where <code>row 0</code> is the <code>top_symbol</code> and <code>row len(board) + 1</code> is the <code>bottom_symbol</code>. The top and bottom symbols are included in the <code>board</code> <code>reveal</code> event. Within the gamestate these symbols are stored as:</p> <pre><code>self.top_symbols = [s1, s2, ....]\nself.bottom_symbols = [s1, s2, ....]\n</code></pre> <p>Note that for cascading/tumbling games, the top symbol is preserved during the tumble.</p>"},{"location":"gamestate_section/syms_board_section/symbol_info/","title":"Symbol structure","text":"<p>Symbols are handled as their own distinct class objects. Based only off a symbol name, several useful attibutes are assigned to the object based on if the symbol name appears in in the <code>config.paytable</code> or <code>config.special_symbols</code> fields. </p> <pre><code>class Symbol:\n    def __init__(self, config: object, name: str) -&gt; None:\n        self.name = name\n        self.special_functions = []\n        self.special = False\n        is_special = False\n        for special_property in config.special_symbols.keys():\n            if name in config.special_symbols[special_property]:\n                setattr(self, special_property, True)\n                is_special = True\n\n        if is_special:\n            setattr(self, \"special\", True)\n\n        self.assign_paying_bool(config)\n</code></pre> <p>When a new game-board is drawn, a 2D array of symbol objects are generated. At a minimum, the symbol will have the attributes:</p> <ul> <li>Name<ul> <li>[string] shorthand name, typically 1 or 2 letters</li> </ul> </li> <li>special_functions<ul> <li>Within the <code>GameStateOverride</code> class, special functions can be applied to a symbol as soon as the object is created. This is done through the abstract function, for example:</li> </ul> </li> </ul> <pre><code>    def assign_special_sym_function(self):\n        self.special_symbol_functions = {\n            \"W\": [self.assign_mult_property],\n        }\n    def assign_mult_property(self, symbol):\n        multiplier_value = get_random_outcome(\n            self.get_current_distribution_conditions()[\"mult_values\"][self.gametype]\n        )\n        symbol.assign_attribute({\"multiplier\": multiplier_value})\n</code></pre> <pre><code>`assign_special_sym_function()` is called when the `GameState` is initially created. In this example, we are assigning a multiplier value to any new wild ('W') which is created. Any action defined within `self.special_symbol_functions` with the format `{&lt;name&gt;: @callable_func}` will be assigned to the `special_functions` property.\n</code></pre> <ul> <li>is_special<ul> <li>This property is assigned as <code>False</code> by default unless the name appears as a value within <code>config.special_symbols</code></li> </ul> </li> <li>special_property<ul> <li>Properties appearing in <code>config.special_functions = {'property': [name]}</code> are set to <code>True</code> by default. </li> </ul> </li> <li>assign_paying_bool()<ul> <li>This function assigns the properties <code>is_paying</code> and <code>paytable</code>. If the symbol name appears in <code>config.paytable</code> <code>is_paying</code> is set to <code>True</code> and the relevant paytable values are assigned to <code>paytable</code>. Otherwise these values are set to <code>False</code> and <code>None</code> respectively.</li> </ul> </li> </ul>"},{"location":"gamestate_section/syms_board_section/symbol_info/#symbol-attributes","title":"Symbol Attributes","text":"<p>In addition to the application of <code>special_functions</code>, attributes are an important characteristic of symbol objects, particularly for checking if there are any special symbols on the game-board which require additional actions. For example if we want to check if a given symbol has a <code>prize</code> or <code>multiplier</code> attribute:</p> <pre><code>    if self.board[reel][row].check_attribute('prize','multiplier'):\n        ...\n</code></pre> <p>The <code>check_attribute</code> function will return a <code>boolean</code> value if the given attribute exists and its value is not <code>False</code>. I.e.:</p> <pre><code>    if symbol.check_attribute('prize'):\n        win += symbol.get_attribute('prize')\n</code></pre> <p>Furthermore we can assign properties to a symbol using the <code>assign_attribute</code> method. As an example, if we have a game where we have a special symbol denoted by the <code>enhance</code> tag. Where the effect of this symbol is to add a <code>multiplier</code> value to any active <code>Wild</code> symbols. In the <code>gamestate</code> we could preform the following actions:</p> <pre><code>    if len(self.special_symbols_on_board['enhance']) &gt; 0:\n        for sym in self.special_symbols_on_board[wild]:\n            mult_val = get_random_outcomes(self.config.mult_values[self.gametype])\n            self.board[sym['reel']][sym['row']].assign_attribute({'multiplier', mult_val})\n</code></pre>"},{"location":"optimization_section/optimization_algorithm/","title":"Optimizing win distributions with iterative weighted sampling","text":"<p>A discussion of how the provided optimization algorithm operates can be viewed by downloading this paper.</p> <p>The aforementioned algorithm is implemented in the Rust programming language, this program compiles down to a binary executable. If the program is being run for the first time, or if there are modifications made to the main.rs file, the binary should be rebuilt using:</p> <pre><code>cargo build --release\n</code></pre>"},{"location":"optimization_section/optimization_algorithm/#setting-up-optimization-parameters","title":"Setting up optimization parameters","text":"<p>The optimization algorithm parameters can be setup and passed within the run.py file Game-specific parameters should be set using the OptimizationSetup class. This Class takes as input the game configuration class and appends opt_params. This is a dictionary where the keys are the betmode names and have the required keys:</p> <pre><code>opt_params = &lt;mode_name&gt; : {\n    \"conditions\": ...\n    \"scaling\": ...\n    \"parameters: \n}\n</code></pre> <p>Each key has a corresponding construction class within <code>optimizaation_algorithm/optimization_config.py</code></p>"},{"location":"optimization_section/optimization_algorithm/#conditions","title":"Conditions","text":"<p>The <code>conditions</code> key has the setup class <code>ConstructConditions</code>. This key separates out specific simulation numbers which the optimization algorithm is applied to. The optimization program requires knowing what RTP to optimize a subset of solutions to.  This is generally separated out into events where it is desirable to control the frequency of such an event occurring. Such as freegame, max wins or 0-win hit-rates. For each of these win types, we need to have a well defined RTP, meaning that we need 2 of the 3 variables, RTP, average wins, hit-rates. You will notice that for the 0 win conditions in the sample game the hit-rate is undefined (x), this is allowed because it is a free-variable. Since all hit-rates of all win-types must sum to be exactly 1, we are able to deduce the hit-rate using 1 - (sum of all other win-type allocations).</p>"},{"location":"optimization_section/optimization_algorithm/#scaling","title":"Scaling","text":"<p>We are able to bias particular win-ranges within the optimization program. We initially generating our trial distributions, we can artificially increase or decrease the the Gaussian weights within this range by a particular scale factor. We can also assign a probability of these weights being assigned for each distribution created. Note that biasing particular ranges by a significant amount can be lead to a lower likelihood of a randomly assigned distribution being accepted, so its effect should be used carefully. </p>"},{"location":"optimization_section/optimization_algorithm/#parameters","title":"Parameters","text":"<p>This input is used to construct a setup file red by the optimization tool. It defines the number of distributions to trial before combination, minimum and maximum mean-to-median distribution scores to control volatility as well as the number of simulated test spins to run in order to rank viable distributions. </p>"},{"location":"optimization_section/optimization_algorithm/#executing-optimization-script","title":"Executing optimization script","text":"<p>Once the game specific <code>OptimizationSetup</code> class is constructed, a <code>math_config.json</code> file is generated containing all relevant game parameters in conjunction with a <code>setup.txt</code> file detailing simulation setup optimization parameters, handled with the <code>OptimizationExecution</code> class. Within the <code>run.py</code> file we can specify which game modes we would like to optimize and directly run the Rust binary using:</p> <pre><code>    optimization_modes_to_run = [\"base\", \"bonus\"]\n    OptimizationExecution().run_all_modes(config, optimization_modes_to_run, rust_threads)\n</code></pre>"},{"location":"overview_section/game_format/","title":"Standard Game Setup Requirements","text":"<p>Without diving into specific functions, this section is intended to walkthrough how a new slot game would generally be setup. In practice it is recommended to start with one of the sample games which closest resemble the game being made, or otherwise starting from the template.</p>"},{"location":"overview_section/game_format/#configuration-file","title":"Configuration file","text":"<p>Game parameters should all be set in the <code>GameConfig</code> <code>__init__()</code> function. This is where to set the name name, RTP, board dimensions, payouts, reels and various special symbol actions. All required fields are listed in the <code>Config</code> class and should be filed out explicitly for each new game. Next the <code>BetMode</code> classes are defined. Generally there would be at a minimum a (default) <code>base</code> game and a <code>freegame</code>, which is usually purchased. </p> <pre><code>class GameConfig(Config):\n    def __init__(self):\n        super().__init__()\n        self.game_id = \"\"\n        self.provider_number = 0\n        self.working_name = \"\"\n        self.wincap = 0\n        self.win_type = \"lines\"\n        self.rtp = 0\n\n        self.num_reels = 0\n        self.num_rows = [0] * self.num_reels  \n        self.paytable = {\n            (kind, symbol): payout, \n        }\n\n        self.include_padding = True\n        self.special_symbols = {\"property\": [\"sym_name\"],...}\n\n        self.freespin_triggers = {\n        }\n        self.reels = {}\n        self.bet_modes = []\n</code></pre> <p>Each <code>BetMode</code> should likewise be set explicitly, defining the cost, rtp maximum win amounts and various gametype flags. We would like to define different win criteria within each betmode. In the sample games we define distinct criteria for any game-aspects where we would like to control either the hit-rate and/or RTP allocation. In this example we would like to control the basegame hit-rate, max-win hit-rate and freegame hit-rate. Therefore we need to specify unique <code>Distribution</code> criteria for each of these special conditions. Further information about purpose of Distribution conditions can be found here and here</p> <pre><code>    BetMode(\n        name=\"base\",\n        cost=1.0,\n        rtp=self.rtp,\n        max_win=self.wincap,\n        auto_close_disabled=False,\n        is_feature=True,\n        is_buybonus=False,\n        distributions=[\n            Distribution(\n                criteria=\"winCap\",\n                quota=0.001,\n                win_criteria=self.wincap,\n                conditions={\n                    \"reel_weights\": {\n                        self.basegame_type: {\"BR0\": 1},\n                        self.freegame_type: {\"FR0\": 1},\n                    },\n                    \"force_wincap\": True,\n                    \"force_freegame\": True,\n                },\n            ),\n            Distribution(\n                criteria=\"freegame\",\n                quota=0.1,\n                conditions={\n                    \"reel_weights\": {\n                        self.basegame_type: {\"BR0\": 1},\n                        self.freegame_type: {\"FR0\": 1},\n                    },\n                    \"force_wincap\": False,\n                    \"force_freegame\": True,\n                },\n            ),\n            Distribution(\n                criteria=\"0\",\n                quota=0.4,\n                win_criteria=0.0,\n                conditions={\n                    \"reel_weights\": {self.basegame_type: {\"BR0\": 1}},\n                },\n            ),\n            Distribution(\n                criteria=\"basegame\",\n                quota=0.5,\n                conditions={\n                    \"reel_weights\": {self.basegame_type: {\"BR0\": 1}},\n                },\n            ),\n        ],\n    )\n</code></pre>"},{"location":"overview_section/game_format/#gamestate-file","title":"Gamestate file","text":"<p>When any simulation is run, the entry point will be the <code>run_spin()</code> function, which lives in the <code>GameState</code> class. <code>GameExecuatables</code> and <code>GameCalculations</code> are child classes of <code>GameState</code> and also deal with game specific logic.</p> <p>The generic structure would follow the format:</p> <pre><code>def run_spin(self, sim):\n    self.reset_seed(sim) #seed the RNG with the simulation number \n    self.repeat = True\n    while self.repeat:\n        self.reset_book() #reset local variables\n        self.draw_board() #rraw board from reelstrips\n\n        #evaluate win_data\n        #update win_manager\n        #emit relevant events\n\n        self.win_manager.update_gametype_wins(self.gametype) #update cumulative basegame wins\n        if self.check_fs_condition(): #check scatter conditions\n            self.run_freespin_from_base() #run freegame\n\n        self.evaluate_finalwin()\n        self.check_repeat() #Verify betmode distribution conditions are satisfied\n\n    self.imprint_wins() #save simulation result\n</code></pre> <p>For reproducibility the RNG is seeded with the simulation number. Betmode distribution criteria are preassigned to each simulation number, requiring the <code>self.repeat</code> condition to be initially set until the spin has completed and it can be checked that any criteria-specific conditions or win amounts are satisfied. Note that <code>self.repeat = False</code> is set in the <code>self.reset_book()</code> function. This function will reset all relevant <code>GameState</code> properties to default values. </p> <p>Generally the first steps will be to use the reelstrips provided in the configuration file to draw a board from randomly chosen reelstop positions. Wins are evaluated from one of the provided win-types for the active board, and the wallet manager is updated. After this game-logic is completed the relevant events (such as <code>reveal</code> and <code>winInfo</code>) are emitted. All sample games follow these three steps: 1. Calculate current state of the board 2. Update wallet manager 3. Emit events</p> <p>To keep track of which gametype wins are allocated, the wallet manger is again invoked once all basegame actions are complete. If the game have a freegame mode and the triggering conditions are satisfied the <code>run_freespin()</code> function is invoked. This mode will have a similar structure:</p> <pre><code>def run_freespin(self):\n    self.reset_fs_spin() #reset freegame variables\n    while self.fs &lt; self.tot_fs: #account for multiple freegame spins\n        self.update_freespin() #update spin number and emit event\n        self.draw_board() #draw a new board using freegame reelstrips\n\n        #evaluate win_data\n        #update win_manager\n        #emit relevant events\n\n        if self.check_fs_condition(): #check retrigger conditions\n            self.update_fs_retrigger_amt()\n\n        self.win_manager.update_gametype_wins(self.gametype) #update cumulative freegame win amounts\n\n    self.end_freespin() #emit event to indicate end of freegame\n\n</code></pre> <p>While it is possible to perform all game actions within these functions, for clarity functions from <code>GameExecutables</code> and <code>GameCalculations</code> are typically invoked and should be created on a game-by-game basis depending on requirements. </p>"},{"location":"overview_section/game_format/#runfile","title":"Runfile","text":"<p>Finally to produce simulations, the <code>run.py</code> file is used to create simulation outputs and config files containing game and simulation details. </p> <pre><code>if __name__ == \"__main__\":\n\n    num_threads = 1\n    rust_threaeds = 20\n    batching_size = 50000\n    compression = False\n    profiling = False\n\n    num_sim_args = {\n        \"base\": int(10),\n        \"bonus\": int(10),\n    }\n\n    config = GameConfig()\n    gamestate = GameState(config)\n\n    create_books(\n        gamestate,\n        config,\n        num_sim_args,\n        batching_size,\n        num_threads,\n        compression,\n        profiling,\n    )\n    generate_configs(gamestate)\n\n</code></pre> <p>The <code>create_books</code> function handles the allocation of win criteria to simulation numbers, output file format and multi-threading parameters. </p>"},{"location":"overview_section/game_format/#outputs","title":"Outputs","text":"<p>Simulation outputs are placed in the <code>game/library/</code> folder. <code>books/books_compressed</code> is the primary data-file containing all events and payout multipliers. <code>lookup_tables</code> hold the summary simulation-payout values in <code>.csv</code> format which is consumed by the optimization algorithm. Additionally for game analysis, lookup table mapping of which simulations belong to which win criteria and which gametype wins arise from are produced. <code>force/</code> file outputs contain all information used by the <code>.record()</code> function, which is again useful for analyzing the frequency and average win amounts for specific events. The optimization algorithm also uses the recorded <code>force</code> data to identify which simulations correspond to specific win criteria. Finally <code>config/</code> files contain information required by the frontend such as symbol and betmode information, backend information such as file hash values and a configuration file for the optimization algorithm.</p> <p>The optimization algorithm consumes the lookup table and outputs a copy of the file, but with modified weights. To assist with setting optimization parameters, there are two other files with the prefix <code>lookUpTableIdToCriteria</code> and <code>lookUpTableSegmented</code>. These files are used to identify which bet-mode sub-type that specific simulation number belongs to (such as max-wins, 0-wins, freegame entry etc..), and what gametype (usually basegame or freegame) contributes to the final payout multiplier.</p>"},{"location":"overview_section/game_struct/","title":"Intended Engine Usage","text":""},{"location":"overview_section/game_struct/#game-files","title":"Game Files","text":"<p>As seen in the example games, all games follow a recommended structure, which should be copied from the games/template folder. </p> <pre><code>```\ngame/\n\u251c\u2500\u2500 library/\n|----- books/\n|----- books_compressed/\n|----- configs/\n|----- forces/\n|----- lookup_tables/\n\u251c\u2500\u2500 reels/\n\u251c\u2500\u2500 readme.txt\n\u251c\u2500\u2500 run.py\n\u251c\u2500\u2500 game_config.py\n\u251c\u2500\u2500 game_executables.py\n\u251c\u2500\u2500 game_calculations.py\n\u251c\u2500\u2500 game_events.py\n\u251c\u2500\u2500 game_override.py\n\u2514\u2500\u2500 gamestate.py\n```\n</code></pre> <p>Sub-folders within library/ are automatically generated if they do not exist at the completion of the simulation. readme.txt is used for developer descriptions of game mechanics and miscellenous information relevant to that particular game.</p> <p>While all commonly used engine functions are handled by classes within their respective src/ directory, every game is likely to be unique in some way and these game-files allow the user to override existing functions in order to add additional engine features to suit their use-case, or implement game-specific logic. </p> <p>The game_config/executables/calculations/events/override files offer extensions on actions defined in the Source Files section, which should be consulted for more detailed information.</p>"},{"location":"overview_section/game_struct/#run-file","title":"Run-file","text":"<p>This file is used to set simulation parameters, specifically the configuration and <code>GameState</code> classes. The required specifications include:</p> Parameter Type Description <code>num_threads</code> <code>int</code> Number of threads used for multithreading <code>rust_threads</code> <code>int</code> Number of threads used by the Rust compiler <code>batching_size</code> <code>int</code> Number of simulations run on each thread <code>compression</code> <code>bool</code> <code>True</code> for <code>.json.zst</code> compressed books, <code>False</code> for <code>.json</code> format <code>profiling</code> <code>bool</code> <code>True</code> outputs and opens a <code>.svg</code> flame graph <code>num_sim_args</code> <code>dict[int]</code> Keys must match bet mode names in the game configuration <p>All simulations are passed to the <code>create_books()</code> function which carries out all the simulations and handles file output. This function will populate <code>library/</code> <code>books_compressed</code>, <code>books</code>, <code>forces</code>,  <code>lookup_tables</code> folders.</p> <p>Once the simulations are completed, the gamestate is passed to <code>generate_configs(gamestate)</code> which handles generating config files used for the frontend (<code>config_fe.json</code>), backend (<code>config.json</code>) and optimization (<code>config_math.json</code>). </p>"},{"location":"overview_section/game_struct/#library-folders","title":"Library Folders","text":""},{"location":"overview_section/game_struct/#booksbooks_compressed","title":"books/books_compressed","text":"<p>Depending on the compression tag passed to <code>create_books()</code> the <code>books/</code> or <code>books_compressed/</code> folders will be populated with the events emitted from the simulation. </p>"},{"location":"overview_section/game_struct/#configs","title":"configs","text":"<p>This will consist of three <code>.json</code> files for the math, frontend and backend. The details of which are described here.</p>"},{"location":"overview_section/game_struct/#lookup_tables","title":"lookup_tables","text":"<p>Once any given simulation is compete the events associated are stored within the books, and the corresponding payout details are recorded in a lookup table of the format:</p> Simulation Weight Payout <code>int</code> <code>int</code> <code>float</code> <p>All simulations start with an assigned weight of <code>1</code>, which is then modified if the optimization algorithm is applied. </p>"},{"location":"overview_section/game_struct/#configs_1","title":"Configs","text":"<p>The GameConfig inherits the Config class. All information defined in the init function are required inputs. Symbol information, pay-tables, reels-strips and bet-mode information are all specified here. </p>"},{"location":"overview_section/game_struct/#gamestate","title":"Gamestate","text":"<p>Every game has a gamestate.py file, where independent simulation states are handled. The run_spin() function is required and used as the entry_point from create_books to execute the a single simulation. run_freespin is also used in all sample games, though is not a required function if the game does not contain a free-spin entry from the base-game.</p>"},{"location":"overview_section/game_struct/#executables","title":"Executables","text":"<p>Commonly used groups of game-logic and event emission is provided in this location. Functions called in the run_spin() functions will typically belong to the Executables/GameExecutables classes. </p> <p>Functions currently in this class include drawing random or forced game-boards, handling game-logic for several win-types and their associated win information events, updating and </p>"},{"location":"overview_section/game_struct/#misc-calculations","title":"Misc. Calculations","text":"<p>The Executables class inherits all miscellaneous game-logic and board-actions. Primarily this includes all win-evaluation types:  * Lines  * Ways  * Scatter (pay anywhere)  * Cluster   * Expanding wild + prize collection</p> <p>Additionally other classes attached to Executables are tumbling/cascading of winning symbols and Conditions for checking the current simulation state</p>"},{"location":"overview_section/state_overview/","title":"The State Machine","text":""},{"location":"overview_section/state_overview/#introduction","title":"Introduction","text":"<p>When initializing a simulation batch, the GameState class serves as a central hub that manages all simulation aspects, including:</p> <ul> <li>Simulation parameters</li> <li>All game modes</li> <li>Configuration settings</li> <li>Simulation results</li> <li>Output files</li> </ul> <p>This class acts as a super-class, ensuring shared components across all simulations. The entry point for all game simulations is the <code>run.py</code> file, which sets up parameters through the Config class and initializes a GameState object. The GameState handles crucial aspects such as:</p>"},{"location":"overview_section/state_overview/#simulation-configuration","title":"Simulation Configuration","text":"<ul> <li>Compression</li> <li>Tracing</li> <li>Multithreading</li> <li>Output files</li> <li>Cumulative win manager</li> </ul>"},{"location":"overview_section/state_overview/#game-configuration","title":"Game Configuration","text":"<ul> <li>Betmode details (costs, name, etc..)</li> <li>Paytable</li> <li>Symbols</li> <li>Reelsets</li> </ul> <p>These global <code>GameState</code> attributes remain consistent across all game modes, and simulations. When a simulation runs, <code>run_spin()</code> creates a sub-instance of the General GameState, allowing modifications to game data through the <code>self</code> object. The central idea is that the GameState represents the current state of the simulation. And components within this state are modified directly. This reduces the need to be passing objects back and forth between functions when writing game logic. </p> <p>At a high-level, the structure of the engine is shown:  </p> <p>There is a super-class containing essentially all core functionality. When setting up a custom game, these events will extend (or override) the core functionality as per Python's Method Resolution Order (MRO). This <code>GameState</code> class is then used to keep track of simulation details. Once complete, all relevant output files are generated sequentially for each BetMode. Finally these outputs can be used for optimization before being uploaded/published to the Admin Control Panel (ACP).</p>"},{"location":"overview_section/state_overview/#class-inheritance","title":"Class Inheritance","text":""},{"location":"overview_section/state_overview/#why-use-class-inheritance","title":"Why Use Class Inheritance?","text":"<p>Class inheritance ensures flexibility, allowing developers to access core functions while customizing specific behaviors for each game. Core functions are found in the Source Files section and can be overridden at the game level.</p>"},{"location":"overview_section/state_overview/#gamestateoverride-gamegame_overridepy","title":"GameStateOverride (game/game_override.py)","text":"<p>This class is the first in the Method Resolution Order (MRO) and is responsible for modifying or extending actions from the <code>state.py</code> file. All sample games override the <code>reset_book()</code> function to accommodate game-specific parameters.</p> <p>Example:</p> <pre><code>def reset_book(self):\n    super().reset_book()\n    self.reset_grid_mults()\n    self.reset_grid_bool()\n    self.tumble_win = 0\n</code></pre> <p>Each game has unique rules, such as cluster multipliers or cascading wins, which are set here.</p>"},{"location":"overview_section/state_overview/#gameexecutables-gamegame_executablespy","title":"GameExecutables (game/game_executables.py)","text":"<p>Executable functions group multiple game actions together. These functions can be overridden to introduce new mechanics at the game level.</p> <p>In the case of triggering freespins, for example. Generally the number of scatters active on a game-board would be counted and the appropriate number of spins are assigned from the config file definition:</p> <pre><code>config.freespin_triggers = {3:8 ,4:10, 5:12}\n</code></pre> <p>Where 3 scatters award 8 spins etc... This is a commonly carried out procedure, so there is a function in <code>Executables.update_freespin_amount()</code> to assign freespins,</p> <pre><code>    def update_freespin_amount(self, scatter_key: str = \"scatter\") -&gt; None:\n        self.tot_fs = self.config.freespin_triggers[self.gametype][self.count_special_symbols(scatter_key)]\n        fs_trigger_event(self, basegame_trigger=True, freegame_trigger=False)\n</code></pre> <p>However in the <code>0_0_scatter</code> sample game, we would instead want to assign the total spins to be 2x the number of active Scatters. Therefore we can override the function in the <code>GameExecutables</code> class:</p> <pre><code>def update_freespin_amount(self, scatter_key: str = \"scatter\"):\n    self.tot_fs = self.count_special_symbols(scatter_key) * 2\n    fs_trigger_event(self, basegame_trigger=basegame_trigger, freegame_trigger=freegame_trigger)\n</code></pre>"},{"location":"overview_section/state_overview/#gamecalculations-gamesgame_calculationspy","title":"GameCalculations (games/game_calculations.py)","text":"<p>This class handles game-specific calculations, inheriting from GameExecutables.</p>"},{"location":"overview_section/state_overview/#books-and-libraries","title":"Books and Libraries","text":""},{"location":"overview_section/state_overview/#what-is-a-book","title":"What is a \"Book\"?","text":"<p>A \"book\" represents a single simulation result, storing: - The payout multiplier - Events triggered during the round - Win conditions</p> <p>Each simulation generates a Book object, which is stored in a library and subsequently attached to the global GameState object. The contents of book.events is the data returned from the RGS play/ API.</p> <p>Example JSON structure:</p> <pre><code>[\n    {\n        \"id\": int,\n        \"payoutMultiplier\": float,\n        \"events\": [ {}, {}, {} ],\n        \"criteria\": str,\n        \"baseGameWins\": float,\n        \"freeGameWins\": float\n    }\n]\n</code></pre> <p>At the start of a simulation, the book is reset:</p> <pre><code>def reset_book(self) -&gt; None:\n    self.book = {\n        \"id\": self.sim + 1,\n        \"payoutMultiplier\": 0.0,\n        \"events\": [],\n        \"criteria\": self.criteria,\n    }\n</code></pre> <p>At the end of a round, if all win criteria are satisfied, the book is added to the library. For more details, see BetMode.</p>"},{"location":"overview_section/state_overview/#lookup-tables","title":"Lookup Tables","text":"<p>The payoutMultipler attached to a book represents the final amount paid to the player, inclusive or basegame and freegame wins. The LookUpTable csv file is a summary of all simulation payouts. This provides a convenient way to calculate win distribution properties and Return To Player calculations. All lookup tables will be of the format:</p> Simulation Number Simulation Weight Payout Multiplier 1 1 0.0 2 1 92.3 ... ... ... <p>All files generated from the Math Engine will have the prefix <code>lookUpTable_mode.csv</code>. This is the file consumed by the optimization algorithm, which has the effect of modifying the weight values, which are initially set to <code>1</code>. Optimized lookup tables will have the prefix <code>lookUpTable_mode_0.csv</code></p>"},{"location":"sample_section/sample_games/","title":"Sample Games","text":"<p>There are 4 example games included to showcase different win-types and mechanics. All games have a basegame mode (all 1x bet cost) and 1 freegame mode. The expanding wilds game additionally has a superspin mode to showcase how prize-values are handled.</p> <p>Each game-type has a readme.txt file with a brief description of game-rules (copied below).</p>"},{"location":"sample_section/sample_games/#lines-games","title":"Lines Games","text":"<p>This is an example of a simple lines-game-win</p> <p>Wilds have multipliers in the freeGame and have the effect of multiplying a given line win the addition multiplier values attached to Wild symbols,  only when the multiplier value is &gt; 1.</p>"},{"location":"sample_section/sample_games/#basegame","title":"Basegame:","text":"<p>Scatter Symbols appear on all reels, a minimum of 3 Scatters are needed to trigger the Freegame</p>"},{"location":"sample_section/sample_games/#freegame","title":"FreeGame:","text":"<p>A seperate reelset is used for the freegame  Wilds have larger multipliers in the freegame (minimum of 2x) and appear on all reels 2 Scatters are needed to trigger extra spins, appearing only on reels 2,3,4</p> <p>Notes: Wilds only pay on 5-Kind. If the paytable is chosen such that 3/4 Kind Wilds pay, the line calculation will assign the highest base-win symbols as winning. For example if there is a 3-Kind Wild is on the same line as a 5-Kind L4, the 3-Kind wild will be chosen, regardless of the multiplier on the final Wild since the base payout 3W &gt; 5L4</p>"},{"location":"sample_section/sample_games/#ways-game","title":"Ways Game","text":"<p>Standard ways game with 5-reels and 3-rows. </p> <ul> <li>9 paying symbols (H1-H5, L1-L4)</li> <li>1 wild type of Wild symbol</li> <li>1 type of Scatter symbol</li> <li>Multipliers on Wilds (in freegame only)</li> <li>Wilds do not appear on 1st reel</li> </ul>"},{"location":"sample_section/sample_games/#basegame_1","title":"Basegame","text":"<p>Minimum of 3 Scatter symbols are needed to enter the freegame. Maximum of 1 Scatter per reel.</p>"},{"location":"sample_section/sample_games/#freegame-rules","title":"Freegame rules","text":"<p>Wild symbols have multipliers ranging from 1x to 5x. Multiplier values compound multiplicitivly (unlike lines games where multiplier values add)</p>"},{"location":"sample_section/sample_games/#cluster-based-win-game","title":"Cluster-based win game","text":"<p>Clusters of 5 or more like-symbols are removed from the board, and symbols above on the reelstrip fall to fill their place.</p>"},{"location":"sample_section/sample_games/#basegame_2","title":"Basegame:","text":"<p>Standard tumbling game with Scatter and Wild symbols. Minimum of 4 Scatter symbols are required for freeSpin triggers</p>"},{"location":"sample_section/sample_games/#freegame_1","title":"Freegame:","text":"<p>Same basegame rule, except grid positions have multipliers. Grid positions start in a 'deactivated' state. Once one win occurs, the position is 'activated' starting with a 1x multiplier - for every winning cluster, the multiplier value at that position is doubled (up to 512x) There is a global multiplier, which increases by +1 for every freespin and does not reset on each spin A minimum of 3 scatters are required for re-triggers</p>"},{"location":"sample_section/sample_games/#notes","title":"Notes:","text":"<p>Because of the separation between basegame and freegame types - there is an additional freespin entry check to check of the criteria requires a forced  freespin condition. Otherwise, occurences of Scatter symbols tumbling onto the board during basegame criteria may appear.</p>"},{"location":"sample_section/sample_games/#scatter-pays-game","title":"Scatter-Pays Game","text":""},{"location":"sample_section/sample_games/#summary","title":"Summary:","text":"<ul> <li>A 6-reel, 5-row pay-anywhere tumbling (cascading) game.</li> <li>8 paying total (4 high, 4 low)</li> <li>2 special symbols (wild, scatter)</li> </ul> <p>Symbols payouts are grouped by cluster-sizes (8-8), (9-10), (11,13), (14,36)</p>"},{"location":"sample_section/sample_games/#basegame_3","title":"Basegame:","text":"<p>Minimum of 3 Scatter symbols needed for freegame trigger.  2 freegame spins are awarded for each Scatter. </p>"},{"location":"sample_section/sample_games/#freegame-rules_1","title":"Freegame rules","text":"<p>Every tumble increments the global multiplier by +1, which is persistent throughout the freegame The global multiplier is applied to the tumble win as they are removed from the board After all tumbles have completed: multiply the cumulative tumble win by multipliers on board  (multipliers on board do not increment the global mult) If there is a multiplier symbol on the board, this is added to the global multiplier before the final evaluation</p>"},{"location":"sample_section/sample_games/#notes_1","title":"Notes","text":"<p>Due to the potential for symbols to tumble into the active board area, there is no upper limit on the number of freegame that can be awarded. The total number of freegame is 2 * (number of Scatters on board). To account for this the usual 'updateTotalFreeSpinAmount' function is overridden  in the game_executables.py file.</p>"},{"location":"sample_section/sample_games/#event-descriptions","title":"Event descriptions","text":"<p>\"winInfo\" Summarises winning combinations. Includes multipliers, symbol positions, payInfo [passed for every tumble event] \"tumbleBanner\" includes values from the cumulative tumble, with global mult applied \"setWin\" this the result for the entire spin (from on Reveal to the next). Applied after board has stopped tumbling \"seTotalWin\" the cumulative win for a round. In the base-game this will be equal to the setWin, but in the bonus it will incrementally increase </p>"},{"location":"sample_section/sample_games/#expanding-wilds-lines-superspin-mode","title":"Expanding Wilds Lines + Superspin mode","text":"<ul> <li>5-reel, 5-rows</li> <li>15 paylines</li> <li>9 paying symbols</li> <li>1 type of Wild</li> <li>1 type of scatter </li> </ul> <p>Superspin mode, costing 25x. This mode is independent, with no freegame entry. </p> <ul> <li>1 dead symbol (1)</li> <li>1 prize symbol </li> </ul>"},{"location":"sample_section/sample_games/#basegame_4","title":"basegame","text":"<p>Standard lines games rules with Wilds paying on 3, 4 and 5-kind </p>"},{"location":"sample_section/sample_games/#freegame_2","title":"freegame","text":"<p>1 Wild can initially appear on each reel. Symbol then expands out to fill all active rows. Expanded symbol is sticky and persistent for all remaining freegame spins. On each new reveal a random multiplier ranging from 2x - 50x is assigned. No retriggers in freegame. </p>"},{"location":"sample_section/sample_games/#superspin","title":"superspin","text":"<p>This is a hold em' style game. The player can purchase a spin for 25x, and starts with 3 lives Each time a prize symbol lands on the board, the 3 avaliable spins reset.  Prizes are sticky and evaluated once the player has no new spins remaining. </p> <p>This game has a purchase-only 'super-spin' mode. This mode can only be activated through a buy menu and cannot be accessed using Scatters like bonus-games</p>"},{"location":"source_section/board_info/","title":"Board","text":""},{"location":"source_section/board_info/#game-board","title":"Game Board","text":"<p>The <code>Board</code> class inherits the <code>GeneraGameState</code> class and handles the generation of game boards. Most commonly used is the <code>create_board_reelstrips()</code> function. Which selects a reelset as defined in the <code>BetMode.Distribution.conditions</code> class. For each reel a random stopping position is chosen with uniform probability on the range [0,len(reelstrip[reel])-1]. For each reelstop a 2D list of <code>Symbol</code> objects are created and attached to the GameState object. </p> <p>Additionally, special symbol information is included (special_symbols_on_board) along with the reelstop values (reel_positions), padding symbols directly above and below the active board (padding_positions) and which reelstip-id was used.</p> <p>The is also an anticipation field which is used for adding a delay to reel reveals if the number of Scatters required for trigging the freegame is almost satisfied. This is an array of values initialized to <code>0</code> and counting upwards in <code>+1</code> value increments. For example if 3 Scatter symbols are needed to trigger the freegame and there are Scatters revealed on reels 0 and 1, the array would take the form (for a 5 reel game):</p> <pre><code>self.anticipation = [0, 0, 1, 2, 3]\n</code></pre> <p>If the selected reel_pos + the length of the board is greater than the total reelstrip length, the stopping position is wrapped around to the 0 index:</p> <pre><code> self.reelstrip[reel][(reel_pos - 1) % len(self.reelstrip[reel])]\n</code></pre> <p>The reelset used is drawn from the weighted possible reelstrips as defined in the <code>BetMode.betmode.distributions.conditions</code> class (and hence is a required field in the <code>BetMode</code> object):</p> <pre><code>    self.reelstrip_id = get_random_outcome(\n        self.get_current_distribution_conditions()[\"reel_weights\"][self.gametype]\n    )\n</code></pre> <p>Specific stopping positions can also be forced given a reelstip-id and integer stopping values from <code>force_board_from_reelstrips()</code>. If no integer value are provided for a reel, a random position is chosen. This function is typically used in conjunction with <code>executables.force_special_board</code>, which will search a reelstrip for a particular symbol name and randomly select a specified number of stopping positions, chosen to land on a randomly selected board row. </p> <p>Additionally the <code>Board</code> class handled symbol generation, displaying the current <code>.board</code> in the terminal, and retrieving symbol positions and properties as defined in <code>config.special_symbols</code>. </p>"},{"location":"source_section/cluster_info/","title":"Cluster Pays","text":"<p>Cluster games award wins when there are sufficiently many neighbouring like-symbols. Neighbours must share the same reel or row, where diagonal connections do not count towards the cluster size. A minimum of 5 like-symbols is typical, though this can be defined in <code>GameConfig</code> class. Since it is possible for up to <code>num_rows * num_columns</code> winning symbols to occur, it is common to define a particular payout range. For example <code>5 kind</code> pays <code>p1</code> <code>6-7 kind</code> to pay <code>p2</code>, <code>8-10 kind</code> to pay <code>p3</code> and <code>12+</code> symbols pay <code>p4</code> etc... Instead of manually including all possible pay combinations in <code>config.paytable</code> there is a <code>convert_range_table()</code> function in the Config class which takes in a symbol range, name and payout amount which is used to generate all <code>config.paytable</code> entries. This pay group should be of the format:</p> <pre><code>    paygroup = {\n        ((min_combination[int], max_combination[int]), name[str]) : payout[float],\n        ... \n    }\n\n</code></pre> <p>Ranges defined in <code>min_combination</code> and <code>max_combination</code> are inclusive, so for example if the <code>5-kind</code> payout for symbol <code>H1</code> pays <code>10x</code>, this would be written as: <code>((5,5),H1): 10</code>.</p> <p>Often (though not always) cluster pays games include a tumbling mechanic. Within the cluster sample game for example, while there are still winning combinations, the board is tumbled, wins are evaluated for the new board, the wallet manager is updated and relevent events are emitted:</p> <pre><code>    while self.win_data[\"totalWin\"] &gt; 0 and not (self.wincap_triggered):\n        self.tumble_game_board()\n        self.win_data = self.get_cluster_data(record_wins=True)\n        self.win_manager.update_spinwin(self.win_data[\"totalWin\"])\n        self.emit_tumble_win_events()\n</code></pre> <p>Clusters are found using a Breath First Search (BFS) algorithm. Wild attributes can be set (<code>wild</code> is the default value). Wild symbols can contribute to multiple clusters, including those formed by different symbols. </p>"},{"location":"source_section/config_info/","title":"Config class object","text":"<p>The game-specific configuration <code>GameConfig</code> inherits the <code>Config</code> super class. This contains all game specifications, many of which will be set manually for each new game within <code>GameConfig</code>. <code>Config</code> allows for setting custom <code>win_levels</code>, which are returned during win-events and can indicate the type of animation which needs to be played. Additionally the class sets up several path destinations used for writing files and functions to read in and verify reelstrips stored in the <code>.csv</code> format. </p>"},{"location":"source_section/event_info/","title":"Events Module Documentation","text":""},{"location":"source_section/event_info/#overview","title":"Overview","text":"<p>The <code>events.py</code> module defines reusable game events that modify the <code>gamestate</code> and log significant actions. These events ensure proper tracking of game states and facilitate structured client communication.</p>"},{"location":"source_section/event_info/#functions","title":"Functions","text":""},{"location":"source_section/event_info/#json_ready_symsymbol-special_attributes","title":"<code>json_ready_sym(symbol, special_attributes)</code>","text":"<p>Purpose: Converts a symbol object into a dictionary suitable for JSON serialization, including only specified attributes.</p> <p>Parameters: - <code>symbol (object)</code>: The symbol object to convert. - <code>special_attributes (list)</code>: A list of attribute names to include if they are not <code>False</code>.</p>"},{"location":"source_section/event_info/#reveal_eventgamestate","title":"<code>reveal_event(gamestate)</code>","text":"<p>Purpose: Logs the initial board state, including padding symbols if enabled.</p>"},{"location":"source_section/event_info/#fs_trigger_eventgamestate-include_padding_index-basegame_trigger-freegame_trigger","title":"<code>fs_trigger_event(gamestate, include_padding_index, basegame_trigger, freegame_trigger)</code>","text":"<p>Purpose: Logs the triggering of free spins, whether from the base game or a retrigger event.</p> <p>Assertions: - Either <code>basegame_trigger</code> or <code>freegame_trigger</code> must be <code>True</code>, not both. - <code>gamestate.tot_fs</code> must be greater than 0.</p>"},{"location":"source_section/event_info/#set_win_eventgamestate-winlevel_keystandard","title":"<code>set_win_event(gamestate, winlevel_key='standard')</code>","text":"<p>Purpose: Updates the cumulative win amount for a single outcome.</p>"},{"location":"source_section/event_info/#set_total_eventgamestate","title":"<code>set_total_event(gamestate)</code>","text":"<p>Purpose: Updates the total win amount for a betting round, including all free spins.</p>"},{"location":"source_section/event_info/#set_tumble_eventgamestate","title":"<code>set_tumble_event(gamestate)</code>","text":"<p>Purpose: Logs wins from consecutive tumbles.</p>"},{"location":"source_section/event_info/#wincap_eventgamestate","title":"<code>wincap_event(gamestate)</code>","text":"<p>Purpose: Emits an event when the maximum win amount is reached, stopping further spins.</p>"},{"location":"source_section/event_info/#win_info_eventgamestate-include_padding_indextrue","title":"<code>win_info_event(gamestate, include_padding_index=True)</code>","text":"<p>Purpose: Logs winning symbol positions and their win amounts, adjusting for padding if enabled.</p>"},{"location":"source_section/event_info/#update_tumble_win_eventgamestate","title":"<code>update_tumble_win_event(gamestate)</code>","text":"<p>Purpose: Updates the banner for tumble win amounts.</p>"},{"location":"source_section/event_info/#update_freespin_eventgamestate","title":"<code>update_freespin_event(gamestate)</code>","text":"<p>Purpose: Logs the current and total free spins remaining.</p>"},{"location":"source_section/event_info/#freespin_end_eventgamestate-winlevel_keyendfeature","title":"<code>freespin_end_event(gamestate, winlevel_key='endFeature')</code>","text":"<p>Purpose: Logs the end of a free spin feature and assigns the final win level.</p>"},{"location":"source_section/event_info/#final_win_eventgamestate","title":"<code>final_win_event(gamestate)</code>","text":"<p>Purpose: Logs the final payout multiplier at the end of a simulation.</p>"},{"location":"source_section/event_info/#update_global_mult_eventgamestate","title":"<code>update_global_mult_event(gamestate)</code>","text":"<p>Purpose: Logs changes to the global multiplier.</p>"},{"location":"source_section/event_info/#tumble_board_eventgamestate","title":"<code>tumble_board_event(gamestate)</code>","text":"<p>Purpose: Logs symbol positions removed during a tumble and their replacements.</p>"},{"location":"source_section/event_info/#usage-notes","title":"Usage Notes","text":"<ul> <li>Each function appends an event dictionary to <code>gamestate.book['events']</code>.</li> <li>Deep copies ensure that modifications do not affect past event states.</li> <li>Events provide structured output suitable for UI updates and analytics.</li> </ul> <p>This module is essential for maintaining a transparent, trackable game state across different game mechanics.</p>"},{"location":"source_section/executables_info/","title":"Executables Class Documentation","text":""},{"location":"source_section/executables_info/#overview","title":"Overview","text":"<p>The <code>Executables</code> class groups together common actions that are likely to be reused across multiple games. These functions can be overridden in <code>GameExecutables</code> or <code>GameCalculations</code> if game-specific alterations are required. Generally, <code>Executables</code> functions do not return values.</p>"},{"location":"source_section/executables_info/#function-descriptions","title":"Function Descriptions","text":""},{"location":"source_section/executables_info/#draw_boardemit_event-bool-true-none","title":"<code>draw_board(emit_event: bool = True) -&gt; None</code>","text":"<p>Forces the initial reveal to have a specific number of scatters if bet mode criteria specify it. Otherwise, it generates a new board and ensures it does not contain more scatters than necessary.</p>"},{"location":"source_section/executables_info/#force_special_boardforce_criteria-str-num_force_syms-int-none","title":"<code>force_special_board(force_criteria: str, num_force_syms: int) -&gt; None</code>","text":"<p>Forces a board to have a specified number of a particular symbol by modifying reel stops.</p>"},{"location":"source_section/executables_info/#get_syms_on_reelreel_id-str-target_symbol-str-listlist","title":"<code>get_syms_on_reel(reel_id: str, target_symbol: str) -&gt; List[List]</code>","text":"<p>Returns reel stop positions for a specific symbol name.</p>"},{"location":"source_section/executables_info/#emit_wayswin_events-none","title":"<code>emit_wayswin_events() -&gt; None</code>","text":"<p>Transmits win events associated with ways wins.</p>"},{"location":"source_section/executables_info/#emit_linewin_events-none","title":"<code>emit_linewin_events() -&gt; None</code>","text":"<p>Transmits win events associated with line wins.</p>"},{"location":"source_section/executables_info/#emit_tumble_win_events-none","title":"<code>emit_tumble_win_events() -&gt; None</code>","text":"<p>Transmits win and new board information upon a tumble event.</p>"},{"location":"source_section/executables_info/#tumble_game_board-none","title":"<code>tumble_game_board() -&gt; None</code>","text":"<p>Removes winning symbols from the active board and replaces them, triggering a tumble board event.</p>"},{"location":"source_section/executables_info/#evaluate_wincap-none","title":"<code>evaluate_wincap() -&gt; None</code>","text":"<p>Checks if the running bet win has reached the wincap limit and stops further spin functions if necessary.</p>"},{"location":"source_section/executables_info/#count_special_symbolsspecial_sym_criteria-str-int","title":"<code>count_special_symbols(special_sym_criteria: str) -&gt; int</code>","text":"<p>Returns the number of active symbols of a specified special kind.</p>"},{"location":"source_section/executables_info/#check_fs_conditionscatter_key-str-scatter-bool","title":"<code>check_fs_condition(scatter_key: str = \"scatter\") -&gt; bool</code>","text":"<p>Checks if there are enough active scatters to trigger free spins.</p>"},{"location":"source_section/executables_info/#check_freespin_entryscatter_key-str-scatter-bool","title":"<code>check_freespin_entry(scatter_key: str = \"scatter\") -&gt; bool</code>","text":"<p>Ensures that the bet mode criteria are expecting a free spin trigger before proceeding.</p>"},{"location":"source_section/executables_info/#run_freespin_from_basescatter_key-str-scatter-none","title":"<code>run_freespin_from_base(scatter_key: str = \"scatter\") -&gt; None</code>","text":"<p>Triggers the free spin function and updates the total number of free spins available.</p>"},{"location":"source_section/executables_info/#update_freespin_amountscatter_key-str-scatter-none","title":"<code>update_freespin_amount(scatter_key: str = \"scatter\") -&gt; None</code>","text":"<p>Sets the initial number of spins for a free game and transmits an event.</p>"},{"location":"source_section/executables_info/#update_fs_retrigger_amtscatter_key-str-scatter-none","title":"<code>update_fs_retrigger_amt(scatter_key: str = \"scatter\") -&gt; None</code>","text":"<p>Updates the total number of free spins available when a retrigger occurs.</p>"},{"location":"source_section/executables_info/#update_freespin-none","title":"<code>update_freespin() -&gt; None</code>","text":"<p>Called before a new reveal during free spins, resetting spin win data and other relevant attributes.</p>"},{"location":"source_section/executables_info/#end_freespin-none","title":"<code>end_freespin() -&gt; None</code>","text":"<p>Transmits the total amount awarded during the free spin session.</p>"},{"location":"source_section/executables_info/#evaluate_finalwin-none","title":"<code>evaluate_finalwin() -&gt; None</code>","text":"<p>Checks base and free spin sums, then sets the payout multiplier accordingly.</p>"},{"location":"source_section/executables_info/#update_global_mult-none","title":"<code>update_global_mult() -&gt; None</code>","text":"<p>Increments the multiplier value and emits the corresponding event.</p>"},{"location":"source_section/executables_info/#dependencies","title":"Dependencies","text":"<p>This class relies on multiple external modules, including: - <code>src.state.state_conditions.Conditions</code> - <code>src.calculations.lines.LineWins</code> - <code>src.calculations.cluster.ClusterWins</code> - <code>src.calculations.scatter.ScatterWins</code> - <code>src.calculations.ways.WaysWins</code> - <code>src.calculations.tumble.Tumble</code> - <code>src.calculations.statistics.get_random_outcome</code> - <code>src.events.events</code> (Various event handling functions)</p> <p>These modules provide necessary game logic, event management, and mathematical calculations for the execution of the class functions.</p>"},{"location":"source_section/executables_info/#usage","title":"Usage","text":"<p>This class is designed as a base class and is expected to be extended by game-specific implementations where needed. It ensures core game mechanics, such as board generation, free spin handling, and win event management, are handled in a reusable manner.</p>"},{"location":"source_section/file_info/","title":"Output files","text":"<p>All relevant output files are automatically generated within the <code>game/library/</code> directories. If the required sub-directories do not exist, the will be automatically generated.</p>"},{"location":"source_section/file_info/#books","title":"Books","text":"<p>The primary data file output when simulations are run are the book files. These contain summary simulation information such as the final payout multiplier, basegame and freegame win contributions, the simulation criteria and simulation events. The contents of <code>book.events</code> is the information returned by the RGS <code>play/</code> API response. </p> <p>The uncompressed <code>books/</code> files are used within the front-end testing framework and should be used to debug events. Only a small number of simulations should be run due to the file size. Compressed book files are what is uploaded to <code>AWS</code> and consumed by the RGS when games are being uploaded. Only data from compressed books will be returned from the <code>play/</code> API.</p>"},{"location":"source_section/file_info/#force-files","title":"Force files","text":"<p>Each bet mode will output a file of the format <code>force_mode.json</code>. Every time the <code>.record()</code> function is called, the decription keys used as input are appended to the file. If the key already exists, the <code>book-id</code> is appended to the array. This file is used to count instances of particular events. The optimisation algorithm also makes use of these keys to identify max-win and freegame books. Once all bet mode simulations are finished, a <code>force.json</code> file is output which contains all the unique fields and keys.</p>"},{"location":"source_section/file_info/#lookup-tables","title":"Lookup tables","text":"<p>The final payout multiplier for each simulation is summarised in the <code>lookUpTable_mode.csv</code>. This is the file accessed by the optimization algorithm, which works by adjusting the weights, initially assigned to <code>1</code>. There is also a <code>IdToCriteria</code> file which indicates the win criteria required by a specific simulation number, and a <code>Segmented</code> file used to identify what gametype contributed to the final payout multiplier. Both these additional files are not typically uploaded to the ACP and are instead used for various analysis functions.</p>"},{"location":"source_section/file_info/#config-files","title":"Config files","text":"<p>There are three config files generated after all simulations and optimizations are run. <code>config_math.json</code> is used by the optimization algorithm and contains all relevant bet mode details, RTP splits and optimization parameters. <code>config_fe.json</code> is used by the front-end frame work and contains symbol information, padding reels and bet mode details which need to be displayed to players. <code>config.json</code> contains bet mode information and file hash information and used used by the RGS to determine and verify changes to files being uploaded to the ACP.</p>"},{"location":"source_section/lines_info/","title":"Line wins evaluation","text":"<p>The <code>LinesWins</code> object evaluates winning symbol combinations for the current <code>self.board</code> state. Generally 3 or more consecutive symbols result in a win, though these specific combination numbers and payouts can be defined in:</p> <pre><code>config.paytable = {(kind[int], symbol[string]): payout[float]}\n</code></pre> <p>In order to identify winning lines, line arrays must be defined in:</p> <pre><code>config.paylines = {\n    0: [0,0,0,0,0],\n    1: [0,1,0,1,0],\n        ...    \n    }\n</code></pre> <p>in the <code>.paylines</code> dictionary, the key is the line-index and the value is an array dictating which rows result in a winning combination. Like symbols are matched and if the key <code>(kind, name)</code> exists in <code>self.paytable</code>, the corresponding win is evaluated. </p> <p>Custom keys used to identify wild attributes and symbol names can be explicitly set and will default to <code>\"wild\"</code> and <code>\"W\"</code> unless otherwise specified. In the case of <code>(kind, \"W\")</code> existing in <code>self.paytable</code>, the base payout value is checked against the <code>(kind, sym)</code> where sym is the first non-wild. If for example the payline <code>[0,0,0,0,0]</code> has the symbol combination <code>[W,W,W,L4,L4]</code>, resulting in wins <code>(3,\"W\")</code> or <code>(5,\"L4\")</code>. We compare both outcomes and determine that the three-kind Wild combination has a larger payout. Therefore we only take the first three symbols as the winning combination. Note that the sample lines calculation provided will only take into account the base-game wins. If the game is more complex, such as having multipliers on symbols, the final payout amount may need to be handled separately when deciding which winning combination to use. One common approach to dealing with this is to only define the Wild symbols to pay when there is a complete line (so only 5-kind Wilds would pay for a board of this size).</p> <p>The <code>get_lines()</code> evaluation function returns all win information including the winning symbol name, winning positions, number of consecutive matches and win amounts. The <code>meta</code> information also includes symbol and global multiplier information, as well as the index of winning lines as defined in `config.paylines = {index: [line], ... }. </p>"},{"location":"source_section/scatter_info/","title":"Scatter Pays","text":"<p>Scatter-pays (pay-anywhere) games award wins based on the total number of like-symbols appearing on the game board. Symbols do not have to be arranged in any order. Typically a minimum of 8 like-symbols (or Wilds) are required to count as a win, though these values can be defined in the <code>GameConfig</code> class. Since it is possible for up to <code>num_rows * num_columns</code> winning symbols to occur, it is common to define a particular payout range. For example <code>8-kind</code> pays <code>p1</code> <code>9-kind</code> to pay <code>p2</code>, <code>10-12</code> kind to pay <code>p3</code> and <code>12+</code> symbols pay <code>p4</code> etc... Instead of manually including all possible pay combinations in <code>config.paytable</code> there is a <code>convert_range_table()</code> function in the Config class which takes in a symbol range, name and payout amount which is used to generate all <code>config.paytable</code> entries. This pay group should be of the format:</p> <pre><code>    paygroup = {\n        ((min_combination[int], max_combination[int]), name[str]) : payout[float],\n        ... \n    }\n\n</code></pre> <p>Ranges defined in <code>min_combination</code> and <code>max_combination</code> are inclusive, so for example if the <code>8-kind</code> payout for symbol <code>H1</code> pays <code>10x</code>, this would be written as: <code>((8,8),H1): 10</code>.</p> <p>Often (though not always) Scatter pays games are also cascading/tumbling. Within the scatter sample game for example, while there are still winning combinations, the board is tumbled, wins are evaluated for the new board, the wallet manager is updated and relevent events are emitted:</p> <pre><code>    while self.win_data[\"totalWin\"] &gt; 0 and not (self.wincap_triggered):\n        self.tumble_game_board()\n        self.win_data = self.get_scatterpay_wins(record_wins=True)\n        self.win_manager.update_spinwin(self.win_data[\"totalWin\"])\n        self.emit_tumble_win_events()\n</code></pre> <p>The Scatter pay evaluation function also checks for <code>multiplier</code> and <code>wild</code> attributes attached to symbols. Wild symbols can contribute to wins for any number of symbols. </p>"},{"location":"source_section/state_info/","title":"GeneralGameState Class Overview","text":""},{"location":"source_section/state_info/#class-generalgamestate","title":"Class: <code>GeneralGameState</code>","text":""},{"location":"source_section/state_info/#description","title":"Description:","text":"<p>The <code>GeneralGameState</code> class is an abstract base class (ABC) that defines the general structure for game states. Other game state classes inherit from it. It includes methods for initializing game configurations, resetting states, managing wins, and running simulations.</p>"},{"location":"source_section/state_info/#constructor","title":"Constructor:","text":""},{"location":"source_section/state_info/#__init__self-config","title":"<code>__init__(self, config)</code>","text":"<ul> <li>Initializes the game state with the provided configuration.</li> <li>Initializes variables like <code>library</code>, <code>recorded_events</code>, <code>special_symbol_functions</code>, <code>win_manager</code>, <code>criteria</code>, etc.</li> <li>Calls helper methods to reset seeds, create symbol mappings, reset book values, and assign special symbol functions.</li> </ul>"},{"location":"source_section/state_info/#methods","title":"Methods:","text":""},{"location":"source_section/state_info/#create_symbol_mapself-none","title":"<code>create_symbol_map(self) -&gt; None</code>","text":"<ul> <li>Extracts all valid symbols from the configuration.</li> <li>Constructs a <code>SymbolStorage</code> object containing all the symbols from the paytable and special symbols.</li> </ul>"},{"location":"source_section/state_info/#assign_special_sym_functionself-abstract-method","title":"<code>assign_special_sym_function(self)</code> (Abstract Method)","text":"<ul> <li>This method must be overridden in derived classes to define custom symbol behavior.</li> <li>Issues a warning if no special symbol functions are defined.</li> </ul>"},{"location":"source_section/state_info/#reset_bookself-none","title":"<code>reset_book(self) -&gt; None</code>","text":"<ul> <li>Resets global game state variables such as <code>board</code>, <code>book_id</code>, <code>book</code>, and <code>win_data</code>.</li> <li>Initializes default values for win tracking and spin conditions.</li> <li>Resets <code>win_manager</code> state.</li> </ul>"},{"location":"source_section/state_info/#reset_seedself-sim-int-0-none","title":"<code>reset_seed(self, sim: int = 0) -&gt; None</code>","text":"<ul> <li>Resets the random number generator seed based on the simulation number for reproducibility.</li> </ul>"},{"location":"source_section/state_info/#reset_fs_spinself-none","title":"<code>reset_fs_spin(self) -&gt; None</code>","text":"<ul> <li>Resets the free spin game state when triggered.</li> <li>Updates <code>gametype</code> and resets spin wins in <code>win_manager</code>.</li> </ul>"},{"location":"source_section/state_info/#get_betmodeself-mode_name-betmode","title":"<code>get_betmode(self, mode_name) -&gt; BetMode</code>","text":"<ul> <li>Retrieves a bet mode configuration based on its name.</li> <li>Prints a warning if the bet mode is not found.</li> </ul>"},{"location":"source_section/state_info/#get_current_betmodeself-object","title":"<code>get_current_betmode(self) -&gt; object</code>","text":"<ul> <li>Returns the current active bet mode.</li> </ul>"},{"location":"source_section/state_info/#get_current_betmode_distributionsself-object","title":"<code>get_current_betmode_distributions(self) -&gt; object</code>","text":"<ul> <li>Retrieves the distribution information for the current bet mode based on the active criteria.</li> <li>Raises an error if criteria distribution is not found.</li> </ul>"},{"location":"source_section/state_info/#get_current_distribution_conditionsself-dict","title":"<code>get_current_distribution_conditions(self) -&gt; dict</code>","text":"<ul> <li>Returns the conditions required for the current criteria setup.</li> <li>Raises an error if bet mode conditions are missing.</li> </ul>"},{"location":"source_section/state_info/#get_wincap_triggeredself-bool","title":"<code>get_wincap_triggered(self) -&gt; bool</code>","text":"<ul> <li>Checks if a max-win cap has been reached, stopping further spin progress if triggered.</li> </ul>"},{"location":"source_section/state_info/#in_criteriaself-args-bool","title":"<code>in_criteria(self, *args) -&gt; bool</code>","text":"<ul> <li>Checks if the current win criteria match any of the given arguments.</li> </ul>"},{"location":"source_section/state_info/#recordself-description-dict-none","title":"<code>record(self, description: dict) -&gt; None</code>","text":"<ul> <li>Records specific game events to the <code>temp_wins</code> list for tracking distributions.</li> </ul>"},{"location":"source_section/state_info/#check_force_keysself-description-none","title":"<code>check_force_keys(self, description) -&gt; None</code>","text":"<ul> <li>Verifies and adds unique force-key parameters to the bet mode configuration.</li> </ul>"},{"location":"source_section/state_info/#combineself-modes-betmode_name-none","title":"<code>combine(self, modes, betmode_name) -&gt; None</code>","text":"<ul> <li>Merges forced keys from multiple mode configurations into the target bet mode.</li> </ul>"},{"location":"source_section/state_info/#imprint_winsself-none","title":"<code>imprint_wins(self) -&gt; None</code>","text":"<ul> <li>Records triggered events in the <code>library</code> and updates <code>win_manager</code>.</li> </ul>"},{"location":"source_section/state_info/#update_final_winself-none","title":"<code>update_final_win(self) -&gt; None</code>","text":"<ul> <li>Computes and verifies the final win amount across base and free games.</li> <li>Ensures that total wins do not exceed the win cap.</li> <li>Raises an assertion error if the sum of base and free game payouts mismatches the recorded final payout.</li> </ul>"},{"location":"source_section/state_info/#check_repeatself-none","title":"<code>check_repeat(self) -&gt; None</code>","text":"<ul> <li>Determines if a spin needs to be repeated based on criteria constraints.</li> </ul>"},{"location":"source_section/state_info/#run_spinself-sim-abstract-method","title":"<code>run_spin(self, sim)</code> (Abstract Method)","text":"<ul> <li>Must be implemented in derived classes.</li> <li>Placeholder prints a message if not overridden.</li> </ul>"},{"location":"source_section/state_info/#run_freespinself-abstract-method","title":"<code>run_freespin(self)</code> (Abstract Method)","text":"<ul> <li>Must be implemented in derived classes.</li> <li>Placeholder prints a message if not overridden.</li> </ul>"},{"location":"source_section/state_info/#run_simsself-betmode_copy_list-betmode-sim_to_criteria-total_threads-total_repeats-num_sims-thread_index-repeat_count-compresstrue-write_event_listtrue-none","title":"<code>run_sims(self, betmode_copy_list, betmode, sim_to_criteria, total_threads, total_repeats, num_sims, thread_index, repeat_count, compress=True, write_event_list=True) -&gt; None</code>","text":"<ul> <li>Runs multiple simulations, setting up bet modes and criteria per simulation.</li> <li>Tracks and prints RTP calculations.</li> <li>Writes temporary JSON files for multi-threaded results.</li> <li>Generates lookup tables for criteria and payout distributions.</li> </ul>"},{"location":"source_section/state_info/#summary","title":"Summary","text":"<ul> <li><code>GeneralGameState</code> provides a foundation for defining and managing game states.</li> <li>It includes methods for configuring symbols, handling wins, recording events, and executing game simulations.</li> <li>Certain methods must be overridden in derived classes to customize behavior.</li> </ul>"},{"location":"source_section/tumble_info/","title":"Tumble","text":""},{"location":"source_section/tumble_info/#tumbling-boards","title":"Tumbling boards","text":"<p>The <code>Tumble</code> class inherits <code>Board</code> and handles removing winning symbols from <code>self.board</code> and filling vacant positions with symbols which appear directly above winning positions using the properties <code>reel_positions</code> and <code>reelstrip_id</code>. Examples of applications surrounding tumbling (cascading) events can be found in the <code>0_0_cluster</code> and <code>0_0_scatter</code> sample games. </p> <p>The win evaluation functions for the cluster and scatter win-types assign the property <code>explode = True</code> to winning symbol objects. A new board is select by scanning the current <code>self.board</code> object reel-by-reel and counting the number of symbols which satisfy <code>sym.check_attribute(\"explode\")</code>. This same number of symbols is then appended, counting backwards from the initial <code>self.reel_positions</code> values. If padding symbols are used, the symbol stored in <code>top_symbols</code> will be used to fill the first vacated position. </p>"},{"location":"source_section/ways_info/","title":"Ways wins evaluation","text":"<p>The <code>WaysWins</code> object evaluates winning symbol combinations for the current <code>self.board</code> state. Generally 3 or more consecutive symbols result in a win, though these specific combination numbers and payouts can be defined in:</p> <pre><code>config.paytable = {(kind[int], symbol[string]): payout[float]}\n</code></pre> <p>The ways calculation will search for like-symbols (or Wilds) on consecutive reels. The maximum number of ways is determined from the board size: <code>max_ways = (num_rows)^(num_columns)</code>.  Note: the ways calculation does not account for Wild symbols appearing on the first reel. </p> <p>The Ways evaluation takes also takes into account multiplier values attached to symbols containing the <code>multiplier</code> attribute. Unlike lines calculations where multiplier values are added together for symbols on consecutive reels, the total number of ways is instead multiplied by the multiplier value. Leading to the payout amount to grow substancially more quickly. So for example given the board:</p> <pre><code>L5 H1 L4 L4 L4 \nL1 H4 L3 H2 L4 \nH1 H1 H1 L3 H3 \n</code></pre> <p>If there is a multiplier value of, say 3x on the <code>H1</code> symbol on reel 3, the total ways for symbol <code>H1</code> is <code>(3,H1)</code> pays:</p> <pre><code>(1) * (2) * (3) = 6 ways\n</code></pre> <p>The <code>return_data</code> will include all winning symbol names, number of consecutive like-symbols, winning positions and total win amounts for each unique symbol type. the <code>meta</code> tag will additionally include the total number of ways a symbol wins, which will range from <code>1</code> to <code>(num_rows)^(num_columns)</code> and and additional symbol and/or global multiplier contributions.</p>"},{"location":"source_section/win_manager/","title":"Wallet Manger","text":"<p>When a set of simulations are setup and executed through the <code>src/state/run_sims()</code> function, a new instance of the <code>WinManager</code> class is spawned. This class is responsible for tracking <code>basegame</code> and <code>freegame</code> wins for single simulation rounds (when running <code>run_spin()</code>), and also for cumulative win amounts for a given <code>BetMode</code>. </p> <pre><code>class WinManager:\n    def __init__(self, base_game_mode, free_game_mode):\n        self.base_game_mode = base_game_mode\n        self.free_game_mode = free_game_mode\n\n        self.total_cumulative_wins = 0\n        self.cumulative_base_wins = 0\n        self.cumulative_free_wins = 0\n\n        self.running_bet_win = 0.0\n\n        self.basegame_wins = 0.0\n        self.freegame_wins = 0.0\n\n        self.spin_win = 0.0\n        self.tumble_win = 0.0\n</code></pre>"},{"location":"source_section/win_manager/#cumulative-wins","title":"Cumulative wins","text":"<p>The cumulative win-amounts are useful in the terminal printouts to quickly check the RTP splits for a given multiprocessing thread. These cumulative values are updated each time a simulation is run and successfully passed, within <code>state.imprint_wins()</code> basegame and freegame win amounts are updated using <code>win_manager.update_end_round_wins()</code>. </p> <p><code>total_cumulative_wins</code> incorporate wins from all game-types on a single betmode level, while <code>cumulative_base_wins</code> and <code>cumulative_free_wins</code> track the cumulative win amounts for the basegame and freegame respectively. </p>"},{"location":"source_section/win_manager/#spin-level-wins","title":"Spin-level wins","text":"<p>The <code>running_bet_win</code> tracks wins from the basegame and freegame modes and continuously increases during simulation steps. The final <code>running_bet_win</code> value will equal the payout multiplier <code>basegame_wins</code> and <code>freegame_wins</code>are single simulation level parameters which are reset when <code>run_spin()</code> is called. These values are subsequently used for the <code>lookUpTableSegmented</code> files, which helps to identify the contribution of different game-types to the final payout multiplier. </p> <p>The <code>spin_win</code> property tracks the win for a given <code>reveal</code> event. So for example is reset for each spin within a <code>freegame</code>. Finally the <code>tumble_win</code> property is used for tracking wins where there are consecutive win events within a single reveal, most commonly seen within tumbling/cascading games. We may want to keep track of the cumulative win amount resulting from multiple tumble events to update win-banners or apply multipliers at the end of the sequence. </p>"},{"location":"source_section/win_manager/#update-functions","title":"Update functions","text":"<p>There are several <code>WinManager</code> update functions used to update and reset the <code>spin_win</code> and gametype wins. The <code>running_bet_win</code> property does not need to be called explicitly, nor does the <code>cumulative_wins</code> (as this is called when the simulation is accepted and saved). The gametype should be updated explicitly though when the basegame actions have concluded, as well as at the end of each freegame spin (if applicable). This can be seen the sample <code>gamestate.run_spin()</code> game files:</p> <pre><code>self.win_manager.update_gametype_wins(self.gametype)\n</code></pre>"}]}